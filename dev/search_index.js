var documenterSearchIndex = {"docs":
[{"location":"concept_reference/demand/#","page":"-","title":"-","text":"The demand parameter represents a \"demand\" or a \"load\" of a commodity on a node. It appears in the node injection constraint, with positive values interpreted as \"demand\" or \"load\" for the modelled system, while negative values provide the system with \"influx\" or \"gain\". The fractional_demand parameter can be used to split demand into fractions, when desired.","category":"page"},{"location":"concept_reference/demand/#","page":"-","title":"-","text":"The demand parameter can also be included in custom unit_constraints using the demand_coefficient parameter for the node__unit_constraint relationship.","category":"page"},{"location":"concept_reference/ramp_down_cost/#","page":"-","title":"-","text":"By defining the ramp_down_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function whenever the unit ramps down its activity (i.e., when the ramp_down_unit_flow is nonzero) over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/nodal_balance_sense/#","page":"-","title":"-","text":"nodal_balance_sense determines whether or not a node is able to naturally consume or produce energy. The default value, ==, means that the node is unable to do any of that, and thus it needs to be perfectly balanced. The vale >= means that the node is a sink, that is, it can consume any amounts of energy. The value <= means that the node is a source, that is, it can produce any amounts of energy.","category":"page"},{"location":"concept_reference/unit__unit_constraint/#","page":"-","title":"-","text":"unit__unit_constraint is a two-dimensional relationship between a unit and a unit_constraint. The relationship specifies that a variable or variable(s) associated only with the unit (not a unit_flow for example) are involved in the constraint. For example, the unitsoncoefficient defined on unit__unit_constraint specifies the coefficient of the unit's units_on variable in the specified unit_constraint. ","category":"page"},{"location":"concept_reference/unit__unit_constraint/#","page":"-","title":"-","text":"See also unit_constraints","category":"page"},{"location":"concept_reference/max_gap/#","page":"-","title":"-","text":"This determines the optimality convergence criterion and is the benders gap tolerance for the master problem in a decomposed investments model. The benders gap is the relative difference between the current objective function upper bound(zupper) and lower bound (zlower) and is defined as 2*(zupper-zlower)/(zupper + zlower). When this value is lower than max_gap the benders algorithm will terminate having achieved satisgfactory optimality.","category":"page"},{"location":"concept_reference/representative_periods_mapping/#","page":"-","title":"-","text":"For representative periods with seasonal storages, SpineOpt.jl can be interlinked with the package SpinePeriods.jl. SpinePeriods.jl provides the representative_periods_mapping parameter, which maps each non-representative period of the whole optimization window to its representative temporal_block. The map is organized as timeseries (indicating the start of each the non-representative period) with the names of the representative temporal_blocks as entries. ","category":"page"},{"location":"concept_reference/operating_cost/#","page":"-","title":"-","text":"By defining the operating_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for operating costs associated with that unit over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/model_type/#","page":"-","title":"-","text":"This parameter is used, generally, to control model dependent functionality and specify model-level parameters for different models. Currently, the main use is to identify the model objects that represent the master and operational sub problems within a decomposed investment problem structure. To trigger the decomposed structure, a model object with model_type=:spineopt_master must exist and another with model_type=:spineopt_operations must also be present. To deactivate the decomposition functionality, the model_type of the master problem can be set to :spineopt_other","category":"page"},{"location":"concept_reference/model_type/#","page":"-","title":"-","text":"See also [decomposition]{@ref}","category":"page"},{"location":"concept_reference/compression_factor/#","page":"-","title":"-","text":"This parameter is specific to the use of pressure driven gas transfer. To represent a compression between to nodes in the gas network, the compression_factor can be defined. This factor ensures that the pressure of a node is equal to (or lower than) the pressure at the sending node times the compression_factor. The relationship connection__node__node that hosts this parameter should be defined in a way that the first node represents the origin node and the second node represents the compressed node.","category":"page"},{"location":"concept_reference/connection_type_list/#","page":"-","title":"-","text":"connection_type_list holds the possible values for the connection_type parameter. See connection_type for more details","category":"page"},{"location":"concept_reference/model__default_investment_stochastic_structure/#","page":"-","title":"-","text":"The model__default_investment_stochastic_structure relationship can be used to set model-wide default unit__investment_stochastic_structure, connection__investment_stochastic_structure, and node__investment_stochastic_structure relationships. Its main purpose is to allow users to avoid defining each relationship individually, and instead allow them to focus on defining only the exceptions. As such, any specific unit__investment_stochastic_structure, connection__investment_stochastic_structure, and node__investment_stochastic_structure relationships take priority over the model__default_investment_stochastic_structure relationship.","category":"page"},{"location":"concept_reference/units_started_up_coefficient/#","page":"-","title":"-","text":"The units_started_up_coefficient is an optional parameter that can be used to include the units_started_up variable of a unit in a unit_constraint via the unit__unit_constraint relationship. Essentially, units_started_up_coefficient appears as a coefficient for the units_started_up variable of the unit in the unit constraint.","category":"page"},{"location":"concept_reference/minimum_operating_point/#","page":"-","title":"-","text":"The definition of the ramp_up_limit parameter will trigger the creation of the Constraint on minimum operating point. It sets a lower bound on the value of the unit_flow variable for a unit that is online.","category":"page"},{"location":"concept_reference/minimum_operating_point/#","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/units_on_coefficient/#","page":"-","title":"-","text":"The units_on_coefficient is an optional parameter that can be used to include the units_on variable of a unit in a unit_constraint via the unit__unit_constraint relationship. Essentially, units_on_coefficient appears as a coefficient for the units_on variable of the unit in the unit constraint.","category":"page"},{"location":"concept_reference/curtailment_cost/#","page":"-","title":"-","text":"By defining the curtailment_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit's available capacity exceeds its activity (i.e., the unit_flow variable) over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/diff_coeff/#","page":"-","title":"-","text":"The diff_coeff parameter represents diffusion of a commodity between the two nodes in the node__node relationship. It appears as a coefficient on the node_state variable in the node injection constraint, essentially representing diffusion power per unit of state. Note that the diff_coeff is interpreted as one-directional, meaning that if one defines","category":"page"},{"location":"concept_reference/diff_coeff/#","page":"-","title":"-","text":"diff_coeff(node1=n1, node2=n2),","category":"page"},{"location":"concept_reference/diff_coeff/#","page":"-","title":"-","text":"there will only be diffusion from n1 to n2, but not vice versa. Symmetric diffusion is likely used in most cases, requiring defining the diff_coeff both ways","category":"page"},{"location":"concept_reference/diff_coeff/#","page":"-","title":"-","text":"diff_coeff(node1=n1, node2=n2) == diff_coeff(node1=n2, node2=n1).","category":"page"},{"location":"concept_reference/max_res_startup_ramp/#","page":"-","title":"-","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning upward reserves are provided to a upward_reserve node by contracted offline units holding available to startup. To include the provision of nonspinning upward reserves, the parameter max_res_startup_ramp needs to be defined on the corresponding unit__to_node relationship. This will trigger the generation of the variables nonspin_units_started_up and nonspin_ramp_upunitflow and the constraint on maximum upward nonspinning reserve provision. Note that max_res_startup_ramp is given as a fraction of the unit_capacity.","category":"page"},{"location":"concept_reference/max_res_startup_ramp/#","page":"-","title":"-","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/ramp_down_limit/#","page":"-","title":"-","text":"The definition of the ramp_down_limit parameter will trigger the creation of the Constraint on spinning downward ramps. It will limit the maximum decrease in the unit_flow variable between two consecutive timesteps for which the unit is online.","category":"page"},{"location":"concept_reference/ramp_down_limit/#","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/fix_start_up_unit_flow/#","page":"-","title":"-","text":"The fix_start_up_unit_flow parameter fixes the value of the start_up_unit_flow to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/fix_start_up_unit_flow/#","page":"-","title":"-","text":"Common uses for the parameter include e.g. providing initial values for the start_up_unit_flow, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the start_up_unit_flow variable is only fixed for time steps with defined fix_start_up_unit_flow parameter values.","category":"page"},{"location":"concept_reference/fix_start_up_unit_flow/#","page":"-","title":"-","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/fix_start_up_unit_flow/#","page":"-","title":"-","text":"Note that the mentioned start_up_unit_flow variable is only included if the parameter max_startup_ramp exist for the correspond unit__to_node or unit__from_node relationship. The usage of ramps is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/fix_storages_invested/#","page":"-","title":"-","text":"Used primarily to fix the value of the storages_invested variable which represents the point-in-time storage investment decision variable at a node and how many candidate storages are invested-in in a particular timeslice at the corresponding node. ","category":"page"},{"location":"concept_reference/fix_storages_invested/#","page":"-","title":"-","text":"See also investment_optimization, candidate_storages and storage_investment_variable_type","category":"page"},{"location":"concept_reference/shut_down_cost/#","page":"-","title":"-","text":"By defining the shut_down_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit shuts down over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/node__temporal_block/#","page":"-","title":"-","text":"This relationship links a node to a temporal_block and as such it will determine which temporal block governs the temporal horizon and resolution of the variables associated with this node. Specifically, the resolution of the temporal block will directly imply the time slices for which both the regular and ramping flow variables and their associated constraints are created.","category":"page"},{"location":"concept_reference/node__temporal_block/#","page":"-","title":"-","text":"For a more detailed description of how the temporal structure in SpineOpt can be created, see Temporal Framework.","category":"page"},{"location":"concept_reference/tax_in_unit_flow/#","page":"-","title":"-","text":"By defining the tax_in_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with all unit_flow variables with direction to_node over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/min_ratio_out_in_unit_flow/#","page":"-","title":"-","text":"The definition of the min_ratio_out_in_unit_flow parameter triggers the generation of the constraint_min_ratio_out_in_unit_flow and corresponds to a lower bound of the ratio between out and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. To enforce e.g. a minimum ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ng the min_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_in_out/#","page":"-","title":"-","text":"The fix_units_on_coefficient_in_out parameter is an optinal coefficient in the unit input-output ratio constraint controlled by the fix_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_in_out/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_out_in, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_in_out and max_units_on_coefficient_in_out.","category":"page"},{"location":"concept_reference/unit__node__node/#","page":"-","title":"-","text":"While the relationships unit__to_node and unit__to_node take care of the automatic generation of the unit_flow variables, the [unit__node__node] relationships hold the information how the different commodity flows of a unit interact. Only through this relationship and the associated parameters, the topology of a unit, i.e. which intakes lead to which porducts etc., becomes unambiguous.","category":"page"},{"location":"concept_reference/unit__node__node/#","page":"-","title":"-","text":"In almost all cases, at least one of the ..._ratio_... parameters will be defined, e.g. to set a fixed ratio between outgoing and incoming commodity flows of unit (see also e.g. fix_ratio_out_in_unit_flow). Note that the parameters can also be defined on a relationship between groups of objects, e.g. to force a fixed ratio between a group of nodes. In the triggered constraints, this will lead to an aggregation of the individual unit flows.","category":"page"},{"location":"concept_reference/fix_unit_flow_op/#","page":"-","title":"-","text":"If operating_points if defined on a certain unit__to_node or unit__from_node flow, the corresponding unit_flow flow variable is decomposed into a number of sub-variables, unit_flow_op one for each operating point, with an additional index, i to reference the specific operating point. fix_unit_flow_op can thus be used to fix the value of one or more of the variables as desired.","category":"page"},{"location":"concept_reference/upward_reserve/#","page":"-","title":"-","text":"If a node has a true is_reserve_node parameter, it will be treated as a reserve node in the model. To define whether the node corresponds to an upward or downward reserve commodity, the [upward_reserve] or the [downward_reserve] parameter needs to be set to true, respectively.","category":"page"},{"location":"concept_reference/unit__from_node/#","page":"-","title":"-","text":"The unit__to_node and unit__from_node unit relationships are core elements of SpineOpt. For each unit__to_node or unit__from_node, a unit_flow variable is automatically added to the model, i.e. a commodity flow of a unit to or from a specific node, respectively.","category":"page"},{"location":"concept_reference/unit__from_node/#","page":"-","title":"-","text":"Various parameters can be defined on the unit__from_node relationship, in order to constrain the associated unit flows. In most cases a unit_capacity will be defined for an upper bound on the commodity flows. Apart from that, ramping abilities of a unit can be defined. For further details on ramps see Ramping and Reserves.","category":"page"},{"location":"concept_reference/unit__from_node/#","page":"-","title":"-","text":"To associate costs with a certain commodity flows, cost terms, such as fuel_costs and vom_costs, can be included for the unit__from_node relationship.","category":"page"},{"location":"concept_reference/unit__from_node/#","page":"-","title":"-","text":"It is important to note, that the parameters associated with the unit__from_node can be defined either for a specific node, or for a group of nodes. Grouping nodes for the described parameters will result in an aggregation of the unit flows for the triggered constraint, e.g. the definition of the unit_capacity on a group of nodes will result in an upper bound on the sum of all individual unit_flows.","category":"page"},{"location":"concept_reference/unit_availability_factor/#","page":"-","title":"-","text":"To indicate that a unit is only available to a certain extend or at certain times of the optimization, the unit_availability_factor can be used. A typical use case could be an availability timeseries for a variable renewable energy source. By default the availability factor is set to 1. The availability is, among others, used in the constraintunitsavailable.","category":"page"},{"location":"concept_reference/fix_connections_invested_available/#","page":"-","title":"-","text":"The fix_connections_invested_available parameter represents a forced connection investment.","category":"page"},{"location":"concept_reference/fix_connections_invested_available/#","page":"-","title":"-","text":"In other words, it is the fix value of the connections_invested_available variable.","category":"page"},{"location":"concept_reference/stochastic_scenario/#","page":"-","title":"-","text":"Essentially, a stochastic_scenario is a label for an alternative period of time, describing one possibility of what might come to pass. They are the basic building blocks of the scenario-based Stochastic Framework in SpineOpt.jl, but aren't really meaningful on their own. Only when combined into a stochastic_structure using the stochastic_structure__stochastic_scenario and parent_stochastic_scenario__child_stochastic_scenario relationships, along with Parameters like the weight_relative_to_parents and stochastic_scenario_end, they become meaningful.","category":"page"},{"location":"concept_reference/connection_binary_gas_flow/#","page":"-","title":"-","text":"This parameter is necessary for the use pressure driven gas transfer, for which the direction of flow is not known a priori. The parameter connection_binary_gas_flow is a booelean method parameter, which - when set to true - triggers the generation of the binary variables binary_gas_connection_flow, which (together with the big_m parameter) forces the average flow through a pipeline to be unidirectional.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_out_in/#","page":"-","title":"-","text":"The fix_units_on_coefficient_out_in parameter is an optinal coefficient in the unit output-input ratio constraint controlled by the fix_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_out_in/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_in_out, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_out_in and max_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/Parameters/#Parameters-1","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"concept_reference/Parameters/#balance_type-1","page":"Parameters","title":"balance_type","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A selector for how the :nodal_balance constraint should be handled.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: balance_type_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: balance_type_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The balance_type parameter determines whether or not a node needs to be balanced, in the classical sense that the sum of flows entering the node is equal to the sum of flows leaving it.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The values balance_type_node (the default) and balance_type_group mean that the node is always balanced. The only exception is if the node belongs in a group that has itself balance_type equal to balance_type_group. The value balance_type_none means that the node doesn't need to be balanced.","category":"page"},{"location":"concept_reference/Parameters/#big_m-1","page":"Parameters","title":"big_m","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Sufficiently large number used for linearization bilinear terms, e.g. to enforce bidirectional flow for gas pipielines","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The big_m parameter is a property of the model object. The bigM method is commonly used for the purpose of recasting non-linear constraints into a mixed-integer reformulation. In SpineOpt, the bigM formulation is used to describe the sign of gas flow through a connection (if a pressure driven gas transfer model is used). The big_m parameter in combination with the binary variable binary_gas_connection_flow is used in the constraints on the gas flow capacity and the fixed node pressure points and ensures that the average flow through a pipeline is only in one direction and is constraint by the fixed pressure points from the outer approximation of the Weymouth equation. See Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling for reference.","category":"page"},{"location":"concept_reference/Parameters/#block_end-1","page":"Parameters","title":"block_end","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The end time for the temporal_block. Can be given either as a DateTime for a static end point, or as a Duration for an end point relative to the start of the current optimization.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: temporal_block","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Indicates the end of this temporal block. The default value is equal to a duration of 0. It is useful to distinguish here between two cases: a single solve, or a rolling window optimization.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"single solve When a Date time value is chosen, this is directly the end of the optimization for this temporal block. In a single solve optimization, a combination of block_start and block_end can easily be used to run optimizations that cover only part of the model horizon. Multiple temporal_block objects can then be used to create optimizations for disconnected time periods, which is commonly used in the method of representative days. The default value coincides with the model_end.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"rolling window optimization To create a temporal block that is rolling along with the optimization window, a rolling temporal block, a duration value should be chosen. The block_end parameter will in this case determine the size of the optimization window, with respect to the start of each optimization window. If multiple temporal blocks with different block_end parameters exist, the maximum value will determine the size of the optimization window. Note, this is different from the roll_forward parameter, which determines how much the window moves for after each optimization. For more info, see One single temporal_block. The default value is equal to the roll_forward parameter.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"To create a static temporalblock, that doesn't move along with the rolling optimization window, the `blockendneeds to be defined as aDateTime` value. #TODO: this is not yet supported","category":"page"},{"location":"concept_reference/Parameters/#block_start-1","page":"Parameters","title":"block_start","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The start time for the temporal_block. Can be given either as a DateTime for a static start point, or as a Duration for an start point relative to the start of the current optimization.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: temporal_block","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Indicates the start of this temporal block. The main use of this parameter is to create an offset from the model start. The default value is equal to a duration of 0. It is useful to distinguish here between two cases: a single solve, or a rolling window optimization.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"single solve When a Date time value is chosen, this is directly the start of the optimization for this temporal block. When a duration is chosen, it is added to the model_start to obtain the start of this temporal_block. In the case of a duration, the chosen value directly marks the offset of the optimization with respect to the model_start. The default value for this parameter is the model_start.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"rolling window optimization To create a temporal block that is rolling along with the optimization window, a rolling temporal block, a duration value should be chosen. The temporal block_start will again mark the offset of the optimization start but now with respect to the start of each optimization window.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"To create a static temporal block, that has a fixed block_start (and block_end) and does not move along with the rolling window but rather splats into the rolling window, once the rolling window hits the start of the static temporalblock, the `blockstartparameter needs to be defined as aDateTime` value. #TODO: this is not supported yet!","category":"page"},{"location":"concept_reference/Parameters/#candidate_connections-1","page":"Parameters","title":"candidate_connections","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The number of connections that may be invested in","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The candidate_connections parameter denotes the possibility of investing on a certain connection.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The default value of nothing means that the connection can't be invested in, because it's already in operation.  An integer value represents the maximum investment possible at any point in time, as a factor of the connection_capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"In other words, candidate_connections is the upper bound of the connections_invested_available variable.","category":"page"},{"location":"concept_reference/Parameters/#candidate_storages-1","page":"Parameters","title":"candidate_storages","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Determines the maximum number of new storages which may be invested in","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Within an investments problem candidate_storages determines the upper bound on the storages investment decision variable in constraint storages_invested_available. In constraint node_state_cap the maximum node state will be the product of the storages investment variable and node_state_cap. Thus, the interpretation of candidate_storages depends on @refstorage_investment_variable_type which determines the investment decision variable type. If storage_investment_variable_type is integer or binary, then candidate_storages represents the maximum number of discrete storages of size node_state_cap that may be invested in at the corresponding node. If storage_investment_variable_type is continuous, candidate_storages is more analagous to a maximum storage capacity with node_state_cap being analagous to a scaling parameter.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that candidate_storages is the main investment switch and setting a value other than none/nothing triggers the creation of the investment variable for storages at the corresponding node. Note that a value of zero will still trigger the variable creation but its value will be fixed to zero. This can be useful if as inspection of the related dual variables will yield the value of this resource.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also investment_optimization and storage_investment_variable_type","category":"page"},{"location":"concept_reference/Parameters/#candidate_units-1","page":"Parameters","title":"candidate_units","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Number of units which may be additionally constructed","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Within an investments problem candidate_units determines the upper bound on the unit investment decision variable in constraint units_invested_available. In constraint unit_flow_capacity the maximum unit_flow will be the product of the units_invested_available and the corresponding unit_capacity. Thus, the interpretation of candidate_units depends on @refunit_investment_variable_type which determines the unit investment decision variable type. If unit_investment_variable_type is integer or binary, then candidate_units represents the maximum number of discrete units that may be invested in. If unit_investment_variable_type is continuous, candidate_units is more analagous to a maximum storage capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that candidate_units is the main investment switch and setting a value other than none/nothing triggers the creation of the investment variable for the unit. Note that a value of zero will still trigger the variable creation but its value will be fixed to zero. This can be useful if as inspection of the related dual variables will yield the value of this resource.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also investment_optimization and unit_investment_variable_type","category":"page"},{"location":"concept_reference/Parameters/#commodity_lodf_tolerance-1","page":"Parameters","title":"commodity_lodf_tolerance","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"LODF tolerance?","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.1","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: commodity","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Given two connections, the line outage distribution factor (LODF) is the fraction of the pre-contingency flow on the first one, that will flow on the second after the contingency. commodity_lodf_tolerance is the minimum absolute value of the LODF that is considered meaningful. Any value below this tolerance (in absolute value) will be treated as zero.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The LODFs are used to model contingencies on some connections and their impact on some other connections. To model contingencies on a connection, set connection_contingency to true; to study the impact of such contingencies on another connection, set connection_monitored to true.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"In addition, define a commodity with commodity_physics set to commodity_physics_lodf, and associate that commodity (via node__commodity) to both connections' nodes (given by connection__to_node and connection__from_node).","category":"page"},{"location":"concept_reference/Parameters/#commodity_physics-1","page":"Parameters","title":"commodity_physics","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Defines if the commodity follows lodf or ptdf physics.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: commodity_physics_none","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: commodity_physics_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: commodity","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"This parameter determines the specific formulation used to carry out dc load flow within a model. To enable power transfer distribution factor (ptdf) based load flow for a network of nodes and connections, all nodes must be related to a commodity with commodity_physics set to  commodity_physics_ptdf. To enable security constraint unit comment based on ptdfs and line outage distribution factors (lodf) all nodes must be related to a commodity with commodity_physics set to commodity_physics_lodf. ","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also powerflow","category":"page"},{"location":"concept_reference/Parameters/#commodity_ptdf_threshold-1","page":"Parameters","title":"commodity_ptdf_threshold","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"PTDF threshold?","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0001","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: commodity","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Given a connection and a node, the power transfer distribution factor (PTDF) is the fraction of the flow injected into the node that will flow on the connection. commodity_ptdf_threshold is the minimum absolute value of the PTDF that is considered meaningful. Any value below this threshold (in absolute value) will be treated as zero.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The PTDFs are used to model DC power flow on certain connections. To model DC power flow on a connection, set connection_monitored to true.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"In addition, define a commodity with commodity_physics set to either commodity_physics_ptdf, or commodity_physics_lodf. and associate that commodity (via node__commodity) to both connections' nodes (given by connection__to_node and connection__from_node).","category":"page"},{"location":"concept_reference/Parameters/#compression_factor-1","page":"Parameters","title":"compression_factor","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The compression factor establishes a compression from an origin node to a receiving node, which are connected through a connection. The first node corresponds to the origin node, the second to the (compressed) destination node. Typically the value is >=1.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"This parameter is specific to the use of pressure driven gas transfer. To represent a compression between to nodes in the gas network, the compression_factor can be defined. This factor ensures that the pressure of a node is equal to (or lower than) the pressure at the sending node times the compression_factor. The relationship connection__node__node that hosts this parameter should be defined in a way that the first node represents the origin node and the second node represents the compressed node.","category":"page"},{"location":"concept_reference/Parameters/#connection_availability_factor-1","page":"Parameters","title":"connection_availability_factor","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Availability of the connection, acting as a multiplier on its connection_capacity. Typically between 0-1.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"To indicate that a connection is only available to a certain extend or at certain times of the optimization, the connection_availability_factor can be used. A typical use case could be an availability timeseries for connection with expected outage times. By default the availability factor is set to 1. The availability is, among others, used in the constraintconnectionflow_capacity.","category":"page"},{"location":"concept_reference/Parameters/#connection_binary_gas_flow-1","page":"Parameters","title":"connection_binary_gas_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"This parameter needs to true in order to represent bidirectional pressure drive gas transfer.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"This parameter is necessary for the use pressure driven gas transfer, for which the direction of flow is not known a priori. The parameter connection_binary_gas_flow is a booelean method parameter, which - when set to true - triggers the generation of the binary variables binary_gas_connection_flow, which (together with the big_m parameter) forces the average flow through a pipeline to be unidirectional.","category":"page"},{"location":"concept_reference/Parameters/#connection_capacity-1","page":"Parameters","title":"connection_capacity","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Limits the connection_flow variable to the to_node. to_node can be a group of nodes, in which case the sum of the connection_flow is constrained.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Defines the upper bound on the corresponding connection_flow variable. If the connection is a candidate connection, the effective connection_flow upper bound is the product of the investment variable, connections_invested_available and connection_capacity. If ptdf based dc load flow is enabled, connection_capacity represents the normal rating of a connection (line) while connectionemergencycapacity represents the maximum post contingency flow.","category":"page"},{"location":"concept_reference/Parameters/#connection_contingency-1","page":"Parameters","title":"connection_contingency","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A boolean flag for defining a contingency connection.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Specifies that the connection in question is to be included as a contingency when security constrained unit commitment is enabled. When using security constrained unit commitment by setting commodity_physics to commodity_physics_lodf, an N-1 security constraint is created for each monitored line (connection_monitored = true) for each specified contingency (connection_contingency = true). ","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also powerflow","category":"page"},{"location":"concept_reference/Parameters/#connection_conv_cap_to_flow-1","page":"Parameters","title":"connection_conv_cap_to_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for connection_capacity unit conversions in the case the connection_capacity value is incompatible with the desired connection_flow units.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The connection_conv_cap_to_flow can be used to perform the conversion between the measurement unit of the connection_capacity to the measurement unit of the connection_flow variable. The default of this parameter is 1, i.e. assuming that both are given in the same measurement unit.","category":"page"},{"location":"concept_reference/Parameters/#connection_emergency_capacity-1","page":"Parameters","title":"connection_emergency_capacity","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Emergy capacity of a connection?","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The connection_emergency_capacity parameter represents the maximum post-contingency flow on a monitored connection if ptdf and lodf based security constrained unit commitment is enabled (commodity_physics is set to [commodity_physics_lodf].)","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If you set this value, make sure that you also set connection_monitored to true for the involved connection.","category":"page"},{"location":"concept_reference/Parameters/#connection_flow_coefficient-1","page":"Parameters","title":"connection_flow_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"defines the unit constraint coefficient on the connection flow variable in the to direction","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node__unit_constraint and connection__to_node__unit_constraint","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The connection_flow_coefficient is an optional parameter that can be used to include the connection_flow variable from or to a node in a unit_constraint via the connection__from_node__unit_constraint and connection__to_node__unit_constraint relationships. Essentially, connection_flow_coefficient appears as a coefficient for the connection_flow variable from or to the node in the unit constraint.","category":"page"},{"location":"concept_reference/Parameters/#connection_flow_cost-1","page":"Parameters","title":"connection_flow_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Variable costs of a flow through a connection. E.g. EUR/MWh of energy throughput.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the connection_flow_cost parameter for a specific connection, a cost term will be added to the objective function that values all connection_flow variables associated with that connection during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#connection_flow_delay-1","page":"Parameters","title":"connection_flow_delay","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Delays the connection_flows associated with the latter node in respect to the connection_flows associated with the first node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: Dict{String, Any}(\"data\" => \"0h\", \"type\" => \"duration\")","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The connection_flow_delay parameter denotes the amount of time that it takes for the flow to go through a connection. In other words, the flow that enters the connection is only seen at the other side after connection_flow_delay units of time.","category":"page"},{"location":"concept_reference/Parameters/#connection_investment_cost-1","page":"Parameters","title":"connection_investment_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The per unit investment cost for the connection over the connection_investment_lifetime","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the connection_investment_cost parameter for a specific connection, a cost term will be added to the objective function whenever a connection investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#connection_investment_lifetime-1","page":"Parameters","title":"connection_investment_lifetime","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Determines the minimum investment lifetime of a connection. Once invested, it remains in service for this long","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"connection_investment_lifetime is the minimum amount of time that a connection has to stay in operation once it's invested-in. Only after that time, the connection can be decomissioned. Note that connection_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/Parameters/#connection_investment_variable_type-1","page":"Parameters","title":"connection_investment_variable_type","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Determines whether the investment variable is integer (variabletypeinteger) or continuous (variabletypecontinuous)","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: variable_type_integer","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: variable_type_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The connection_investment_variable_type parameter represents the type of the connections_invested_available decision variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The default value, variable_type_integer, means that only integer factors of the connection_capacity can be invested in. The value variable_type_continuous means that any fractional factor can also be invested in. The value variable_type_binary means that only a factor of 1 or zero are possible.","category":"page"},{"location":"concept_reference/Parameters/#connection_linepack_constant-1","page":"Parameters","title":"connection_linepack_constant","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The linepack constant is a property of gas pipelines and relates the linepack to the pressure of the adjacent nodes.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The linepack constant is a physical property of a connection representing a pipeline and holds information how the linepack flexibility relates to pressures of the adjacent nodes. If, and only if, this parameter is defined, the linepack flexibility of a pipeline can be modelled. The existence of the parameter triggers the generation of the constraint on line pack storage. The [connection_linepack_constant] should always be defined on the tuple (connection pipeline, linepack storage node, node group (containing both pressure nodes, i.e. start and end of the pipeline)). See also.","category":"page"},{"location":"concept_reference/Parameters/#connection_monitored-1","page":"Parameters","title":"connection_monitored","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A boolean flag for defining a contingency connection.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"When using ptdf-based load flow by setting commodity_physics to either commodity_physics_ptdf or commodity_physics_ptdf, a constraint is created for each connection for which connection_monitored = true. Thus, to monitor the ptdf-based flow on a particular connection connection_monitored must be set to true.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also powerflow","category":"page"},{"location":"concept_reference/Parameters/#connection_reactance-1","page":"Parameters","title":"connection_reactance","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Reactance of a connection.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The per unit reactance of a transmission line. Used in ptdf based dc load flow where the relative reactances of lines determine the ptdfs of the network and in lossless dc powerflow where the flow on a line is given by flow = 1/x(thetato-thetafrom) where x is the reatance of the line, thetato is the voltage angle of the remote node and thetafrom is the voltage angle of the sending node. ","category":"page"},{"location":"concept_reference/Parameters/#connection_reactance_base-1","page":"Parameters","title":"connection_reactance_base","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If the reactance is given for a p.u.  (e.g. p.u. = 100MW), the connection_reactance_base can be set to perform this conversion (e.g. *100).","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 1","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"As the connection_reactance is often given on a per unit basis, often different than the units used elsewhere, the connection_reactance_base parameter serves as a conversion factor, scaling the connection_reactance with its p.u..","category":"page"},{"location":"concept_reference/Parameters/#connection_resistance-1","page":"Parameters","title":"connection_resistance","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Resistance of a connection.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#connection_type-1","page":"Parameters","title":"connection_type","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A selector between a normal and a lossless bidirectional connection.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: connection_type_normal","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: connection_type_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used to control specific pre-processing actions on connections. Currently, the primary purpose of connection_type is to simplify the data that is required to define a simple bi-directional, lossless line. If connection_type=:connection_type_lossless_bidirectional, it is only necessary to specify the following minimum data:","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"relationship: connection__from_node\nrelationship: connection__to_node\nparameter: connection_capacity (defined on connection__from_node and/or connection__to_node)","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If connection_type=:connection_type_lossless_bidirectional the following pre-processing actions are taken:","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"reciprocal connection__from_node and connection__to_node relationships are created if they don't exist\na new connectionnodenode relationship is created if none exists already\nfixratioconnection_flow parameter is created with the value of 1 if no existing parameter found (therefore this value can be overridden)\nThe first connection_capacity parameter found is copied to connection__from_nodes and connection__to_nodes without a defined connection_capacity.","category":"page"},{"location":"concept_reference/Parameters/#constraint_sense-1","page":"Parameters","title":"constraint_sense","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A selector for the sense of the unit_constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: ==","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: constraint_sense_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit_constraint","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The constraint_sense parameter determines the sense of a custom user constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See User constraints for details.","category":"page"},{"location":"concept_reference/Parameters/#curtailment_cost-1","page":"Parameters","title":"curtailment_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Costs for curtailing generation. Essentially, accrues costs whenever unit_flow not operating at its maximum available capacity. E.g. EUR/MWh","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the curtailment_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit's available capacity exceeds its activity (i.e., the unit_flow variable) over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#cyclic_condition-1","page":"Parameters","title":"cyclic_condition","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If the cyclic condition is set to true for a storage node, the node_state at the end of the optimization window has to be larger than or equal to the initial storage state.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: node__temporal_block","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#demand-1","page":"Parameters","title":"demand","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Demand for the commodity of a node. Energy gains can be represented using negative demand.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The demand parameter represents a \"demand\" or a \"load\" of a commodity on a node. It appears in the node injection constraint, with positive values interpreted as \"demand\" or \"load\" for the modelled system, while negative values provide the system with \"influx\" or \"gain\". The fractional_demand parameter can be used to split demand into fractions, when desired.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The demand parameter can also be included in custom unit_constraints using the demand_coefficient parameter for the node__unit_constraint relationship.","category":"page"},{"location":"concept_reference/Parameters/#demand_coefficient-1","page":"Parameters","title":"demand_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"coefficient of the specified node's demand in the specified unit constraint","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: node__unit_constraint","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The demand_coefficient is an optional parameter that can be used to include the demand of the a node in a unit_constraint via the node__unit_constraint relationship. Essentially, demand_coefficient appears as a coefficient for the demand parameter of the connected node in the unit constraint.","category":"page"},{"location":"concept_reference/Parameters/#diff_coeff-1","page":"Parameters","title":"diff_coeff","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Commodity diffusion coefficient between two nodes. Effectively, denotes the diffusion power per unit of state from the first node to the second.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The diff_coeff parameter represents diffusion of a commodity between the two nodes in the node__node relationship. It appears as a coefficient on the node_state variable in the node injection constraint, essentially representing diffusion power per unit of state. Note that the diff_coeff is interpreted as one-directional, meaning that if one defines","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"diff_coeff(node1=n1, node2=n2),","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"there will only be diffusion from n1 to n2, but not vice versa. Symmetric diffusion is likely used in most cases, requiring defining the diff_coeff both ways","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"diff_coeff(node1=n1, node2=n2) == diff_coeff(node1=n2, node2=n1).","category":"page"},{"location":"concept_reference/Parameters/#downward_reserve-1","page":"Parameters","title":"downward_reserve","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Identifier for nodes providing downward reserves","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If a node has a true is_reserve_node parameter, it will be treated as a reserve node in the model. To define whether the node corresponds to an upward or downward reserve commodity, the [upward_reserve] or the [downward_reserve] parameter needs to be set to true, respectively.","category":"page"},{"location":"concept_reference/Parameters/#duration_unit-1","page":"Parameters","title":"duration_unit","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Defines the base temporal unit of the model. Currently supported values are either an hour or a minute.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: minute","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: duration_unit_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The duration_unit parameter specifies the unit of time in a model.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Two values are currently supported, hour (the default) and minute.","category":"page"},{"location":"concept_reference/Parameters/#fix_binary_gas_connection_flow-1","page":"Parameters","title":"fix_binary_gas_connection_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the value of the connection_flow_binary variable, and hence pre-determine the direction of flow in the connection.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The binary flow of a gas pipelines for pressure driven gas transfer is enables through the binary variable binary_gas_connection_flow and the big_m constant. To fix this binary variable, i.e. pre-define the direction of gas through the pipelines, the fix_binary_gas_connection_flow parameter can be used.","category":"page"},{"location":"concept_reference/Parameters/#fix_connection_flow-1","page":"Parameters","title":"fix_connection_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the value of the connection_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The fix_connection_flow parameter fixes the value of the connection_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#fix_connection_intact_flow-1","page":"Parameters","title":"fix_connection_intact_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the value of the connection_intact_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#fix_connections_invested-1","page":"Parameters","title":"fix_connections_invested","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Setting a value fixes the connections_invested variable accordingly","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#fix_connections_invested_available-1","page":"Parameters","title":"fix_connections_invested_available","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Setting a value fixes the connectionsinvestedavailable variable accordingly","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The fix_connections_invested_available parameter represents a forced connection investment.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"In other words, it is the fix value of the connections_invested_available variable.","category":"page"},{"location":"concept_reference/Parameters/#fix_node_pressure-1","page":"Parameters","title":"fix_node_pressure","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fixes the corresponding node_pressure variable to the provided value","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"In a pressure driven gas model, gas network nodes are associated with the node_pressure variable. In order to fix the pressure at a certain node or to give intial conditions the fix_node_pressure parameter can be used.","category":"page"},{"location":"concept_reference/Parameters/#fix_node_state-1","page":"Parameters","title":"fix_node_state","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fixes the corresponding node_state variable to the provided value. Can be used for e.g. fixing boundary conditions.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The fix_node_state parameter simply fixes the value of the node_state variable to the provided value, if one is found. Common uses for the parameter include e.g. providing initial values for node_state variables, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the node_state variables are only fixed for time steps with defined fix_node_state parameter values.","category":"page"},{"location":"concept_reference/Parameters/#fix_node_voltage_angle-1","page":"Parameters","title":"fix_node_voltage_angle","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fixes the corresponding node_voltage_angle variable to the provided value","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"For a lossless nodal DC power flow network, each node is associated with a node_voltage_angle variable. In order to fix the voltage angle at a certain node or to give initial conditions the fix_node_voltage_angle parameter can be used.","category":"page"},{"location":"concept_reference/Parameters/#fix_nonspin_ramp_down_unit_flow-1","page":"Parameters","title":"fix_nonspin_ramp_down_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the nonspin_ramp_down_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#fix_nonspin_ramp_up_unit_flow-1","page":"Parameters","title":"fix_nonspin_ramp_up_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the nonspin_ramp_up_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#fix_nonspin_units_shut_down-1","page":"Parameters","title":"fix_nonspin_units_shut_down","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the nonspin_units_shut_down variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#fix_nonspin_units_started_up-1","page":"Parameters","title":"fix_nonspin_units_started_up","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the nonspin_units_started_up variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#fix_nonspin_units_starting_up-1","page":"Parameters","title":"fix_nonspin_units_starting_up","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the nonspin_units_starting_up variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#fix_ramp_down_unit_flow-1","page":"Parameters","title":"fix_ramp_down_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the ramp_down_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#fix_ramp_up_unit_flow-1","page":"Parameters","title":"fix_ramp_up_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the ramp_up_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#fix_ratio_in_in_unit_flow-1","page":"Parameters","title":"fix_ratio_in_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the ratio between two unit_flows coming into the unit from the two nodes.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the fix_ratio_in_in_unit_flow parameter triggers the generation of the constraint_fix_ratio_in_in_unit_flow and fixes the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply. To enforce e.g. for a unit u a fixed share of 0.8 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the fix_ratio_in_in_unit_flow parameter would be set to 0.8 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/Parameters/#fix_ratio_in_out_unit_flow-1","page":"Parameters","title":"fix_ratio_in_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the ratio between an incoming unit_flow from the first node and an outgoing unit_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the fix_ratio_in_out_unit_flow parameter triggers the generation of the constraint_fix_ratio_in_out_unit_flow and fixes the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the from_node, i.e. the incoming flows to the unit, and the second node (or group of nodes), represents the to_node i.e. the outgoing flow from the unit. To enforce e.g. a fixed ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing gas flow to the node group el_heat (consisting of the two nodes el and heat), the fix_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/Parameters/#fix_ratio_out_in_connection_flow-1","page":"Parameters","title":"fix_ratio_out_in_connection_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the ratio between the connection_flow from the first node and the connection_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the fix_ratio_out_in_connection_flow parameter triggers the generation of the constraint_fix_ratio_out_in_connection_flow and fixes the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. In most cases the fix_ratio_out_in_connection_flow parameter is set to equal or lower than 1, linking the flows entering to the flows leaving the connection. The parameter can be used to e.g. account for losses over a connection in a certain direction.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that the ratio can also be defined for unit__node__node relationships, where one or both of the nodes correspond to node groups in order to impose a ratio on aggregated connection flows. ","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"To enforce e.g. a fixed ratio of 0.8 for a connection conn between its outgoing electricity flow to node el1 and its incoming flows from the node node el2, the fix_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship u__el1__el2.","category":"page"},{"location":"concept_reference/Parameters/#fix_ratio_out_in_unit_flow-1","page":"Parameters","title":"fix_ratio_out_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the ratio between an outgoing unit_flow to the first node and an incoming unit_flow from the second node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the fix_ratio_out_in_unit_flow parameter triggers the generation of the constraint_fix_ratio_out_in_unit_flow and fixes the ratio between out and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. To enforce e.g. a fixed ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ngthe fix_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/Parameters/#fix_ratio_out_out_unit_flow-1","page":"Parameters","title":"fix_ratio_out_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the ratio between two unit_flows going from the unit into the two nodes.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the fix_ratio_out_out_unit_flow parameter triggers the generation of the constraint_fix_ratio_out_out_unit_flow and fixes the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. To enforce a fixed ratio between to products of a unit u, e.g. fixing the share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"concept_reference/Parameters/#fix_shut_down_unit_flow-1","page":"Parameters","title":"fix_shut_down_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the shut_down_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The fix_shut_down_unit_flow parameter fixes the value of the shut_down_unit_flow to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Common uses for the parameter include e.g. providing initial values for the shut_down_unit_flow, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the shut_down_unit_flow variable is only fixed for time steps with defined fix_shut_down_unit_flow parameter values.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that the mentioned shut_down_unit_flow variable is only included if the parameter max_startup_ramp exist for the correspond unit__to_node or unit__from_node relationship. The usage of ramps is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/Parameters/#fix_start_up_unit_flow-1","page":"Parameters","title":"fix_start_up_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the start_up_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The fix_start_up_unit_flow parameter fixes the value of the start_up_unit_flow to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Common uses for the parameter include e.g. providing initial values for the start_up_unit_flow, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the start_up_unit_flow variable is only fixed for time steps with defined fix_start_up_unit_flow parameter values.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that the mentioned start_up_unit_flow variable is only included if the parameter max_startup_ramp exist for the correspond unit__to_node or unit__from_node relationship. The usage of ramps is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/Parameters/#fix_storages_invested-1","page":"Parameters","title":"fix_storages_invested","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used to fix the value of the storages_invested variable","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used primarily to fix the value of the storages_invested variable which represents the point-in-time storage investment decision variable at a node and how many candidate storages are invested-in in a particular timeslice at the corresponding node. ","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also investment_optimization, candidate_storages and storage_investment_variable_type","category":"page"},{"location":"concept_reference/Parameters/#fix_storages_invested_available-1","page":"Parameters","title":"fix_storages_invested_available","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used to fix the value of the storagesinvestedavailable variable","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used primarily to fix the value of the storages_invested_available variable which represents the storages investment decision variable and how many candidate storages are available at the corresponding node, time step and stochastic scenario. Used also in the decomposition framework to communicate the value of the master problem solution variables to the operational sub-problem. ","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also candidate_storages and investment_optimization","category":"page"},{"location":"concept_reference/Parameters/#fix_unit_flow-1","page":"Parameters","title":"fix_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The fix_unit_flow parameter fixes the value of the unit_flow variable to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Common uses for the parameter include e.g. providing initial values for the unit_flow variable, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the unit_flow variable is only fixed for time steps with defined fix_unit_flow parameter values.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/Parameters/#fix_unit_flow_op-1","page":"Parameters","title":"fix_unit_flow_op","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the unit_flow_op variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If operating_points if defined on a certain unit__to_node or unit__from_node flow, the corresponding unit_flow flow variable is decomposed into a number of sub-variables, unit_flow_op one for each operating point, with an additional index, i to reference the specific operating point. fix_unit_flow_op can thus be used to fix the value of one or more of the variables as desired.","category":"page"},{"location":"concept_reference/Parameters/#fix_units_invested-1","page":"Parameters","title":"fix_units_invested","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the value of the units_invested variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used primarily to fix the value of the units_invested variable which represents the point-in-time unit investment decision variable and how many candidate units are invested-in in a particular timeslice. ","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also investment_optimization, candidate_units and unit_investment_variable_type","category":"page"},{"location":"concept_reference/Parameters/#fix_units_invested_available-1","page":"Parameters","title":"fix_units_invested_available","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the value of the units_invested_available variable","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used primarily to fix the value of the units_invested_available variable which represents the unit investment decision variable and how many candidate units are invested-in and available at the corresponding node, time step and stochastic scenario. Used also in the decomposition framework to communicate the value of the master problem solution variables to the operational sub-problem. ","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also investment_optimization, candidate_units and unit_investment_variable_type","category":"page"},{"location":"concept_reference/Parameters/#fix_units_on-1","page":"Parameters","title":"fix_units_on","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fix the value of the units_on variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#fix_units_on_coefficient_in_in-1","page":"Parameters","title":"fix_units_on_coefficient_in_in","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the fix_ratio_in_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The fix_units_on_coefficient_in_in parameter is an optinal coefficient in the unit input-input ratio constraint controlled by the fix_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_out, fix_units_on_coefficient_out_in, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_in_in and max_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/Parameters/#fix_units_on_coefficient_in_out-1","page":"Parameters","title":"fix_units_on_coefficient_in_out","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the fix_ratio_in_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The fix_units_on_coefficient_in_out parameter is an optinal coefficient in the unit input-output ratio constraint controlled by the fix_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_out_in, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_in_out and max_units_on_coefficient_in_out.","category":"page"},{"location":"concept_reference/Parameters/#fix_units_on_coefficient_out_in-1","page":"Parameters","title":"fix_units_on_coefficient_out_in","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the fix_ratio_out_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The fix_units_on_coefficient_out_in parameter is an optinal coefficient in the unit output-input ratio constraint controlled by the fix_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_in_out, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_out_in and max_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/Parameters/#fix_units_on_coefficient_out_out-1","page":"Parameters","title":"fix_units_on_coefficient_out_out","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the fix_ratio_out_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The fix_units_on_coefficient_out_out parameter is an optinal coefficient in the unit output-output ratio constraint controlled by the fix_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_in_out, and fix_units_on_coefficient_out_in, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_out_out and max_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/Parameters/#fixed_pressure_constant_0-1","page":"Parameters","title":"fixed_pressure_constant_0","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fixed pressure points for pipelines for the outer approximation of the Weymouth approximation. The direction of flow is the first node in the relationship to the second node in the relationship.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"For the MILP representation of pressure driven gas transfer, we use an outer approximation approach as described by Schwele et al.. The Weymouth equation is approximated around fixed pressure points, as described by the constraint on fixed node pressure points, constraining the average flow in each direction dependent on the adjacent node pressures. The second fixed pressure constant, which will be multiplied with the pressure of the destination node, is represented by an Array value of the fixed_pressure_constant_0. The first pressure constant corresponds to the related parameter fixed_pressure_constant_1. Note that the fixed_pressure_constant_0 parameter should be defined on a connection__node__node relationship, for which the first node corresponds to the origin node, while the second node corresponds to the destination node. For a typical gas pipeline, the will be a fixed_pressure_constant_1  for both directions of flow.","category":"page"},{"location":"concept_reference/Parameters/#fixed_pressure_constant_1-1","page":"Parameters","title":"fixed_pressure_constant_1","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fixed pressure points for pipelines for the outer approximation of the Weymouth approximation. The direction of flow is the first node in the relationship to the second node in the relationship.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"For the MILP representation of pressure driven gas transfer, we use an outer approximation approach as described by Schwele et al.. The Weymouth equation is approximated around fixed pressure points, as described by the constraint on fixed node pressure points, constraining the average flow in each direction dependent on the adjacent node pressures. The first fixed pressure constant, which will be multiplied with the pressure of the origin node, is represented by an Array value of the fixed_pressure_constant_1. The second pressure constant corresponds to the related parameter fixed_pressure_constant_0. Note that the fixed_pressure_constant_1 parameter should be defined on a connection__node__node relationship, for which the first node corresponds to the origin node, while the second node corresponds to the destination node. For a typical gas pipeline, the will be a fixed_pressure_constant_1  for both directions of flow.","category":"page"},{"location":"concept_reference/Parameters/#fom_cost-1","page":"Parameters","title":"fom_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fixed operation and maintenance costs of a unit. Essentially, a cost coefficient on the number_of_units and unit_capacity parameters. E.g. EUR/MWh","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the fom_cost parameter for a specific unit, a cost term will be added to the objective function to account for the fixed operation and maintenance costs associated with that unit during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#frac_state_loss-1","page":"Parameters","title":"frac_state_loss","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Self-discharge coefficient for node_state variables. Effectively, represents the loss power per unit of state.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The frac_state_loss parameter allows setting self-discharge losses for nodes with the node_state variables enabled using the has_state variable. Effectively, the frac_state_loss parameter acts as a coefficient on the node_state variable in the node injection constraint, imposing losses for the node. In simple cases, storage losses are typically fractional, e.g. a frac_state_loss parameter value of 0.01 would represent 1% of node_state lost per unit of time. However, a more general definition of what the frac_state_loss parameter represents in SpineOpt would be loss power per unit of node_state.","category":"page"},{"location":"concept_reference/Parameters/#fractional_demand-1","page":"Parameters","title":"fractional_demand","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Fractional demand for node groups?","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Whenever a node is a member of a group, the fractional_demand parameter represents its share of the group's demand.","category":"page"},{"location":"concept_reference/Parameters/#fuel_cost-1","page":"Parameters","title":"fuel_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Variable fuel costs than can be attributed to a unit_flow. E.g. EUR/MWh","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the fuel_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for costs associated with the unit's fuel usage over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#graph_view_position-1","page":"Parameters","title":"graph_view_position","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node, connection__to_node, unit__from_node__unit_constraint, unit__from_node, unit__to_node__unit_constraint and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#has_pressure-1","page":"Parameters","title":"has_pressure","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A boolean flag for whether a node has a node_pressure variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If a node is to present a node in a pressure driven gas network, the boolean parameter has_pressure should be set true, in order to trigger the generation of the v{nodepressure} variable. The pressure at a certain node can also be constrainted through the parameters max_node_pressure and min_node_pressure. More details on the use of pressure driven gas transfer are described here","category":"page"},{"location":"concept_reference/Parameters/#has_state-1","page":"Parameters","title":"has_state","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A boolean flag for whether a node has a node_state variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The has_state parameter is simply a Bool flag for whether a node has a node_state variable. By default, it is set to false, so the nodes enforce instantaneous commodity balance according to the nodal balance and node injection constraints. If set to true, the node will have a node_state variable generated for it, allowing for commodity storage at the node. Note that you'll also have to specify a value for the state_coeff parameter, as otherwise the node_state variable has zero commodity capacity.","category":"page"},{"location":"concept_reference/Parameters/#has_voltage_angle-1","page":"Parameters","title":"has_voltage_angle","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A boolean flag for whether a node has a node_voltage_angle variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"For the use of node-based lossless DC powerflow, each node will be associated with a v{voltageangle} variable. To enable the generation of the variable in the optimization model, the boolean parameter has_voltage_angle should be set true. The voltage angle at a certain node can also be constrained through the parameters max_voltage_angle and min_voltage_angle. More details on the use of pressure driven gas transfer are described here","category":"page"},{"location":"concept_reference/Parameters/#is_active-1","page":"Parameters","title":"is_active","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If false, the object is excluded from the model if the tool filter object activity control is specified","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: true","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: commodity, connection, model, node, output, report, stochastic_scenario, stochastic_structure, temporal_block, unit_constraint and unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"is_acive is a universal, utility parameter that is defined for every object class. When used in conjunction with the activity_control feature, the is_active parameter allows one to control whether or not a specific object is active within a model or not. ","category":"page"},{"location":"concept_reference/Parameters/#is_reserve_node-1","page":"Parameters","title":"is_reserve_node","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A boolean flag for a reserve_node?","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the parameter is_reserve_node to true, a node is treated as a reserve node in the model. Units that are linked through a unit__to_node relationship will be able to provide balancing services to the reserve node, but within their technical feasibility. The mathematical formulation holds a chapter on Ramping and reserve constraints and the general concept of setting up a model with reserves is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/Parameters/#max_cum_in_unit_flow_bound-1","page":"Parameters","title":"max_cum_in_unit_flow_bound","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Set a maximum cumulative upped bound for a unit_flow?","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__commodity","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"To impose a limit on the cumulative in flows to a unit for the entire modelling horizon, e.g. to enforce limits on emissions, the max_cum_in_unit_flow_bound parameter can be used. Defining this parameter triggers the generation of the constraint_max_cum_in_unit_flow_bound.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Assuming for instance that the total intake of a unit u_A should not exceed 10MWh for the entire modelling horizon, then the max_cum_in_unit_flow_bound would need to take the value 10. (Assuming here that the unit_flow variable is in MW, and the model duration_unit is hours)","category":"page"},{"location":"concept_reference/Parameters/#max_gap-1","page":"Parameters","title":"max_gap","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Specifies the maximum optimality gap for the model. Currently only used for the master problem within a decomposed structure","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.05","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"This determines the optimality convergence criterion and is the benders gap tolerance for the master problem in a decomposed investments model. The benders gap is the relative difference between the current objective function upper bound(zupper) and lower bound (zlower) and is defined as 2*(zupper-zlower)/(zupper + zlower). When this value is lower than max_gap the benders algorithm will terminate having achieved satisgfactory optimality.","category":"page"},{"location":"concept_reference/Parameters/#max_iterations-1","page":"Parameters","title":"max_iterations","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Specifies the maximum number of iterations for the model. Currently only used for the master problem within a decomposed structure","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 10.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"When the model in question is of type :spineopt_master, this determines the maximum number of Benders iterations.","category":"page"},{"location":"concept_reference/Parameters/#max_node_pressure-1","page":"Parameters","title":"max_node_pressure","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum allowed gas pressure at node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If a node has a node_pressure variable (see also the parameter [has_pressure])(@ref) and this chapter), an upper bound on the pressure can be introduced through the max_node_pressure parameter, which triggers the generation of the maxmimum node pressure constraint.","category":"page"},{"location":"concept_reference/Parameters/#max_ratio_in_in_unit_flow-1","page":"Parameters","title":"max_ratio_in_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum ratio between two unit_flows coming into the unit from the two nodes.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the max_ratio_in_in_unit_flow parameter triggers the generation of the constraint_max_ratio_in_in_unit_flow and enforces an upper bound on the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply. To enforce e.g. for a unit u a maximum share of 0.8 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the max_ratio_in_in_unit_flow parameter would be set to 0.8 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/Parameters/#max_ratio_in_out_unit_flow-1","page":"Parameters","title":"max_ratio_in_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum ratio between an incoming unit_flow from the first node and an outgoing unit_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the max_ratio_in_out_unit_flow parameter triggers the generation of the constraint_max_ratio_in_out_unit_flow and set an upper bound on the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the from_node, i.e. the incoming flows to the unit, and the second node (or group of nodes), represents the to_node i.e. the outgoing flow from the unit. To enforce e.g. a maximum ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing gas flow to the node group el_heat (consisting of the two nodes el and heat), the max_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/Parameters/#max_ratio_out_in_connection_flow-1","page":"Parameters","title":"max_ratio_out_in_connection_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum ratio between the connection_flow from the first node and the connection_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the max_ratio_out_in_connection_flow parameter triggers the generation of the constraint_max_ratio_out_in_connection_flow and sets an upper bound on the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class connection__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the connection, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the connection.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that the ratio can also be defined for connection__node__node relationships, where one or both of the nodes correspond to node groups in order to impose a ratio on aggregated connection flows.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"To enforce e.g. a maximum ratio of 0.8 for a connection conn between its outgoing electricity flow to node commodity1 and its incoming flows from the node node commodity2, the max_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship conn__commodity1__commodity2.","category":"page"},{"location":"concept_reference/Parameters/#max_ratio_out_in_unit_flow-1","page":"Parameters","title":"max_ratio_out_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum ratio between an outgoing unit_flow to the first node and an incoming unit_flow from the second node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the max_ratio_out_in_unit_flow parameter triggers the generation of the constraint_max_ratio_out_in_unit_flow and enforces an upper bound on the ratio between outgoing and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. To enforce e.g. a maximum ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ng the max_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/Parameters/#max_ratio_out_out_unit_flow-1","page":"Parameters","title":"max_ratio_out_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum ratio between two unit_flows going from the unit into the two nodes.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the max_ratio_out_out_unit_flow parameter triggers the generation of the constraint_max_ratio_out_out_unit_flow and sets an upper bound on the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. To enforce a maximum ratio between to products of a unit u, e.g. setting the maximum share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"concept_reference/Parameters/#max_res_shutdown_ramp-1","page":"Parameters","title":"max_res_shutdown_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum non-spinning reserve ramp-down for online units providing reserves during shut-downs","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning downward reserves are provided to a downward_reserve node by contracted units holding available to shutdown. To include the provision of nonspinning downward reserves, the parameter max_res_shutdown_ramp needs to be defined on the corresponding unit__to_node relationship. This will trigger the generation of the variables nonspin_units_shut_down and nonspin_ramp_down_unit_flow and the constraint on maximum downward nonspinning reserve provision. Note that max_res_shutdown_ramp is given as a fraction of the unit_capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/Parameters/#max_res_startup_ramp-1","page":"Parameters","title":"max_res_startup_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum non-spinning reserve ramp-up for offline units scheduled for reserve provision","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning upward reserves are provided to a upward_reserve node by contracted offline units holding available to startup. To include the provision of nonspinning upward reserves, the parameter max_res_startup_ramp needs to be defined on the corresponding unit__to_node relationship. This will trigger the generation of the variables nonspin_units_started_up and nonspin_ramp_upunitflow and the constraint on maximum upward nonspinning reserve provision. Note that max_res_startup_ramp is given as a fraction of the unit_capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/Parameters/#max_shutdown_ramp-1","page":"Parameters","title":"max_shutdown_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum ramp-down during shutdowns","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#max_startup_ramp-1","page":"Parameters","title":"max_startup_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum ramp-up during startups","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the max_startup_ramp parameter will trigger the creation of the Constraint on upward start up ramp_up. It sets an upper bound on the unit_flow variable the timestep right after a startup.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/Parameters/#max_units_on_coefficient_in_in-1","page":"Parameters","title":"max_units_on_coefficient_in_in","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the max_ratio_in_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The max_units_on_coefficient_in_in parameter is an optinal coefficient in the unit input-input ratio constraint controlled by the max_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_out, max_units_on_coefficient_out_in, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_in_in and fix_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/Parameters/#max_units_on_coefficient_in_out-1","page":"Parameters","title":"max_units_on_coefficient_in_out","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the max_ratio_in_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The max_units_on_coefficient_in_out parameter is an optinal coefficient in the unit input-output ratio constraint controlled by the max_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_out_in, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_in_out and fix_units_on_coefficient_in_out.","category":"page"},{"location":"concept_reference/Parameters/#max_units_on_coefficient_out_in-1","page":"Parameters","title":"max_units_on_coefficient_out_in","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the max_ratio_out_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The max_units_on_coefficient_out_in parameter is an optinal coefficient in the unit output-input ratio constraint controlled by the max_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_in_out, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_out_in and fix_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/Parameters/#max_units_on_coefficient_out_out-1","page":"Parameters","title":"max_units_on_coefficient_out_out","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the max_ratio_out_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The max_units_on_coefficient_out_out parameter is an optinal coefficient in the unit output-output ratio constraint controlled by the max_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_out_in, and max_units_on_coefficient_in_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_out_out and fix_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/Parameters/#max_voltage_angle-1","page":"Parameters","title":"max_voltage_angle","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum allowed voltage angle at node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If a node has a node_voltage_angle variable (see also the parameter has_voltage_angle and this chapter), an upper bound on the pressure can be introduced through the max_voltage_angle parameter, which triggers the generation of the maximum node voltage angle constraint.","category":"page"},{"location":"concept_reference/Parameters/#min_down_time-1","page":"Parameters","title":"min_down_time","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum downtime of a unit after it shuts down.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#min_node_pressure-1","page":"Parameters","title":"min_node_pressure","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum allowed gas pressure at node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If a node has a node_pressure variable (see also the parameter [has_pressure])(@ref) and this chapter), a lower bound on the pressure can be introduced through the min_node_pressure parameter, which triggers the generation of the minimum node pressure constraint.","category":"page"},{"location":"concept_reference/Parameters/#min_ratio_in_in_unit_flow-1","page":"Parameters","title":"min_ratio_in_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum ratio between two unit_flows coming into the unit from the two nodes.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the min_ratio_in_in_unit_flow parameter triggers the generation of the constraint_min_ratio_in_in_unit_flow and sets a lower bound for the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply. To enforce e.g. for a unit u a minimum share of 0.2 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the min_ratio_in_in_unit_flow parameter would be set to 0.2 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/Parameters/#min_ratio_in_out_unit_flow-1","page":"Parameters","title":"min_ratio_in_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum ratio between an incoming unit_flow from the first node and an outgoing unit_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the min_ratio_in_out_unit_flow parameter triggers the generation of the constraint_min_ratio_in_out_unit_flow and enforces a lower bound on the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes, see) in this relationship represents the from_node, i.e. the incoming flow to the unit, and the second node (or group of nodes) represents the to_node i.e. the outgoing flow from the unit. To enforce e.g. a minimum ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing gas flow to the node group el_heat (consisting of the two nodes el and heat), the fix_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/Parameters/#min_ratio_out_in_connection_flow-1","page":"Parameters","title":"min_ratio_out_in_connection_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum ratio between the connection_flow from the first node and the connection_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the min_ratio_out_in_connection_flow parameter triggers the generation of the constraint_min_ratio_out_in_connection_flow and sets a lower bound on the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class connection__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the connection, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the connection.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that the ratio can also be defined for connection__node__node relationships, where one or both of the nodes correspond to node groups in order to impose a ratio on aggregated connection flows.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"To enforce e.g. a minimum ratio of 0.2 for a connection conn between its outgoing electricity flow to node commodity1 and its incoming flows from the node node commodity2, the min_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship conn__commodity1__commodity2.","category":"page"},{"location":"concept_reference/Parameters/#min_ratio_out_in_unit_flow-1","page":"Parameters","title":"min_ratio_out_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum ratio between an outgoing unit_flow to the first node and an incoming unit_flow from the second node.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the min_ratio_out_in_unit_flow parameter triggers the generation of the constraint_min_ratio_out_in_unit_flow and corresponds to a lower bound of the ratio between out and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. To enforce e.g. a minimum ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ng the min_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/Parameters/#min_ratio_out_out_unit_flow-1","page":"Parameters","title":"min_ratio_out_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum ratio between two unit_flows going from the unit into the two nodes.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the min_ratio_out_out_unit_flow parameter triggers the generation of the constraint_min_ratio_out_out_unit_flow and enforces a lower bound on the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. To enforce a minimum ratio between to products of a unit u, e.g. setting the minimum share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"concept_reference/Parameters/#min_res_shutdown_ramp-1","page":"Parameters","title":"min_res_shutdown_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum non-spinning reserve ramp-down for online units providing reserves during shut-downs","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning downward reserves are provided by contracted units holding available to shutdown to a downward_reserve node. If a unit is scheduled to provide nonspinning reserve, a limit on the minimum amount of reserves provided can be imposed by defining the parameter min_res_shutdown_ramp on a unit__to_node relationship, which triggers the constraint on minimum downward nonspinning reserve provision. The parameter min_res_shutdown_ramp is given as a fraction of the unit_capacity of the corresponding unit__to_node relationship.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that to include the provision of nonspinning downward reserves, the parameter max_res_shutdown_ramp needs to be defined on the corresponding unit__to_node relationship, which triggers the generation of the variables nonspin_units_shut_down and nonspin_ramp_down_unit_flow.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/Parameters/#min_res_startup_ramp-1","page":"Parameters","title":"min_res_startup_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum non-spinning reserve ramp-up for offline units scheduled for reserve provision","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning upward reserves are provided to an upward_reserve node by contracted offline units holding available to startup. If a unit is scheduled to provide nonspinning reserve, a limit on the minimum amount of reserves provided can be imposed by defining the parameter min_res_startup_ramp on a unit__to_node relationship, which triggers the constraint on minimum upward nonspinning reserve provision. The parameter min_res_startup_ramp is given as a fraction of the unit_capacity of the corresponding unit__to_node relationship.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that to include the provision of nonspinning upward reserves, the parameter max_res_startup_ramp needs to be defined on the corresponding unit__to_node relationship, which triggers the generation of the variables nonspin_units_started_up and nonspin_ramp_upunitflow.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/Parameters/#min_shutdown_ramp-1","page":"Parameters","title":"min_shutdown_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum ramp-up during startups","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#min_startup_ramp-1","page":"Parameters","title":"min_startup_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum ramp-up during startups","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the min_startup_ramp parameter will trigger the creation of the TODO. It sets a lower bound on the unit_flow variable the timestep right after a startup.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/Parameters/#min_units_on_coefficient_in_in-1","page":"Parameters","title":"min_units_on_coefficient_in_in","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the min_ratio_in_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The min_units_on_coefficient_in_in parameter is an optinal coefficient in the unit input-input ratio constraint controlled by the min_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_out, min_units_on_coefficient_out_in, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_in_in and fix_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/Parameters/#min_units_on_coefficient_in_out-1","page":"Parameters","title":"min_units_on_coefficient_in_out","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the min_ratio_in_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The min_units_on_coefficient_in_out parameter is an optinal coefficient in the unit input-output ratio constraint controlled by the min_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_out_in, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_in_out and fix_units_on_coefficient_in_out.","category":"page"},{"location":"concept_reference/Parameters/#min_units_on_coefficient_out_in-1","page":"Parameters","title":"min_units_on_coefficient_out_in","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the min_ratio_out_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The min_units_on_coefficient_out_in parameter is an optinal coefficient in the unit output-input ratio constraint controlled by the min_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_in_out, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_out_in and fix_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/Parameters/#min_units_on_coefficient_out_out-1","page":"Parameters","title":"min_units_on_coefficient_out_out","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the min_ratio_out_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The min_units_on_coefficient_out_out parameter is an optinal coefficient in the unit output-output ratio constraint controlled by the min_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_in_out, and min_units_on_coefficient_out_in, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_out_out and fix_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/Parameters/#min_up_time-1","page":"Parameters","title":"min_up_time","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum uptime of a unit after it starts up.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#min_voltage_angle-1","page":"Parameters","title":"min_voltage_angle","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum allowed voltage angle at node. ","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If a node has a node_voltage_angle variable (see also the parameter has_voltage_angle and this chapter), a lower bound on the pressure can be introduced through the min_voltage_angle parameter, which triggers the generation of the minimum node voltage angle constraint.","category":"page"},{"location":"concept_reference/Parameters/#minimum_operating_point-1","page":"Parameters","title":"minimum_operating_point","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum level for the unit_flow relative to the units_on online capacity.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the ramp_up_limit parameter will trigger the creation of the Constraint on minimum operating point. It sets a lower bound on the value of the unit_flow variable for a unit that is online.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/Parameters/#minimum_reserve_activation_time-1","page":"Parameters","title":"minimum_reserve_activation_time","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Duration a certain reserve product needs to be online/available","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The parameter minimum_reserve_activation_time is the duration a reserve product needs to be online, before it can be replaced by another (slower) reserve product.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"In SpineOpt, the parameter is used to model reserve provision through storages. If a storage provides reserves to a reserve node (see also is_reserve_node) one needs to ensure that the node state is sufficiently high to provide these scheduled reserves as least for the duration of the minimum_reserve_activation_time. The constraint on the minimum node state with reserve provision is trigger by the existence of the minimum_reserve_activation_time. See also Ramping and Reserves","category":"page"},{"location":"concept_reference/Parameters/#model_end-1","page":"Parameters","title":"model_end","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Defines the last timestamp to be modelled. Rolling optimization terminates after passing this point.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: Dict{String, Any}(\"data\" => \"2000-01-02T00:00:00\", \"type\" => \"date_time\")","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Together with the model_start parameter, it is used to define the temporal horizon of the model. In case of a single solve optimization, the parameter marks the end of the last timestep that is possibly part of the optimization. Note that it poses an upper bound, and that the optimization does not necessarily include this timestamp when the block_end parameters are more stringent.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"In case of a rolling horizon optimization, it will tell to the model to stop rolling forward once an optimization has been performed for which the result of the indicated timestamp has been kept in the final results. For example, assume that a model_end value of 2030-01-01T05:00:00 has been chosen, a block_end of 3h, and a roll_forward of 2h. The roll_forward parameter indicates here that the results of the first two hours of each optimization window are kept as final, therefore the last optimization window will span the timeframe [2030-01-01T04:00:00 - 2030-01-01T06:00:00].","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A DateTime value should be chosen for this parameter. ","category":"page"},{"location":"concept_reference/Parameters/#model_start-1","page":"Parameters","title":"model_start","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Defines the first timestamp to be modelled. Relative temporal_blocks refer to this value for their start and end.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: Dict{String, Any}(\"data\" => \"2000-01-01T00:00:00\", \"type\" => \"date_time\")","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Together with the model_end parameter, it is used to define the temporal horizon of the model. For a single solve optimization, it marks the timestamp from which the relative offset in a temporal_block is defined by the block_start parameter. In the rolling optimization framework, it does this for the first optimization window.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A DateTime value should be chosen for this parameter. ","category":"page"},{"location":"concept_reference/Parameters/#model_type-1","page":"Parameters","title":"model_type","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used to identify model objects as relating to the master problem or operational sub problems (default)","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: spineopt_operations","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: model_type_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"This parameter is used, generally, to control model dependent functionality and specify model-level parameters for different models. Currently, the main use is to identify the model objects that represent the master and operational sub problems within a decomposed investment problem structure. To trigger the decomposed structure, a model object with model_type=:spineopt_master must exist and another with model_type=:spineopt_operations must also be present. To deactivate the decomposition functionality, the model_type of the master problem can be set to :spineopt_other","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also [decomposition]{@ref}","category":"page"},{"location":"concept_reference/Parameters/#nodal_balance_sense-1","page":"Parameters","title":"nodal_balance_sense","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A selector for nodal_balance constraint sense.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: ==","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: constraint_sense_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"nodal_balance_sense determines whether or not a node is able to naturally consume or produce energy. The default value, ==, means that the node is unable to do any of that, and thus it needs to be perfectly balanced. The vale >= means that the node is a sink, that is, it can consume any amounts of energy. The value <= means that the node is a source, that is, it can produce any amounts of energy.","category":"page"},{"location":"concept_reference/Parameters/#node_opf_type-1","page":"Parameters","title":"node_opf_type","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A selector for node_opf_type?","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: node_opf_type_normal","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: node_opf_type_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used to identify the reference node (or slack bus) when ptdf based dc load flow is enabled (commodity_physics set to commodity_physics_ptdf or commodity_physics_lodf. To identify the reference node, set node_opf_type = :node_opf_type_reference","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also powerflow","category":"page"},{"location":"concept_reference/Parameters/#node_slack_penalty-1","page":"Parameters","title":"node_slack_penalty","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A penalty cost for node_slack_pos and node_slack_neg variables. The slack variables won't be included in the model unless there's a cost defined for them.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"node_slack_penalty triggers the creation of node slack variables, node_slack_pos and node_slack_neg.  This allows the model to violate the node_balance constraint with these violations penalised in the objective function  with a coefficient equal to node_slack_penalty. If node_slack_penalty = 0 the slack variables are created and violations are  unpenalised. If set to none or undefined, the variables are not created and violation of the node_balance constraint is  not possible. ","category":"page"},{"location":"concept_reference/Parameters/#node_state_cap-1","page":"Parameters","title":"node_state_cap","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The maximum permitted value for a node_state variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The node_state_cap parameter represents the maximum allowed value for the node_state variable. Note that in order for a node to have a node_state variable in the first place, the has_state parameter must be set to true. However, if the node has storage investments enabled using the candidate_storages parameter, the node_state_cap parameter acts as a coefficient for the storages_invested_available variable. Essentially, with investments, the node_state_cap parameter represents storage capacity per storage investment.","category":"page"},{"location":"concept_reference/Parameters/#node_state_coefficient-1","page":"Parameters","title":"node_state_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"coefficient of the specified node's state variable in the specified unit constraint","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: node__unit_constraint","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#node_state_min-1","page":"Parameters","title":"node_state_min","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The minimum permitted value for a node_state variable.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The node_state_min parameter sets the lower bound for the node_state variable, if one has been enabled by the [has_state] parameter. For reserve nodes with minimum_reserve_activation_time, the node_state_min is considered also via a special constraint.","category":"page"},{"location":"concept_reference/Parameters/#number_of_units-1","page":"Parameters","title":"number_of_units","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Denotes the number of 'sub units' aggregated to form the modelled unit.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Defines how many members a certain unit object represents. Typically this parameter takes a binary (UC) or integer (clustered UC) value. Together with the unit_availability_factor, this will determine the maximum number of members that can be online at any given time. (Thus restricting the units_on variable). It is possible to allow the model to increase the number_of_units itself, through Investment Optimization","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The default value for this parameter is 1.","category":"page"},{"location":"concept_reference/Parameters/#online_variable_type-1","page":"Parameters","title":"online_variable_type","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A selector for how the units_on variable is represented within the model.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: unit_online_variable_type_linear","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: unit_online_variable_type_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"online_variable_type is a method parameter closely related to the number_of_units and can take the values \"unit_online_variable_type_binary\", \"unit_online_variable_type_integer\", \"unit_online_variable_type_linear\". If the binary value is chosen, the units status is modelled as a binary (classic UC). For clustered unit commitment units, the integer type is applicable. Note that if the parameter is not defined, the default will be linear. If the units status is not crucial, this can reduce the computational burden.","category":"page"},{"location":"concept_reference/Parameters/#operating_cost-1","page":"Parameters","title":"operating_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Operating costs of a unit_flow variable. E.g. EUR/MWh.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the operating_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for operating costs associated with that unit over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#operating_points-1","page":"Parameters","title":"operating_points","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Decomposes the flow variable into a number of separate operating segment variables. Used to in conjunction with unit_incremental_heat_rate and/or unit_constraints","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If operating_points if defined as an array type on a certain unit__to_node or unit__from_node flow, the corresponding unit_flow flow variable is decomposed into a number of sub operating segment variables, unit_flow_op one for each operating segment, with an additional index, i to reference the specific operating segment. Each value in the array represents the upperbound of the operating segment, normalized on unitcapacity for the corresponding `unit__tonodeorunit__fromnodeflow.operatingpointsis used in conjunction with [unit\\_incremental\\_heat\\_rate](@ref) where the array dimension must match and is used to define the normalized operating point bounds for the corresponding incremental heat rate.operatingpoints` is also used in conjunction with [unit\\constraints](@ref) where the array dimension must match any corrponding piecewise linear unit_flow_coefficient. Here operating_points is used also to define the normalized operating point bounds for the corresponding unit_flow_coefficients.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that operating_points is defined on a capacity-normalized basis and the values represent the upper bound of the corresponding operating segment variable. So if operating_points is specified as [0.5, 1], this creates two operating segments, one from zero to 50% of the corresponding unit_capacity and a second from 50% to 100% of the corresponding unit_capacity.","category":"page"},{"location":"concept_reference/Parameters/#output_db_url-1","page":"Parameters","title":"output_db_url","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Database url for SpineOpt output.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: report","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The output_db_url parameter is the url of the databse to write the results of the model run. It overrides the value of the second argument passed to run_spineopt.","category":"page"},{"location":"concept_reference/Parameters/#ramp_down_cost-1","page":"Parameters","title":"ramp_down_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Costs of ramping down","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the ramp_down_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function whenever the unit ramps down its activity (i.e., when the ramp_down_unit_flow is nonzero) over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#ramp_down_costs-1","page":"Parameters","title":"ramp_down_costs","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Costs for ramping down","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#ramp_down_limit-1","page":"Parameters","title":"ramp_down_limit","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Limit the maximum ramp-down rate of an online unit, given as a fraction of the unitcapacity. [rampdown_limit] = %/t, e.g. 0.2/h","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the ramp_down_limit parameter will trigger the creation of the Constraint on spinning downward ramps. It will limit the maximum decrease in the unit_flow variable between two consecutive timesteps for which the unit is online.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/Parameters/#ramp_up_cost-1","page":"Parameters","title":"ramp_up_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Costs of ramping up","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the ramp_up_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function whenever the unit ramps up its activity (i.e., when the ramp_up_unit_flow is nonzero) over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#ramp_up_costs-1","page":"Parameters","title":"ramp_up_costs","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Costs for ramping up","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#ramp_up_limit-1","page":"Parameters","title":"ramp_up_limit","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Limit the maximum ramp-up rate of an online unit, given as a fraction of the unitcapacity. [rampup_limit] = %/t, e.g. 0.2/h","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The definition of the ramp_up_limit parameter will trigger the creation of the Constraint on spinning upwards ramp_up. It limits the maximum increase in the unit_flow variable between two consecutive timesteps for which the unit is online.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"For a more complete description of how ramping restrictions can be implemented, see Ramping and Reserves.","category":"page"},{"location":"concept_reference/Parameters/#representative_periods_mapping-1","page":"Parameters","title":"representative_periods_mapping","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Mapping from real timelices to their corresponding representative days","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: temporal_block","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"For representative periods with seasonal storages, SpineOpt.jl can be interlinked with the package SpinePeriods.jl. SpinePeriods.jl provides the representative_periods_mapping parameter, which maps each non-representative period of the whole optimization window to its representative temporal_block. The map is organized as timeseries (indicating the start of each the non-representative period) with the names of the representative temporal_blocks as entries. ","category":"page"},{"location":"concept_reference/Parameters/#res_start_up_cost-1","page":"Parameters","title":"res_start_up_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the res_start_up_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function whenever a non-spinning reserve unit starts up over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#reserve_procurement_cost-1","page":"Parameters","title":"reserve_procurement_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Procurement cost for reserves","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#resolution-1","page":"Parameters","title":"resolution","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Temporal resolution of the temporal_block. Essentially, divides the period between block_start and block_end into TimeSlices with the input resolution.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: Dict{String, Any}(\"data\" => \"1h\", \"type\" => \"duration\")","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: temporal_block","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"This parameter specifies the resolution of the temporal block, or in other words: the length of the timesteps used in the optimization run. Generally speaking, variables and constraints are generated for each timestep of an optimization. For example, the nodal balance constraint must hold for each timestep.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"An array of duration values can be used to have a resolution that varies with time itself. It can for example be used when uncertainty in one of the inputs rises as the optimization moves away from the model start. Think of a forecast of for instance wind power generation, which might be available in quarter hourly detail for one day in the future, and in hourly detail for the next two days. It is possible to take a quarter hourly resolution for the full horizon of three days. However, by lowering the temporal resolution after the first day, the computational burden is lowered substantially.","category":"page"},{"location":"concept_reference/Parameters/#right_hand_side-1","page":"Parameters","title":"right_hand_side","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The right-hand side, constant term in a unit_constraint. Can be time-dependent and used e.g. for complicated efficiency approximations.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit_constraint","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used to specify the right-hand-side, constant term in a unit_constraint. See also unit_constraints.","category":"page"},{"location":"concept_reference/Parameters/#roll_forward-1","page":"Parameters","title":"roll_forward","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Defines how much the model moves ahead in time between solves in a rolling optimization. Without this parameter, everything is solved in as a single optimization.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"This parameter defines how much the optimization window rolls forward in a rolling horizon optimization and should be expressed as a duration. In a rolling horizon optimization, a (small) part of the model is optimized at each iteration, after which the window rolls forward to optimize a different part. Overlap between consecutive optimization windows is possible. In the practical approaches presented in Temporal Framework, the rolling window optimization will be explained in more detail. The default value of this parameter is the entire model time horizon, which leads to a single optimization for the entire time horizon.","category":"page"},{"location":"concept_reference/Parameters/#shut_down_cost-1","page":"Parameters","title":"shut_down_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Costs of shutting down a 'sub unit', e.g. EUR/shutdown.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the shut_down_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit shuts down over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#start_up_cost-1","page":"Parameters","title":"start_up_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Costs of starting up a 'sub unit', e.g. EUR/startup.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the start_up_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit starts up over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#state_coeff-1","page":"Parameters","title":"state_coeff","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Represents the commodity content of a node_state variable in respect to the unit_flow and connection_flow variables. Essentially, acts as a coefficient on the node_state variable in the :node_injection constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The state_coeff parameter acts as a coefficient for the node_state variable in the node injection constraint. Essentially, it tells how the node_state variable should be treated in relation to the commodity flows and demand, and can be used for e.g. scaling or unit conversions. For most use-cases a state_coeff parameter value of 1.0 should suffice, e.g. having a MWh storage connected to MW flows in a model with hour as the basic unit of time.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that in order for the state_coeff parameter to have an impact, the node must first have a node_state variable to begin with, defined using the has_state parameter. By default, the state_coeff is set to zero as a precaution, so that the user always has to set its value explicitly for it to have an impact on the model.","category":"page"},{"location":"concept_reference/Parameters/#stochastic_scenario_end-1","page":"Parameters","title":"stochastic_scenario_end","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A Duration for when a stochastic_scenario ends and its child_stochastic_scenarios start. Values are interpreted relative to the start of the current solve, and if no value is given, the stochastic_scenario is assumed to continue indefinitely.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: stochastic_structure__stochastic_scenario","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The stochastic_scenario_end is a Duration-type parameter, defining when a stochastic_scenario ends relative to the start of the current optimization. As it is a parameter for the stochastic_structure__stochastic_scenario relationship, different stochastic_structures can have different values for the same stochastic_scenario, making it possible to define slightly different stochastic_structures using the same stochastic_scenarios. See the Stochastic Framework section for more information about how different stochastic_structures interact in SpineOpt.jl.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"When a stochastic_scenario ends at the point in time defined by the stochastic_scenario_end parameter, it spawns its children according to the parent_stochastic_scenario__child_stochastic_scenario relationship. Note that the children will be inherently assumed to belong to the same stochastic_structure their parent belonged to, even without explicit stochastic_structure__stochastic_scenario relationships! Thus, you might need to define the weight_relative_to_parents parameter for the children.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If no stochastic_scenario_end is defined, the stochastic_scenario is assumed to go on indefinitely.","category":"page"},{"location":"concept_reference/Parameters/#storage_investment_cost-1","page":"Parameters","title":"storage_investment_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Determines the investment cost per unit state_cap over the investment life of a storage","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the storage_investment_cost parameter for a specific node, a cost term will be added to the objective function whenever a storage investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#storage_investment_lifetime-1","page":"Parameters","title":"storage_investment_lifetime","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum lifetime for storage investment decisions.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Duration parameter that determines the minimum duration of storage investment decisions. Once a storage has been invested-in, it must remain invested-in for storage_investment_lifetime. Note that storage_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also investment_optimization and candidate_storages","category":"page"},{"location":"concept_reference/Parameters/#storage_investment_variable_type-1","page":"Parameters","title":"storage_investment_variable_type","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Determines whether the storage investment variable is continuous (usually representing capacity) or integer (representing discrete units invested)","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: variable_type_integer","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: variable_type_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Within an investments problem storage_investment_variable_type determines the storage investment decision variable type. Since a node's node_state will be limited to the product of the investmentvariable and the corresponding [node\\state_cap](@ref) and since candidate_storages represents the upper bound of the storage investment decision variable, storage_investment_variable_type thus determines what the investment decision represents. If storage_investment_variable_type is integer or binary, then candidate_storages represents the maximum number of discrete storages that may be invested-in. If storage_investment_variable_type is continuous, candidate_storages is more analagous to a capacity with node_state_cap being analagous to a scaling parameter. For example, if storage_investment_variable_type = integer, candidate_storages = 4 and node_state_cap = 1000 MWh, then the investment decision is how many 1000h MW storages to build. If storage_investment_variable_type = continuous, candidate_storages = 1000 and node_state_cao = 1 MWh, then the investment decision is how much storage capacity to build. Finally, if storage_investment_variable_type = integer, candidate_storages = 10 and node_state_cap = 100 MWh, then the investment decision is many 100MWh storage blocks to build.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also investment_optimization and candidate_storages","category":"page"},{"location":"concept_reference/Parameters/#tax_in_unit_flow-1","page":"Parameters","title":"tax_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Tax costs for incoming unit_flows on this node. E.g. EUR/MWh.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the tax_in_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with all unit_flow variables with direction to_node over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#tax_net_unit_flow-1","page":"Parameters","title":"tax_net_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Tax costs for net incoming and outgoing unit_flows on this node. Incoming flows accrue positive net taxes, and outgoing flows accrue negative net taxes.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the tax_net_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with the net total of all unit_flow variables with the direction to\\_node for this specific node minus all unit_flow variables with direction from\\_node.","category":"page"},{"location":"concept_reference/Parameters/#tax_out_unit_flow-1","page":"Parameters","title":"tax_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Tax costs for outgoing unit_flows from this node. E.g. EUR/MWh.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the tax_out_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with all unit_flow variables with direction from_node over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#unit_availability_factor-1","page":"Parameters","title":"unit_availability_factor","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Availability of the unit, acting as a multiplier on its unit_capacity. Typically between 0-1.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"To indicate that a unit is only available to a certain extend or at certain times of the optimization, the unit_availability_factor can be used. A typical use case could be an availability timeseries for a variable renewable energy source. By default the availability factor is set to 1. The availability is, among others, used in the constraintunitsavailable.","category":"page"},{"location":"concept_reference/Parameters/#unit_capacity-1","page":"Parameters","title":"unit_capacity","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Maximum unit_flow capacity of a single 'sub_unit' of the unit.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"To set an upper bound on the commodity flow of a unit in a certain direction, the unit_capacity constraint needs to be defined on a unit__to_node or unit__from_node relationship. By defining the parameter, the unit_flow variables to or from a node or a group of nodes will be constraint by the capacity constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Note that if the unit_capacity parameter is defined on a node group, the sum of all unit_flows within the specified node group will be constrained by the unit_capacity.","category":"page"},{"location":"concept_reference/Parameters/#unit_conv_cap_to_flow-1","page":"Parameters","title":"unit_conv_cap_to_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Optional coefficient for unit_capacity unit conversions in the case the unit_capacity value is incompatible with the desired unit_flow units.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#unit_flow_coefficient-1","page":"Parameters","title":"unit_flow_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Coefficient of a unit_flow variable for a custom unit_constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node__unit_constraint and unit__to_node__unit_constraint","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The unit_flow_coefficient is an optional parameter that can be used to include the unit_flow or unit_flow_op variables from or to a node in a unit_constraint via the unit__from_node__unit_constraint and unit__to_node__unit_constraint relationships. Essentially, unit_flow_coefficient appears as a coefficient for the unit_flow and unit_flow_op variables from or to the node in the unit constraint.","category":"page"},{"location":"concept_reference/Parameters/#unit_idle_heat_rate-1","page":"Parameters","title":"unit_idle_heat_rate","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Flow from node1 per unit time and per units_on that results in no additional flow to node2","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used to implement the no-load or idle heat rate of a unit. This is the y-axis offset of the heat rate function and is the fuel consumed per unit time when a unit is online and that results in no additional output. This is defined on the unit__node__node relationship and it is assumed that the input flow from node 1 represents fuel consumption and the output flow to node 2 is the elecrical output. While the units depend on the data, unit_idle_heat_rate is generally expressed in GJ/hr. Used in conjunction with unit_incremental_heat_rate. unit_idle_heat_rate is only currently considered if unit_incremental_heat_rate is specified. A trivial unit_incremental_heat_rate of zero can be defined if there is no incremental heat rate.","category":"page"},{"location":"concept_reference/Parameters/#unit_incremental_heat_rate-1","page":"Parameters","title":"unit_incremental_heat_rate","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Standard piecewise incremental heat rate where node1 is assumed to be the fuel and node2 is assumed to be electriciy. Assumed monotonically increasing. Array type or single coefficient where the number of coefficients must match the dimensions of unit_operating_points","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used to implement simple or piecewise linear incremental heat rate functions. Used in the constraint unit_pw_heat_rate - the input fuel flow at node 1 is the sum of the electrical MW output at node 2 times the incremental heat rate over all heat rate segments, plus the unit_idle_heat_rate. The units are detmerined by the data, but generally, incremental heat rates are given in GJ/MWh. Note that the formulation assumes a convex, monitonically increasing heat rate function. The formulation relies on optimality to load the heat rate segments in the correct order and no additional integer variables are created to enforce the correct loading order. The heat rate segment MW operating points are defined by operating_points. ","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"To implement a simple incremental heat rate function,unit_incremental_heat_rate should be given as a simple scalar representing the incremental heat rate over the entire operating range of the unit. To implement a piecewise linear heat rate function, unit_incremental_heat_rate should be specified as an array type. It is then used in conjunction with the unit parameter operating_points which should also be defined as an array type of equal dimension. When defined as an array type unit_incremental_heat_rate[i] is the effective incremental heat rate between operating_pointsi-1 and operating_points[i]. Note that operating_points is defined on a capacity-normalized basis so if operatingpoints is specified as [0.5, 1], this creates two operating segments, one from zero to 50% of the corresponding [unit\\capacity](@ref) and a second from 50% to 100% of the corresponding unit_capacity.","category":"page"},{"location":"concept_reference/Parameters/#unit_investment_cost-1","page":"Parameters","title":"unit_investment_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Investment cost per 'sub unit' built.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the unit_investment_cost parameter for a specific unit, a cost term will be added to the objective function whenever a unit investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#unit_investment_lifetime-1","page":"Parameters","title":"unit_investment_lifetime","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Minimum lifetime for unit investment decisions.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Duration parameter that determines the minimum duration of unit investment decisions. Once a unit has been invested-in, it must remain invested-in for unit_investment_lifetime. Note that unit_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also investment_optimization and candidate_units","category":"page"},{"location":"concept_reference/Parameters/#unit_investment_variable_type-1","page":"Parameters","title":"unit_investment_variable_type","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Determines whether investment variable is integer or continuous.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: unit_investment_variable_type_continuous","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: unit_investment_variable_type_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Within an investments problem unit_investment_variable_type determines the unit investment decision variable type. Since the unit_flows will be limited to the product of the investmentvariable and the corresponding [unit\\capacity](@ref) for each unit_flow and since candidate_units represents the upper bound of the investment decision variable, unit_investment_variable_type thus determines what the investment decision represents. If unit_investment_variable_type is integer or binary, then candidate_units represents the maximum number of discrete units that may be invested. If unit_investment_variable_type is continuous, candidate_units is more analagous to a capacity with unit_capacity being analagous to a scaling parameter. For example, if unit_investment_variable_type = integer, candidate_units = 4 and unit_capacity for a particular unit_flow = 400 MW, then the investment decision is how many 400 MW units to build. If unit_investment_variable_type = continuous, candidate_units = 400 and unit_capacity for a particular unit_flow = 1 MW, then the investment decision is how much capacity if this particular unit to build. Finally, if unit_investment_variable_type = integer, candidate_units = 10 and unit_capacity for a particular unit_flow = 50 MW, then the investment decision is many 50MW blocks of capacity of this particular unit to build.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"See also investment_optimization and candidate_units","category":"page"},{"location":"concept_reference/Parameters/#unit_start_flow-1","page":"Parameters","title":"unit_start_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Flow from node1 that is incurred when a unit is started up.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Used to implement unit startup fuel consumption where node 1 is assumed to be input fuel and node 2 is assumed to be output elecrical energy. This is a flow from node 1 that is incurred when the value of the variable unitsstartedup is 1 in the corresponding time period. This flow does not result in additional output flow at node 2. Used in conjunction with unit_incremental_heat_rate. unit_start_flow is only currently considered if unit_incremental_heat_rate is specified. A trivial unit_incremental_heat_rate of zero can be defined if there is no incremental heat rate.","category":"page"},{"location":"concept_reference/Parameters/#units_on_coefficient-1","page":"Parameters","title":"units_on_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Coefficient of a units_on variable for a custom unit_constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__unit_constraint","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The units_on_coefficient is an optional parameter that can be used to include the units_on variable of a unit in a unit_constraint via the unit__unit_constraint relationship. Essentially, units_on_coefficient appears as a coefficient for the units_on variable of the unit in the unit constraint.","category":"page"},{"location":"concept_reference/Parameters/#units_started_up_coefficient-1","page":"Parameters","title":"units_started_up_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Coefficient of a units_started_up variable for a custom unit_constraint.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__unit_constraint","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The units_started_up_coefficient is an optional parameter that can be used to include the units_started_up variable of a unit in a unit_constraint via the unit__unit_constraint relationship. Essentially, units_started_up_coefficient appears as a coefficient for the units_started_up variable of the unit in the unit constraint.","category":"page"},{"location":"concept_reference/Parameters/#upward_reserve-1","page":"Parameters","title":"upward_reserve","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Identifier for nodes providing upward reserves","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"If a node has a true is_reserve_node parameter, it will be treated as a reserve node in the model. To define whether the node corresponds to an upward or downward reserve commodity, the [upward_reserve] or the [downward_reserve] parameter needs to be set to true, respectively.","category":"page"},{"location":"concept_reference/Parameters/#vom_cost-1","page":"Parameters","title":"vom_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Variable operating costs of a unit_flow variable. E.g. EUR/MWh.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"By defining the vom_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for the variable operation and maintenance costs associated with that unit over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#weight-1","page":"Parameters","title":"weight","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Weighting factor of the temporal block associated with the objective function","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: temporal_block","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#weight_relative_to_parents-1","page":"Parameters","title":"weight_relative_to_parents","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The weight of the stochastic_scenario in the objective function relative to its parents.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: stochastic_structure__stochastic_scenario","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The weight_relative_to_parents parameter defines how much weight the stochastic_scenario gets in the Objective function. As a stochastic_structure__stochastic_scenario relationship parameter, different  stochastic_structures can use different weights for the same stochastic_scenario. Note that every stochastic_scenario that appears in the model must have a weight_relative_to_parents defined for it related to the used stochastic_structure! See the Stochastic Framework section for more information about how different stochastic_structures interact in SpineOpt.jl.)","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Since the Stochastic Framework in SpineOpt.jl supports stochastic directed acyclic graphs instead of simple stochastic trees, it is possible to define stochastic_structures with converging stochastic_scenarios. In these cases, the child stochastic_scenarios inherint the weight of all of their parents, and the final weight that will appear in the Objective function is calculated as shown below:","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"# For root `stochastic_scenarios` (meaning no parents)\n\nweight(scenario) = weight_relative_to_parents(scenario)\n\n# If not a root `stochastic_scenario`\n\nweight(scenario) = sum([weight(parent) * weight_relative_to_parents(scenario)] for parent in parents)","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"The above calculation is performed starting from the roots, generation by generation, until the leaves of the stochastic DAG. Thus, the final weight of each stochastic_scenario is dependent on the weight_relative_to_parents Parameters of all its ancestors.","category":"page"},{"location":"concept_reference/Parameters/#write_lodf_file-1","page":"Parameters","title":"write_lodf_file","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A boolean flag for whether the LODF values should be written to a results file.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#write_mps_file-1","page":"Parameters","title":"write_mps_file","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A selector for writing an .mps file of the model.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: write_mps_file_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#write_ptdf_file-1","page":"Parameters","title":"write_ptdf_file","text":"","category":"section"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"A boolean flag for whether the LODF values should be written to a results file.","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/#","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/unit__to_node__unit_constraint/#","page":"-","title":"-","text":"unit__to_node__unit_constraint is a three-dimensional relationship between a unit, a node and a unit_constraint. The relationship specifies that the unit_flow variable from the specified unit to the specified node is involved in the specified unit_constraint. Parameters on this relationship generally apply to this specific unit_flow variable. For example the parameter unitflowcoefficient defined on unit__to_node__unit_constraint represents the coefficient on the specific unit_flow variable in the specified unit_constraint","category":"page"},{"location":"concept_reference/connection_type/#","page":"-","title":"-","text":"Used to control specific pre-processing actions on connections. Currently, the primary purpose of connection_type is to simplify the data that is required to define a simple bi-directional, lossless line. If connection_type=:connection_type_lossless_bidirectional, it is only necessary to specify the following minimum data:","category":"page"},{"location":"concept_reference/connection_type/#","page":"-","title":"-","text":"relationship: connection__from_node\nrelationship: connection__to_node\nparameter: connection_capacity (defined on connection__from_node and/or connection__to_node)","category":"page"},{"location":"concept_reference/connection_type/#","page":"-","title":"-","text":"If connection_type=:connection_type_lossless_bidirectional the following pre-processing actions are taken:","category":"page"},{"location":"concept_reference/connection_type/#","page":"-","title":"-","text":"reciprocal connection__from_node and connection__to_node relationships are created if they don't exist\na new connectionnodenode relationship is created if none exists already\nfixratioconnection_flow parameter is created with the value of 1 if no existing parameter found (therefore this value can be overridden)\nThe first connection_capacity parameter found is copied to connection__from_nodes and connection__to_nodes without a defined connection_capacity.","category":"page"},{"location":"concept_reference/ramp_up_cost/#","page":"-","title":"-","text":"By defining the ramp_up_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function whenever the unit ramps up its activity (i.e., when the ramp_up_unit_flow is nonzero) over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/unit__to_node/#","page":"-","title":"-","text":"The unit__to_node and unit__from_node unit relationships are core elements of SpineOpt. For each unit__to_node or unit__from_node, a unit_flow variable is automatically added to the model, i.e. a commodity flow of a unit to or from a specific node, respectively.","category":"page"},{"location":"concept_reference/unit__to_node/#","page":"-","title":"-","text":"Various parameters can be defined on the unit__to_node relationship, in order to constrain the associated unit flows. In most cases a unit_capacity will be defined for an upper bound on the commodity flows. Apart from that, ramping abilities of a unit can be defined. For further details on ramps see Ramping and Reserves.","category":"page"},{"location":"concept_reference/unit__to_node/#","page":"-","title":"-","text":"To associate costs with a certain commodity flows, cost terms, such as fuel_costs and vom_costs, can be included for the unit__to_node relationship.","category":"page"},{"location":"concept_reference/unit__to_node/#","page":"-","title":"-","text":"It is important to note, that the parameters associated with the unit__to_node can be defined either for a specific node, or for a group of nodes. Grouping nodes for the described parameters will result in an aggregation of the unit flows for the triggered constraint, e.g. the definition of the unit_capacity on a group of nodes will result in an upper bound on the sum of all individual unit_flows.","category":"page"},{"location":"concept_reference/connection_investment_cost/#","page":"-","title":"-","text":"By defining the connection_investment_cost parameter for a specific connection, a cost term will be added to the objective function whenever a connection investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/min_ratio_in_out_unit_flow/#","page":"-","title":"-","text":"The definition of the min_ratio_in_out_unit_flow parameter triggers the generation of the constraint_min_ratio_in_out_unit_flow and enforces a lower bound on the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes, see) in this relationship represents the from_node, i.e. the incoming flow to the unit, and the second node (or group of nodes) represents the to_node i.e. the outgoing flow from the unit. To enforce e.g. a minimum ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing gas flow to the node group el_heat (consisting of the two nodes el and heat), the fix_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/unit_investment_cost/#","page":"-","title":"-","text":"By defining the unit_investment_cost parameter for a specific unit, a cost term will be added to the objective function whenever a unit investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/number_of_units/#","page":"-","title":"-","text":"Defines how many members a certain unit object represents. Typically this parameter takes a binary (UC) or integer (clustered UC) value. Together with the unit_availability_factor, this will determine the maximum number of members that can be online at any given time. (Thus restricting the units_on variable). It is possible to allow the model to increase the number_of_units itself, through Investment Optimization","category":"page"},{"location":"concept_reference/number_of_units/#","page":"-","title":"-","text":"The default value for this parameter is 1.","category":"page"},{"location":"concept_reference/_example/#","page":"-","title":"-","text":"AN EXAMPLE DESCRIPTION FOR HOW THE AUTOGENERATION OF CONCEPT REFERENCE BASED ON SPINEOPT TEMPLATE WORKS","category":"page"},{"location":"concept_reference/_example/#","page":"-","title":"-","text":"References to other sections, e.g. node are handled like this. Don't use the grave accents around the reference name, as it breaks the reference! Grave accents in Documenter.jl refer to docstrings in the code instead of sections in the documentation.","category":"page"},{"location":"concept_reference/start_up_cost/#","page":"-","title":"-","text":"By defining the start_up_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit starts up over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/report__output/#","page":"-","title":"-","text":"The report__output relationship tells which output variables to include in which report when writing SpineOpt output. Note that the reports also need to be connected to a model using the model__report relationship. Without appropriately defined model__report and report__output and relationships, SpineOpt doesn't write any output, so be sure to include at least one report connected to all the output variables of interest in the model!","category":"page"},{"location":"concept_reference/output_db_url/#","page":"-","title":"-","text":"The output_db_url parameter is the url of the databse to write the results of the model run. It overrides the value of the second argument passed to run_spineopt.","category":"page"},{"location":"concept_reference/connection_reactance_base/#","page":"-","title":"-","text":"As the connection_reactance is often given on a per unit basis, often different than the units used elsewhere, the connection_reactance_base parameter serves as a conversion factor, scaling the connection_reactance with its p.u..","category":"page"},{"location":"getting_started/running_an_optimization/#Running-an-Optimization-1","page":"Running an Optimization","title":"Running an Optimization","text":"","category":"section"},{"location":"getting_started/running_an_optimization/#","page":"Running an Optimization","title":"Running an Optimization","text":"TODO: Explain how to run optimizations using SpineOpt through Spine Toolbox. This section would benefit greatly if there was some form of an example system bundled in with SpineOpt, maybe even a pre-made Spine Toolbox project that would allow users to simply load it into Toolbox and press execute. ","category":"page"},{"location":"getting_started/running_an_optimization/#Quick-start-guide-1","page":"Running an Optimization","title":"Quick start guide","text":"","category":"section"},{"location":"getting_started/running_an_optimization/#","page":"Running an Optimization","title":"Running an Optimization","text":"Once SpineOpt is installed, to use it in your programs you just need to say:","category":"page"},{"location":"getting_started/running_an_optimization/#","page":"Running an Optimization","title":"Running an Optimization","text":"julia> using SpineOpt","category":"page"},{"location":"getting_started/running_an_optimization/#","page":"Running an Optimization","title":"Running an Optimization","text":"To run SpineOpt for a SpineOpt database, say:","category":"page"},{"location":"getting_started/running_an_optimization/#","page":"Running an Optimization","title":"Running an Optimization","text":"julia> run_spineopt(\"...url of a SpineOpt database...\")","category":"page"},{"location":"getting_started/running_an_optimization/#","page":"Running an Optimization","title":"Running an Optimization","text":"In what follows, we demonstrate how to setup a database for a simple example through Spine Toolbox.","category":"page"},{"location":"concept_reference/units_on__stochastic_structure/#","page":"-","title":"-","text":"The units_on__stochastic_structure relationship defines the stochastic_structure used by the units_on variable. Essentially, this relationship permits defining a different stochastic_structure for the online decisions regarding the units_on variable, than what is used for the production unit_flow variables. A common use-case is e.g. using only one units_on variable across multiple stochastic_scenarios for the unit_flow variables. Note that only one units_on__stochastic_structure relationship can be defined per unit per model, as interpreted by the units_on__stochastic_structure and model__stochastic_structure relationships.","category":"page"},{"location":"concept_reference/units_on__stochastic_structure/#","page":"-","title":"-","text":"The units_on__stochastic_structure relationship uses the model__default_stochastic_structure relationship if not specified.","category":"page"},{"location":"concept_reference/node__stochastic_structure/#","page":"-","title":"-","text":"The node__stochastic_structure relationship defines which stochastic_structure the node uses. Essentially, it sets the stochastic_structure of all the flow variables connected to the node, as well as the potential node_state variable. Note that only one stochastic_structure can be defined per node per model, as interpreted based on the node__stochastic_structure and model__stochastic_structure relationships. Investment variables use dedicated relationships, as detailed in the Investment Optimization section.","category":"page"},{"location":"concept_reference/node__stochastic_structure/#","page":"-","title":"-","text":"The node__stochastic_structure relationship uses the model__default_stochastic_structure relationship if not specified.","category":"page"},{"location":"concept_reference/tax_net_unit_flow/#","page":"-","title":"-","text":"By defining the tax_net_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with the net total of all unit_flow variables with the direction to\\_node for this specific node minus all unit_flow variables with direction from\\_node.","category":"page"},{"location":"concept_reference/report/#","page":"-","title":"-","text":"A report is essentially a group of outputs from a model, that gets written into the output database as a result of running SpineOpt. Note that unless appropriate model__report and report__output relationships are defined, SpineOpt doesn't write any output!","category":"page"},{"location":"concept_reference/model_start/#","page":"-","title":"-","text":"Together with the model_end parameter, it is used to define the temporal horizon of the model. For a single solve optimization, it marks the timestamp from which the relative offset in a temporal_block is defined by the block_start parameter. In the rolling optimization framework, it does this for the first optimization window.","category":"page"},{"location":"concept_reference/model_start/#","page":"-","title":"-","text":"A DateTime value should be chosen for this parameter. ","category":"page"},{"location":"concept_reference/constraint_sense/#","page":"-","title":"-","text":"The constraint_sense parameter determines the sense of a custom user constraint.","category":"page"},{"location":"concept_reference/constraint_sense/#","page":"-","title":"-","text":"See User constraints for details.","category":"page"},{"location":"concept_reference/connection_flow_coefficient/#","page":"-","title":"-","text":"The connection_flow_coefficient is an optional parameter that can be used to include the connection_flow variable from or to a node in a unit_constraint via the connection__from_node__unit_constraint and connection__to_node__unit_constraint relationships. Essentially, connection_flow_coefficient appears as a coefficient for the connection_flow variable from or to the node in the unit constraint.","category":"page"},{"location":"concept_reference/fix_unit_flow/#","page":"-","title":"-","text":"The fix_unit_flow parameter fixes the value of the unit_flow variable to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/fix_unit_flow/#","page":"-","title":"-","text":"Common uses for the parameter include e.g. providing initial values for the unit_flow variable, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the unit_flow variable is only fixed for time steps with defined fix_unit_flow parameter values.","category":"page"},{"location":"concept_reference/fix_unit_flow/#","page":"-","title":"-","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/fix_connection_flow/#","page":"-","title":"-","text":"The fix_connection_flow parameter fixes the value of the connection_flow variable.","category":"page"},{"location":"concept_reference/connection_contingency/#","page":"-","title":"-","text":"Specifies that the connection in question is to be included as a contingency when security constrained unit commitment is enabled. When using security constrained unit commitment by setting commodity_physics to commodity_physics_lodf, an N-1 security constraint is created for each monitored line (connection_monitored = true) for each specified contingency (connection_contingency = true). ","category":"page"},{"location":"concept_reference/connection_contingency/#","page":"-","title":"-","text":"See also powerflow","category":"page"},{"location":"concept_reference/res_proc_cost/#","page":"-","title":"-","text":"By defining the res_proc_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function whenever that unit is used over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/max_node_pressure/#","page":"-","title":"-","text":"If a node has a node_pressure variable (see also the parameter [has_pressure])(@ref) and this chapter), an upper bound on the pressure can be introduced through the max_node_pressure parameter, which triggers the generation of the maxmimum node pressure constraint.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_in_in/#","page":"-","title":"-","text":"The min_units_on_coefficient_in_in parameter is an optinal coefficient in the unit input-input ratio constraint controlled by the min_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_in_in/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_out, min_units_on_coefficient_out_in, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_in_in and fix_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/unit_investment_lifetime/#","page":"-","title":"-","text":"Duration parameter that determines the minimum duration of unit investment decisions. Once a unit has been invested-in, it must remain invested-in for unit_investment_lifetime. Note that unit_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/unit_investment_lifetime/#","page":"-","title":"-","text":"See also investment_optimization and candidate_units","category":"page"},{"location":"concept_reference/connection/#","page":"-","title":"-","text":"A connection represents a transfer of energy of one commodity over space. For example, an electricity transmission line, a gas pipe, a river branch, can be modelled using a connection.","category":"page"},{"location":"concept_reference/connection/#","page":"-","title":"-","text":"A connection always takes energy from one or more nodes, and releases that same energy to one or more (possibly the same) nodes. The former are specificed through the connection__from_node relationship, and the latter through connection__to_node. Every connection inherits the temporal and stochastic structures from the associated nodes. The model will generate connection_flow variables for every combination of connection, node, direction (from node or to node), time slice, and stochastic scenario, according to the above relationships.","category":"page"},{"location":"concept_reference/connection/#","page":"-","title":"-","text":"The operation of the connection is specified through a number of parameter values. For example, the capacity of the connection, as the maximum amount of energy that can enter or leave it, is given by connection_capacity. The conversion ratio of input to output can be specified using any of fix_ratio_out_in_connection_flow, max_ratio_out_in_connection_flow, and min_ratio_out_in_connection_flow. The delay on a connection, as the time it takes for the energy to go from one end to the other, is given by connection_flow_delay.","category":"page"},{"location":"concept_reference/fix_shut_down_unit_flow/#","page":"-","title":"-","text":"The fix_shut_down_unit_flow parameter fixes the value of the shut_down_unit_flow to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/fix_shut_down_unit_flow/#","page":"-","title":"-","text":"Common uses for the parameter include e.g. providing initial values for the shut_down_unit_flow, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the shut_down_unit_flow variable is only fixed for time steps with defined fix_shut_down_unit_flow parameter values.","category":"page"},{"location":"concept_reference/fix_shut_down_unit_flow/#","page":"-","title":"-","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/fix_shut_down_unit_flow/#","page":"-","title":"-","text":"Note that the mentioned shut_down_unit_flow variable is only included if the parameter max_startup_ramp exist for the correspond unit__to_node or unit__from_node relationship. The usage of ramps is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/connection_monitored/#","page":"-","title":"-","text":"When using ptdf-based load flow by setting commodity_physics to either commodity_physics_ptdf or commodity_physics_ptdf, a constraint is created for each connection for which connection_monitored = true. Thus, to monitor the ptdf-based flow on a particular connection connection_monitored must be set to true.","category":"page"},{"location":"concept_reference/connection_monitored/#","page":"-","title":"-","text":"See also powerflow","category":"page"},{"location":"concept_reference/min_ratio_out_out_unit_flow/#","page":"-","title":"-","text":"The definition of the min_ratio_out_out_unit_flow parameter triggers the generation of the constraint_min_ratio_out_out_unit_flow and enforces a lower bound on the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. To enforce a minimum ratio between to products of a unit u, e.g. setting the minimum share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"getting_started/creating_your_own_model/#Creating-Your-Own-Model-1","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"TODO: Explain the steps necessary top start creating your own models using SpineOpt and Spine Toolbox.","category":"page"},{"location":"getting_started/creating_your_own_model/#Creating-a-SpineOpt-database-1","page":"Creating Your Own Model","title":"Creating a SpineOpt database","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Create an empty Spine database e.g. example.db by following the documentation of Spine Toolbox. To make this database a SpineOpt database, import the SpineOpt template. This template is located in your local SpineOpt repository ../data/spineopt_template.json or can alternatively be downloaded here. To import this template in the empty Spine database, follow the instructions described here (https://spine-toolbox.readthedocs.io/en/master/datastoreform/importingandexporting_data.html).","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"This will insert a predefined set of object classes, relationship classes, and parameter definitions required by SpineOpt to run, as well as sensitive default values for those parameters.","category":"page"},{"location":"getting_started/creating_your_own_model/#Defining-the-model-structure-1","page":"Creating Your Own Model","title":"Defining the model structure","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"The first step in defining a SpineOpt is to create the objects and relationships that specify the model structure.","category":"page"},{"location":"getting_started/creating_your_own_model/#Defining-the-model-object-1","page":"Creating Your Own Model","title":"Defining the model object","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"The model object in SpineOpt is an abstraction that represents the model itself. Every SpineOpt database needs to have at least one model object.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"One way to add a model object to example.db using the Stacked view in SpineToolbox is to right-click the object_class model and select \"Add objects\" from the drop-down menu. By adding the object name quick_start, we have now created a new model object. For reference, these steps are described in more detail here.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"The model object holds general information about the optimization. The whole range of functionalities is later explained in Advanced Concepts chapter, but for this example we will only add the optimization horizon. For this, you need to enter start and end date of the optimization. To do so, select the object quick_start and go to the Object parameter value tab. Double-click on the empty row under parameter_name and select model_start. A None should appear in value column. To asign a start date value, right-click on None and open the editor. The parameter type of model_start is of type Datetime. Set the value to e.g. 2021-01-01T00:00:00. Proceed accordingly for the model_end. Further reading on adding parameter values can be found here.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"TODO: add some illustrative pictures","category":"page"},{"location":"getting_started/creating_your_own_model/#Defining-the-spatial-structure-1","page":"Creating Your Own Model","title":"Defining the spatial structure","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To specify the spatial structure for SpineOpt, you need to define commodity, node, unit, and connection objects, together with the relationships that define their interactions.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Commodities are any kind of tradable good. These goods can for instance be electricity, heat, gas, and water.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Nodes provide the locational information of such commodities. They can be understood as spatial aggregators. In combination with units and connections, they form the energy network.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Units in SpineOpt represent any kind of conversion process. As one example, a unit can represent a power plant the converts the flow of a commodity fuel into an electricity and/or heat flow.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Connections on the other hand describe the transport of goods from one location to another. Electricity lines and gas pipelines are examples of such connections.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Let's add some units and nodes to our database to start building our model. We proceed by adding the objects gas_import, power_plant of type unit and gas_node and electricity_node of type node, following the same methodology as before for our object quick_start of type model.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To specify how these units and nodes may interact with each other, let's define a unit__from_node relationship between power_plant and gas_node, and unit__to_node relationships between gas_import and gas_node, and power_plant and electricity_node.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Using the Stacked view again, we right click the respective relationship classes and select Add relationships. The corresponding objects can now be related. In practical terms, the above means that there are energy flows going from gas_import into gas_node, as well as from gas_node into power_plant, and from power_plant into electricity_node.","category":"page"},{"location":"getting_started/creating_your_own_model/#Defining-the-temporal-structure-1","page":"Creating Your Own Model","title":"Defining the temporal structure","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To specify the temporal structure for SpineOpt, you need to define temporal_block objects. Think of a temporal_block as a distinctive way of 'slicing' time across the model horizon.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To link the temporal structure to the spatial structure, you need to specify node__temporal_block relationships, establishing which temporal__block applies to each node.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To keep things simple at this point, let's just define one temporal_block for our model and apply it to all nodes. We add the object hourly_temporal_block of type temporal_block following the same procedure as before and establish node__temporal_block relationships between  gas_node and hourly_temporal_block, and electricity_node and hourly_temporal_block. In practical terms, the above means that there energy flows over gas_node and electricity_node for each 'time-slice' comprised in hourly_temporal_block.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To ensure that a temporal_block belongs to a certain model, we must furthermore establish a relationship  of type model__temporal_block between hourly_temporal_block and quick_start.","category":"page"},{"location":"getting_started/creating_your_own_model/#Defining-the-stochastic-structure-1","page":"Creating Your Own Model","title":"Defining the stochastic structure","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To specify the stochastic structure for SpineOpt, you need to define stochastic_scenario and stochastic_structure objects, together with stochastic_structure__stochastic_scenario relationships (and optionally, parent_stochastic_scenario__child_stochastic_scenario relationships).","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To link the stochastic structure to the spatial structure, you need to define node__stochastic_structure relationships, establishing which stochastic_structure applies to each node.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To keep things simple at this point, let's just define one stochastic_structure for our model with one stochastic_scenario , and apply it to all nodes: We add a stochastic_structure object called deterministic and define the object base_case of type stochastic_scenario.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"In SpineOpt, every node needs to be connected to exactly one object of type stochastic_structure. We establish relationships between all nodes to the new object deterministic. To bring the stochastic_structure and the stochastic_scenario together (defining our scenario tree), we link deterministic and base_case through a relationship of type  stochastic_structure__stochastic_scenario.","category":"page"},{"location":"getting_started/creating_your_own_model/#Specifying-the-model-behavior-1","page":"Creating Your Own Model","title":"Specifying the model behavior","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"The second step in defining a SpineOpt is to specify the object and parameter values that dictate the model behavior.","category":"page"},{"location":"getting_started/creating_your_own_model/#","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"TO BE CONTINUED...","category":"page"},{"location":"concept_reference/unit__investment_temporal_block/#","page":"-","title":"-","text":"unit__investment_temporal_block is a two-dimensional relationship between a unit and a temporal_block. This relationship defines the temporal resolution and scope of a unit's investment decision. Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__defaultinvestmenttemporal_block is specified and no unit__investment_temporal_block relationship is specified, the model__defaultinvestmenttemporal_block relationship will be used. Conversely if unit__investment_temporal_block is specified along with model__temporal_block, this will override model__defaultinvestmenttemporal_block for the specified unit.","category":"page"},{"location":"concept_reference/unit__investment_temporal_block/#","page":"-","title":"-","text":"See also investment_optimization","category":"page"},{"location":"concept_reference/max_ratio_in_out_unit_flow/#","page":"-","title":"-","text":"The definition of the max_ratio_in_out_unit_flow parameter triggers the generation of the constraint_max_ratio_in_out_unit_flow and set an upper bound on the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the from_node, i.e. the incoming flows to the unit, and the second node (or group of nodes), represents the to_node i.e. the outgoing flow from the unit. To enforce e.g. a maximum ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing gas flow to the node group el_heat (consisting of the two nodes el and heat), the max_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/connection_investment_lifetime/#","page":"-","title":"-","text":"connection_investment_lifetime is the minimum amount of time that a connection has to stay in operation once it's invested-in. Only after that time, the connection can be decomissioned. Note that connection_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/unit/#","page":"-","title":"-","text":"A unit represents an energy conversion process, where energy of one commodity can be converted into energy of another commodity. For example, a gas turbine, a power plant, or even a load, can be modelled using a unit.","category":"page"},{"location":"concept_reference/unit/#","page":"-","title":"-","text":"A unit always takes energy from one or more nodes, and releases energy to one or more (possibly the same) nodes. The former are specificed through the unit__from_node relationship, and the latter through unit__to_node. Every unit has a temporal and stochastic structures given by the units_on__temporal_block and [units_on__stochastic_structure] relationships. The model will generate unit_flow variables for every combination of unit, node, direction (from node or to node), time slice, and stochastic scenario, according to the above relationships.","category":"page"},{"location":"concept_reference/unit/#","page":"-","title":"-","text":"The operation of the unit is specified through a number of parameter values. For example, the capacity of the unit, as the maximum amount of energy that can enter or leave it, is given by unit_capacity. The conversion ratio of input to output can be specified using any of fix_ratio_out_in_unit_flow, max_ratio_out_in_unit_flow, and min_ratio_out_in_unit_flow. The variable operating cost is given by vom_cost.","category":"page"},{"location":"concept_reference/fix_ratio_in_in_unit_flow/#","page":"-","title":"-","text":"The definition of the fix_ratio_in_in_unit_flow parameter triggers the generation of the constraint_fix_ratio_in_in_unit_flow and fixes the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply. To enforce e.g. for a unit u a fixed share of 0.8 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the fix_ratio_in_in_unit_flow parameter would be set to 0.8 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/unit_constraint/#","page":"-","title":"-","text":"The unit_constraint is a generic data-driven custom constraint, which allows for defining constraints involving multiple units, nodes, or connections. The constraint_sense parameter changes the sense of the unit_constraint, while the right_hand_side parameter allows for defining the constant terms of the constraint.","category":"page"},{"location":"concept_reference/unit_constraint/#","page":"-","title":"-","text":"Coefficients for the different variables appearing in the unit_constraint are defined using relationships, like e.g. unit__from_node__unit_constraint and connection__to_node__unit_constraint for unit_flow and connection_flow variables, or unit__unit_constraint and node__unit_constraint for units_on and node_state variables.","category":"page"},{"location":"concept_reference/max_ratio_out_out_unit_flow/#","page":"-","title":"-","text":"The definition of the max_ratio_out_out_unit_flow parameter triggers the generation of the constraint_max_ratio_out_out_unit_flow and sets an upper bound on the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. To enforce a maximum ratio between to products of a unit u, e.g. setting the maximum share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"concept_reference/min_node_pressure/#","page":"-","title":"-","text":"If a node has a node_pressure variable (see also the parameter [has_pressure])(@ref) and this chapter), a lower bound on the pressure can be introduced through the min_node_pressure parameter, which triggers the generation of the minimum node pressure constraint.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Stochastic-Framework-1","page":"Stochastic Framework","title":"Stochastic Framework","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Scenario-based stochastics in unit commitment and economic dispatch models typically only consider branching scenario trees. However, sometimes the available stochastic data doesn't span over the entire desired modelling horizon, or all the modelled phenomena. Especially with increasing interest in energy system integration and sector coupling, stochastic data of consistent quality and/or length might be hard to come by.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"While these data issues can be circumvented by either cloning stochastic data across multiple scenario branches or generating dummy forecasts, they can result in inflated problem sizes. Furthermore, Ensuring realistic correlations between generated forecasts is extremely difficult, especially across multiple energy sectors.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"The stochastic framework in SpineOpt.jl aims to support stochastic directed acyclic graphs (DAGs) instead of only branching trees, allowing for scenarios to converge later on in the modelled horizon. In addition, the framework allows for slightly different stochastic scenario graphs for different variables, making it easier to define e.g. variables common between all stochastic scenarios.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Key-concepts-1","page":"Stochastic Framework","title":"Key concepts","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Here, we briefly describe the key concepts required to understand the stochastic framework:","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"stochastic_scenario is essentially just a label for an alternative period of time, describing one possiblity of what may come to pass. Even in deterministic modelling with SpineOpt.jl, a single stochastic_scenario is required for labelling the deterministic timeline.\nStochastic DAG is the directed acyclic graph describing the parent_stochastic_scenario__child_stochastic_scenario relationships between the stochastic scenarios. The key difference between a stochastic DAG and a traditional stochastic tree is that the scenarios are allowed to have multiple parents, making it possible to converge scenarios into each other in addition to branching.\nStochastic path is a unique sequence of stochastic scenarios for traversing the stochastic DAG. Every (finite) stochastic DAG has a limited number of full stochastic paths that traverse it from roots (scenarios without parents) to leaves (scenarios without children). Here, we use the term stochastic path to refer to any subset of scenarios within a full stochastic path.\nstochastic_structure is essentially a \"realization\" of the stochastic DAG, with additional information like the stochastic_scenario_end and weight_relative_to_parents Parameters. These become relevant when we start discussing interactions between different stochastic structures.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"<img src=\"../../figs/dag_fullpath_path.svg\" width=\"40%\"/>","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"The above figure presents an example stochastic DAG with the individual stochastic scenarios labelled from s0-s8. An example full stochastic path [s0, s1, s5, s8] is highlighted in red, while an example stochastic path [s2, s4, s7] is highlighted in blue.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#General-idea-in-brief-1","page":"Stochastic Framework","title":"General idea in brief","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"The major issue with stochastic DAGs compared to stochastic trees, is that indexing constraints that include variables from multiple time steps (henceforth referred to as \"dynamic constraints\") needs rethinking. With stochastic trees, constraints can always be unambiguously indexed using (stochastic_scenario, last_time_step), since all stochastic scenarios only have a single parent. However, this is no longer the case for stochastic DAGs, as illustrated in the figures below:","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"<img src=\"../../figs/branching.svg\" width=\"40%\"/>\n<img src=\"../../figs/converging.svg\" width=\"40%\"/>","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"The example on the left illustrates the \"traditional\" indexing in branching stochastic trees, where backtracking through the tree always leads to unambiguous (stochastic_scenario, time_step) indices. The example on the right shows a similar situation in a stochastic DAG, where backtracking through the DAG leads to four different (stochastic_scenario, time_step) indices, and thus requires four constraints to be generated and indexed.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Stochastic-path-indexing-1","page":"Stochastic Framework","title":"Stochastic path indexing","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"As discussed in the previous section, dynamic constraints in stochastic DAGs cannot be unambiguously indexed using a single (stochastic_scenario, time_step). However, they can be unambiguously indexed using (stochastic_path, time_step), where the stochastic path is the unique sequence of stochastic scenarios traversing the DAG. Since there are only a limited number of ways to traverse the DAG, represented by the full stochastic paths, we can identify the number of unique paths necessary for constraint generation as follows:","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Identify all unique full stochastic paths, meaning all the possible ways of traversing the DAG from roots to leaves.\nFind all the stochastic scenarios that are active on all the time steps included in the constraint.\nFind all the unique stochastic paths by intersecting the set of active stochastic scenarios with the full stochastic paths.\nGenerate constraints over each unique stochastic path found in step 3.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-dynamic-constraint-generation-1","page":"Stochastic Framework","title":"Example dynamic constraint generation","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"<img src=\"../../figs/constraint_paths.svg\" width=\"40%\"/>","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"The above figure shows examples of two different dynamic constraints generated in a stochastic DAG: the red constraint including variables from timesteps t4-t5 and the blue constraint including variables from timesteps t1, t3. The full stochastic paths for traversing the above DAG are as follows:","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"[s0, s1, s5, s8]\n[s0, s2, s3, s5, s8]\n[s0, s2, s4, s6, s8]\n[s0, s2, s4, s7, s8]","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"For the red constraint, the stochastic scenarios s5-s8 are active on the time steps t4-t5. All the above full stochastic paths include at least two of the active stochastic scenarios, but full paths 1 and 2 both produce an identical path [s5, s8], so the set of unique stochastic paths for the red constraint becomes:","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"[s5, s8]\n[s6, s8]\n[s7, s8]","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"There are no paths [s5, s6], [s5, s7], [s6, s7] since following the DAG one cannot start from s5 and end up in s6, even though these stochastic scenarios are active.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"The blue constraint illustrates a case where the time step range is non-continuous. The active stochastic scenarios on t1, t3 are s1, s2, s4, s5, so again by comparing these to the full stochastic paths we get:","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"[s1, s5]\n[s2, s5]\n[s2, s4]","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"In this case, the full stochastic paths 3 and 4 both produce the path [s2, s4], so only three unique constraints need to be generated. Again, the path [s1, s4] is invalid, since the DAG cannot be traversed from s1 to s4.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Interaction-between-different-stochastic-structures-1","page":"Stochastic Framework","title":"Interaction between different stochastic structures","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Stochastic path indexing in constraints also allows for \"distorting\" the stochastic DAG in different parts of the model. As long as the stochastic DAG itself isn't changed, meaning the parent_stochastic_scenario__child_stochastic_scenario relationships and the resulting full stochastic paths, we can actually define different stochastic structures and still be able to handle constraint generation between them. This is due to the fact that when determining the stochastic paths, it makes no difference whether we're looking at the same stochastic_structure at different time steps, or at two stochastic structures, one of which has been delayed, on the same time step. This is illustrated by the figure below:","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"<img src=\"../../figs/delayed_stochastic_paths.svg\" width=\"50%\"/>","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"The above represents constraint generation over two stochastic structures, where the lower stochastic_structure has been delayed in respect to the one above. Nevertheless, the procedure for finding the stochastic paths for the constraints remains identical to the previous example:","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Identify all unique full stochastic paths, meaning all the possible ways of traversing the DAG. As long as the DAG remains the same between all the involved stochastic structures, the pathing remains the same.\nFind all the stochastic scenarios that are active on all the stochastic structures and time steps included in the constraint.\nFind all the unique stochastic paths by intersecting the set of active scenarios with the full stochastic paths.\nGenerate constraints over each unique stochastic path found in step 3.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Stochastics-in-the-model-data-structure-1","page":"Stochastic Framework","title":"Stochastics in the model data structure","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"While the Key concepts and General idea in brief sections go over the stochastic framework in SpineOpt.jl in a more general sense, here we'll go over how to set up stochastics using SpineOpt.jl data structure. Simple step-by-step examples are also provided in the Example of deterministic stochastics, Example of branching stochastics, and Example of converging stochastics sections further below. We won't go into too much detail about the related Object Classes, Relationship Classes, or Parameters, since those can be found in their respective sections. Introductions to these concepts can also be found in the Structural object classes and Structural relationship classes sections, if necessary.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Setting-up-the-stochastic-framework-1","page":"Stochastic Framework","title":"Setting up the stochastic framework","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"As with all things in SpineOpt.jl, you'll want to start with adding the desired number of objects to the relevant Object Classes, as one cannot define relationships over objects that don't exist. For the stochastic framework, this means creating at least one stochastic_scenario and stochastic_structure object each. This needs to be done even if your model is fully deterministic, as even the deterministic structure needs to be labelled for SpineOpt.jl to recognize that it exists.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Next, if your model has multiple stochastic_scenario objects, you'll want to define how they are related using the parent_stochastic_scenario__child_stochastic_scenario relationship. This relationship essentially defines the stochastic DAG, as well as all the possible stochastic paths, explained in the Key concepts section. Unless the parent_stochastic_scenario__child_stochastic_scenario relationship is defined, there won't be a stochastic DAG, and all stochastic_scenario objects will be assumed to be completely independent of each other.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Now that you've set up the desired stochastic_scenario and stochastic_structure objects, as well as defined the stochastic DAG using the parent_stochastic_scenario__child_stochastic_scenario relationship, it's time to define the properties of the stochastic_structure objects using the stochastic_structure__stochastic_scenario relationship, and the stochastic_scenario_end and weight_relative_to_parents Parameters therein. You'll always have to define at least one stochastic_structure__stochastic_scenario relationship, as the stochastic_structure object is what connects the Systemic object classes to the stochastic framework. stochastic_structure__stochastic_scenario relationship holds two key Parameters:","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"weight_relative_to_parents defines the coefficient the corresponding stochastic_scenario has in the Objective function, and needs to be defined for each stochastic_scenario included in the stochastic_structure. The weight is relative to the parents of the [stochastic_scenario], and is calculated as presented below.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"# For root `stochastic_scenarios` (meaning no parents)\n\nweight(scenario) = weight_relative_to_parents(scenario)\n\n# If not a root `stochastic_scenario`\n\nweight(scenario) = sum([weight(parent) * weight_relative_to_parents(scenario)] for parent in parents)","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"stochastic_scenario_end is a Duration type parameter that tells when the stochastic_scenario ends in relation to the start of the current optimization. When defined, the stochastic_scenario ends at the defined point in time, and spawns its children according to parent_stochastic_scenario__child_stochastic_scenario, if any. Note that this means the children are included in the stochastic_structure, even without an explicit relationship! If stochastic_scenario_end isn't defined, the stochastic_scenario is assumed to go on indefinetely.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Finally, with all the pieces in place, we'll need to connect the defined stochastic_structure objects to the desired objects in the Systemic object classes using the Structural relationship classes like  node__stochastic_structure etc. Here, we essentially tell which parts of the modelled system use which stochastic_structure. Since creating each of these relationships individually can be a bit of a pain, there are a few Meta relationship classes like the model__default_stochastic_structure, that can be used to set model-wide defaults that are used if specific relationships are missing.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-deterministic-stochastics-1","page":"Stochastic Framework","title":"Example of deterministic stochastics","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Here, we'll demonstrate step-by-step how to create the simplest possible stochastic frame: the fully deterministic one.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Create a stochastic_scenario called e.g. realization and a stochastic_structure called e.g. deterministic.\nWe can skip the parent_stochastic_scenario__child_stochastic_scenario relationship, since there isn't a stochastic DAG in this example, and the default behaviour of each [stochastic_scenario] being independent works for our purposes (only one stochastic_scenario anyhow).\nCreate the stochastic_structure__stochastic_scenario relationship for (deterministic, realization), and set its weight_relative_to_parents parameter to 1. We don't need to define the stochastic_scenario_end parameter, as we want the realization to go on indefinitely.\nRelate the deterministic stochastic_structure to all the desired system objects using the appropriate Structural relationship classes, or use the model-level default Meta relationship classes.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-branching-stochastics-1","page":"Stochastic Framework","title":"Example of branching stochastics","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Here, we'll demonstrate step-by-step how to create a simple branching stochastic tree, where one scenario branches into three at a specific point in time.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Create four stochastic_scenario objects called e.g. realization, forecast1, forecast2, and forecast3, and a stochastic_structure called e.g. branching.\nDefine the stochastic DAG by creating the parent_stochastic_scenario__child_stochastic_scenario relationships for (realization, forecast1), (realization, forecast2), and (realization, forecast3).\nCreate the stochastic_structure__stochastic_scenario relationship for (branching, realization), (branching, forecast1), (branching, forecast2), and (branching, forecast3).\nSet the weight_relative_to_parents parameter to 1 and the stochastic_scenario_end parameter e.g. to 6h for the stochastic_structure__stochastic_scenario relationship (branching, realization). Now, the realization stochastic_scenario will end after 6 hours of time steps, and its children (forecast1, forecast2, and forecast3) will become active.\nSet the weight_relative_to_parents Parameters for the (branching, forecast1), (branching, forecast2), and (branching, forecast3) stochastic_structure__stochastic_scenario relationships to whatever you desire, e.g. 0.33 for equal probabilities across all forecasts.\nRelate the brancing stochastic_structure to all the desired system objects using the appropriate Structural relationship classes, or use the model-level default Meta relationship classes.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-converging-stochastics-1","page":"Stochastic Framework","title":"Example of converging stochastics","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Here, we'll demonstrate step-by-step how to create a simple stochastic DAG, where both branching and converging occurs. This example relies on the previous Example of branching stochastics, but adds another stochastic_scenario at the end, which is a child of the forecast1, forecast2, and forecast3 scenarios.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Follow the steps 1-5 in the previous Example of branching stochastics, except call the stochastic_structure something different, e.g. converging.\nCreate a new stochastic_scenario called e.g. converged_forecast.\nAlter the stochastic DAG by creating the parent_stochastic_scenario__child_stochastic_scenario relationships for (forecast1, converged_forecast), (forecast2, converged_forecast), and (forecast3, converged_forecast). Now all three forecasts will converge into a single converged_forecast.\nAdd the stochastic_structure__stochastic_scenario relationship for (converging, converged_forecast), and set its weight_relative_to_parents parameter to 1. Now, all the probability mass in forecast1, forecast2, and forecast3 will be summed up back to the converged_forecast.\nSet the stochastic_scenario_end Parameters of the stochastic_structure__stochastic_scenario relationships (converging, forecast1), (converging, forecast2), and (converging, forecast3) to e.g. 12h, so that all three scenarios end at the same time and the converged_forecast becomes active.\nRelate the converging stochastic_structure to all the desired system objects using the appropriate Structural relationship classes, or use the model-level default Meta relationship classes.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Working-with-stochastic-and-updating-data-1","page":"Stochastic Framework","title":"Working with stochastic and updating data","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Now that we've discussed how to set up stochastics for SpineOpt, let's focus on stochastic data. The most complex form of input data SpineOpt can currently handle is both stochastic and updating, meaning that the values the parameter takes can depend on both the stochastic_scenario, and the analysis time (first time step) of each solve. However, just stochastic or just updating cases are supported as well, using the same input data format.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"In SpineOpt, stochastic data uses the Map data type from SpineInterface.jl. Essentially, Maps are general indexed data containers, which SpineOpt tries to interpret as stochastic data. Every time SpineOpt calls a parameter, it passes the stochastic_scenario and analysis time as keyword arguments to the parameter, but depending on the parameter type, it doesn't necessarily do anything with that information. For Map type parameters, those keyword arguments are used for navigating the indices of the Map to try and find the corresponding value. If the Map doesn't include the stochastic_scenario index it's looking for, it assumes there's no stochastic information in the Map and carries on to search for analysis time indices. This logic is useful for defining both stochastic and updating data, as well as either case by itself, as shown in the following examples.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-stochastic-data-1","page":"Stochastic Framework","title":"Example of stochastic data","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"By stochastic data, we mean parameter values that depend only on the stochastic_scenario. In such a case, the input data must be formatted as a Map with the following structure","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"stochastic_scenario value\nscenario1 value1\nscenario2 value2","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"where stochastic_scenario indices are simply Strings corresponding to the names of the stochastic_scenario objects. The values can be whatever data types SpineInterface.jl supports, like Constants, DateTimes, Durations, or TimeSeries. In the above example, the parameter will take value1 in scenario1, and value2 in scenario2. Note that since there's no analysis time index in this example, the values are used regardless of the analysis time.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-updating-data-1","page":"Stochastic Framework","title":"Example of updating data","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"By updating data, we mean parameter values that depend only on the analysis time. In such a case, the input data must be formatted as a Map with the following structure","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"analysis time value\n2000-01-01T00:00:00 value1\n2000-01-01T12:00:00 value2","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"where the analysis time indices are DateTime values. The values can be whatever data types SpineInterface.jl supports, like Constants, DateTimes, Durations, or TimeSeries. In the above example, the parameter will take value1 if the first time step of the current simulation is between 2000-01-01T00:00:00 and 2000-01-01T12:00:00, and value2 if the first time step of the simulation is after 2000-01-01T12:00:00. Note that since there's no stochastic_scenario index in this example, the values are used regardless of the stochastic_scenario.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-stochastic-updating-data-1","page":"Stochastic Framework","title":"Example of stochastic updating data","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"By stochastic updating data, we mean parameter values that depend on both the stochastic_scenario and the analysis time. In such a case, the input data must be formatted as a Map with the following structure","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"stochastic_scenario analysis time value\nscenario1 2000-01-01T00:00:00 value1\nscenario1 2000-01-01T12:00:00 value2\nscenario2 2000-01-01T00:00:00 value3\nscenario2 2000-01-01T12:00:00 value4","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"where the stochastic_scenario indices are simply Strings corresponding to the names of the stochastic_scenario objects, and the analysis time indices are DateTime values. The values can be whatever data types SpineInterface.jl supports, like Constants, DateTimes, Durations, or TimeSeries. In the above example, the parameter will take value1 if the first time step of the current simulation is between 2000-01-01T00:00:00 and 2000-01-01T12:00:00 and the parameter is called in scenario1, and value3 in scenario2. If the first time step of the current simulation is after 2000-01-01T12:00:00, the parameter will take value2 in scenario1, and value4 in scenario2.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Constraint-generation-with-stochastic-path-indexing-1","page":"Stochastic Framework","title":"Constraint generation with stochastic path indexing","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Every time a constraint might refer to variables either on different time steps or on different stochastic scenarios (meaning different nodes or units), the constraint needs to use stochastic path indexing in order to be correctly generated for arbitrary stochastic DAGs. In practise, this means following the procedure outlined below:","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Identify all unique full stochastic paths, meaning all the possible ways of traversing the DAG. This is done along with generating the stochastic structure, so no real impact on constraint generation.\nFind all the stochastic scenarios that are active on all the stochastic structures and time slices included in the constraint.\nFind all the unique stochastic paths by intersecting the set of active scenarios with the full stochastic paths.\nGenerate constraints over each unique stochastic path found in step 3.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#","page":"Stochastic Framework","title":"Stochastic Framework","text":"Steps 2 and 3 are the crucial ones, and are currently handled by separate constraint_<constraint_name>_indices functions. Essentially, these functions go through all the variables on all the time steps included in the constraint, collect the set of active stochastic_scenarios on each time step, and then determine the unique active stochastic paths on each time step. The functions pre-form the index set over which the constraint is then generated in the add_constraint_<constraint_name> functions.","category":"page"},{"location":"advanced_concepts/unit_commitment/#Unit-commitment-1","page":"Unit Commitment","title":"Unit commitment","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"To incorporate technical detail about (clustered) unit-commitment statuses of units, the online, started and shutdown status of units can be tracked and constrained in SpineOpt. In the following, relevant relationships and parameters are introduced and the general working principle is described.","category":"page"},{"location":"advanced_concepts/unit_commitment/#Key-concepts-for-unit-commitment-1","page":"Unit Commitment","title":"Key concepts for unit commitment","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"Here, we briefly describe the key concepts involved in the representation of (clustered) unit commitment models:","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"units_on is an optimization variable that holds information about the on- or offline status of a unit. Unit commitment restrictions will govern how this variable can change through time.","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"units_on__temporal_block is a relationship linking the units_on variable of this unit to a specific temporal_block object. The temporal block holds information on the temporal scope and resolution for which the variable should be optimized.","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"online_variable_type is a method parameter and can take the values \"unit_online_variable_type_binary\", \"unit_online_variable_type_integer\", \"unit_online_variable_type_linear\". If the binary value is chosen, the units status is modelled as a binary (classic UC). For clustered unit commitment units, the integer type is applicable. Note that if the parameter is not defined, the default will be linear. If the units status is not crucial, this can reduce the computational burden.","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"number_of_units defines how many units of a certain unit type are available. Typically this parameter takes a binary (UC) or integer (clustered UC) value. To avoid confusion the following distinction will be made in this document:  unit will be used to identify a Spine unit object, which can have multiple members. Together with the unit_availability_factor, this will determine the maximum number of members that can be online at any given time. (Thus restricting the units_on variable). The default value for this parameter is 1. It is possible to allow the model to increase the number_of_units itself, through Investment Optimization","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"unit_availability_factor: (number value). Is the fraction of the time that this unit is considered to be available. Typically, units are not available 100% of the time, due to scheduled maintenance, unforeseen outages, or other things. This can be incorporated in the model by setting the unit_availability_factor to a fractional value. For each timestep in the model, an upper bound is then imposed on the units_on variable, equal to number_of_units * unit_availability_factor. This parameter can not be used when the online_variable_type is binary. It should also be noted that when the online_variable_type is of integer type, the aforementioned product must be integer as well, since it will determine the value of the units_available parameter which is restricted to integer values. The default value for this parameter is 1.","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"min_up_time: (duration value). Sets the minimum time that a unit has to stay online after a startup. Inclusion of this parameter will trigger the creation of the constraint on Minimum up time (basic version)","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"min_down_time: (duration value). Sets the minimum time that a unit has to stay offline after a shutdown. Inclusion of this parameter will trigger the creation of the constraint on Minimum down time (basic version)","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"minimum_operating_point: (number value) limits the minimum value of the unit_flow variable for a unit which is currently online. Inclusion of this parameter will trigger the creation of the Constraint on minimum operating point","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"start_up_cost: \"number value\". Cost associated with starting up a unit.\nshut_down_cost: \"number value\". Cost associated with shutting down a unit.","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"I feel like units_on__temporal_block should be added here aswell. Also we need to add the unit status variables to the mathematical_formulation, but should probably also briefly explain them here.","category":"page"},{"location":"advanced_concepts/unit_commitment/#","page":"Unit Commitment","title":"Unit Commitment","text":"Also can we change the formatting a bit? When I build the documentation, the indentations are a bit off","category":"page"},{"location":"concept_reference/commodity_physics/#","page":"-","title":"-","text":"This parameter determines the specific formulation used to carry out dc load flow within a model. To enable power transfer distribution factor (ptdf) based load flow for a network of nodes and connections, all nodes must be related to a commodity with commodity_physics set to  commodity_physics_ptdf. To enable security constraint unit comment based on ptdfs and line outage distribution factors (lodf) all nodes must be related to a commodity with commodity_physics set to commodity_physics_lodf. ","category":"page"},{"location":"concept_reference/commodity_physics/#","page":"-","title":"-","text":"See also powerflow","category":"page"},{"location":"concept_reference/big_m/#","page":"-","title":"-","text":"The big_m parameter is a property of the model object. The bigM method is commonly used for the purpose of recasting non-linear constraints into a mixed-integer reformulation. In SpineOpt, the bigM formulation is used to describe the sign of gas flow through a connection (if a pressure driven gas transfer model is used). The big_m parameter in combination with the binary variable binary_gas_connection_flow is used in the constraints on the gas flow capacity and the fixed node pressure points and ensures that the average flow through a pipeline is only in one direction and is constraint by the fixed pressure points from the outer approximation of the Weymouth equation. See Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling for reference.","category":"page"},{"location":"concept_reference/is_active/#","page":"-","title":"-","text":"is_acive is a universal, utility parameter that is defined for every object class. When used in conjunction with the activity_control feature, the is_active parameter allows one to control whether or not a specific object is active within a model or not. ","category":"page"},{"location":"concept_reference/vom_cost/#","page":"-","title":"-","text":"By defining the vom_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for the variable operation and maintenance costs associated with that unit over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/candidate_storages/#","page":"-","title":"-","text":"Within an investments problem candidate_storages determines the upper bound on the storages investment decision variable in constraint storages_invested_available. In constraint node_state_cap the maximum node state will be the product of the storages investment variable and node_state_cap. Thus, the interpretation of candidate_storages depends on @refstorage_investment_variable_type which determines the investment decision variable type. If storage_investment_variable_type is integer or binary, then candidate_storages represents the maximum number of discrete storages of size node_state_cap that may be invested in at the corresponding node. If storage_investment_variable_type is continuous, candidate_storages is more analagous to a maximum storage capacity with node_state_cap being analagous to a scaling parameter.","category":"page"},{"location":"concept_reference/candidate_storages/#","page":"-","title":"-","text":"Note that candidate_storages is the main investment switch and setting a value other than none/nothing triggers the creation of the investment variable for storages at the corresponding node. Note that a value of zero will still trigger the variable creation but its value will be fixed to zero. This can be useful if as inspection of the related dual variables will yield the value of this resource.","category":"page"},{"location":"concept_reference/candidate_storages/#","page":"-","title":"-","text":"See also investment_optimization and storage_investment_variable_type","category":"page"},{"location":"concept_reference/max_units_on_coefficient_out_out/#","page":"-","title":"-","text":"The max_units_on_coefficient_out_out parameter is an optinal coefficient in the unit output-output ratio constraint controlled by the max_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/max_units_on_coefficient_out_out/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_out_in, and max_units_on_coefficient_in_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_out_out and fix_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/unit_investment_variable_type/#","page":"-","title":"-","text":"Within an investments problem unit_investment_variable_type determines the unit investment decision variable type. Since the unit_flows will be limited to the product of the investmentvariable and the corresponding [unit\\capacity](@ref) for each unit_flow and since candidate_units represents the upper bound of the investment decision variable, unit_investment_variable_type thus determines what the investment decision represents. If unit_investment_variable_type is integer or binary, then candidate_units represents the maximum number of discrete units that may be invested. If unit_investment_variable_type is continuous, candidate_units is more analagous to a capacity with unit_capacity being analagous to a scaling parameter. For example, if unit_investment_variable_type = integer, candidate_units = 4 and unit_capacity for a particular unit_flow = 400 MW, then the investment decision is how many 400 MW units to build. If unit_investment_variable_type = continuous, candidate_units = 400 and unit_capacity for a particular unit_flow = 1 MW, then the investment decision is how much capacity if this particular unit to build. Finally, if unit_investment_variable_type = integer, candidate_units = 10 and unit_capacity for a particular unit_flow = 50 MW, then the investment decision is many 50MW blocks of capacity of this particular unit to build.","category":"page"},{"location":"concept_reference/unit_investment_variable_type/#","page":"-","title":"-","text":"See also investment_optimization and candidate_units","category":"page"},{"location":"concept_reference/fix_node_state/#","page":"-","title":"-","text":"The fix_node_state parameter simply fixes the value of the node_state variable to the provided value, if one is found. Common uses for the parameter include e.g. providing initial values for node_state variables, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the node_state variables are only fixed for time steps with defined fix_node_state parameter values.","category":"page"},{"location":"concept_reference/has_voltage_angle/#","page":"-","title":"-","text":"For the use of node-based lossless DC powerflow, each node will be associated with a v{voltageangle} variable. To enable the generation of the variable in the optimization model, the boolean parameter has_voltage_angle should be set true. The voltage angle at a certain node can also be constrained through the parameters max_voltage_angle and min_voltage_angle. More details on the use of pressure driven gas transfer are described here","category":"page"},{"location":"concept_reference/max_units_on_coefficient_in_out/#","page":"-","title":"-","text":"The max_units_on_coefficient_in_out parameter is an optinal coefficient in the unit input-output ratio constraint controlled by the max_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/max_units_on_coefficient_in_out/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_out_in, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_in_out and fix_units_on_coefficient_in_out.","category":"page"},{"location":"concept_reference/the_basics/#Basics-of-the-model-structure-1","page":"Basics of the model structure","title":"Basics of the model structure","text":"","category":"section"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"In SpineOpt.jl, the model structure is generated based on the input data, allowing it to be used for a multitude of different problems. Here, we aim to provide you with a basic understanding of the SpineOpt.jl model and data structure, while the Object Classes, Relationship Classes, Parameters, and Parameter Value Lists sections provide more in-depth explanations of each concept.","category":"page"},{"location":"concept_reference/the_basics/#Introduction-to-object-classes-1","page":"Basics of the model structure","title":"Introduction to object classes","text":"","category":"section"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"Essentially, Object Classes represents different types of objects or entities that make up the model. For example, every power plant in the model is represented as an object of the object class unit, every power line as an object of the object class connection, and so forth. In order to add any new entity to a model, a new object has to be added to desired object class in the input data.","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"Each object class has a very specific purpose in SpineOpt.jl, so understanding their differences is key. The Object Classes can be roughly divided into three distinctive groups, namely Systemic object classes, Structural object classes, and Meta object classes.","category":"page"},{"location":"concept_reference/the_basics/#Systemic-object-classes-1","page":"Basics of the model structure","title":"Systemic object classes","text":"","category":"section"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"As the name implies, system Object Classes are used to describe the system to be modelled. Essentially, they define what you want to model. These include:","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"commodity represents different goods to be generated, consumed, transported, etc.\nconnection handles the transfer of commodities between nodes.\nnode ensures the balance of the commodity flows, and can be used to store commodities as well.\nunit handles the generation and consumption of commodities.","category":"page"},{"location":"concept_reference/the_basics/#Structural-object-classes-1","page":"Basics of the model structure","title":"Structural object classes","text":"","category":"section"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"Structural Object Classes are used to define the temporal and stochastic structure of the modelled problem, as well as custom unit constraints. Unlike the above system Object Classes, the structural Object Classes are more about how you want to model, instead of strictly what you want to model. These include:","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"stochastic_scenario represents a different forecast or another type of an alternative time period.\nstochastic_structure acts as a handle for a group of stochastic_scenarios with set properties.\ntemporal_block defines a period of time with the desired temporal resolution.\nunit_constraint is an optional custom constraint generated based on the input data.","category":"page"},{"location":"concept_reference/the_basics/#Meta-object-classes-1","page":"Basics of the model structure","title":"Meta object classes","text":"","category":"section"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"Meta Object Classes are used for defining things on the level of models or above, like model output and even multiple models for problem decompositions. These include:","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"model represents an individual model, grouping together all the things relevant for itself.\noutput defines which Variables are output from the model.\nreport groups together multiple output objects.","category":"page"},{"location":"concept_reference/the_basics/#Introduction-to-relationship-classes-1","page":"Basics of the model structure","title":"Introduction to relationship classes","text":"","category":"section"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"While Object Classes define all the objects or entities that make up a model, Relationship Classes define how those entities are related to each other. Thus, Relationship Classes hold no meaning on their own, and always include at least one object class.","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"Similar to Object Classes, each relationship class has a very specific purpose in SpineOpt.jl, and understanding the purpose of each relationship class is paramount. The Relationship Classes can be roughly divided into Systemic relationship classes, Structural relationship classes, and Meta relationship classes, again similar to Object Classes.","category":"page"},{"location":"concept_reference/the_basics/#Systemic-relationship-classes-1","page":"Basics of the model structure","title":"Systemic relationship classes","text":"","category":"section"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"Systemic Relationship Classes define how Systemic object classes are related to each other, thus helping define the system to be modelled. Most of these relationships deal with which units and connections interact with which nodes, and how those interactions work. This essentially defines the possible commodity flows to be modelled. Systemic Relationship Classes include:","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"connection__from_node defines which node the connection can transfer a commodity from.\nconnection__node__node holds Parameters for connections between two nodes.\nconnection__to_node defines which node the connection can transfer a commodity to.\nnode__commodity defines which node holds which commodity.\nnode__node holds parameters for direct node-node interactions, like diffusion of commodities.\nunit__commodity defines which commodity the unit handles.\nunit__from_node defines which node the unit can take an input commodity from.\nunit__node__node holds parameters for unit interactions between two nodes.\nunit__to_node defines which node the unit can output a commodity to.","category":"page"},{"location":"concept_reference/the_basics/#Structural-relationship-classes-1","page":"Basics of the model structure","title":"Structural relationship classes","text":"","category":"section"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"Structural Relationship Classes primarily relate Structural object classes to Systemic object classes, defining what structures the individual parts of the system use. These are mostly used to determine the temporal and stochastic structures to be used in different parts of the modelled system, or custom unit constraints.","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"SpineOpt.jl has a very flexible temporal and stochastic structure, explained in detail in the Temporal Framework and Stochastic Framework sections of the documentation. Unfortunately, this flexibility requires quite a few different structural Relationship Classes, the most important of which are the following basic structural Relationship Classes:","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"node__stochastic_structure defines the stochastic_structure used for the node balance.\nnode__temporal_block defines the temporal blocks used for the node balance.\nparent_stochastic_scenario__child_stochastic_scenario defines the stochastic DAG of the Stochastic Framework.\nstochastic_structure__stochastic_scenario holds parameters for stochastic scenarios in the stochastic_structure.\nunits_on__stochastic_structure defines the stochastic_structure used for the online variable of the unit.\nunits_on__temporal_block defines the temporal blocks used for the online variable of the unit.","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"Furthermore, there are also a number of advanced structural Relationship Classes, which are only necessary when using some of the optional features of SpineOpt.jl, like Investment Optimization and custom unit constraints. These include:","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"connection__from_node__unit_constraint holds Parameters for the connection_flow variable from the node in question in the custom unit_constraint.\nconnection__investment_stochastic_structure defines the stochastic_structure used for the investment Variables for the connection.\nconnection__investment_temporal_block defines the temporal blocks used for the investment Variables for the connection.\nconnection__to_node__unit_constraint holds Parameters for the connection_flow variable to the node in question in the custom unit_constraint.\nnode__investment_stochastic_structure defines the stochastic_structure used for the investment Variables for the node.\nnode__investment_temporal_block defines the stochastic_structure used for the investment Variables for the node.\nnode__unit_constraint holds Parameters for the node_state variable in the custom unit_constraint.\nunit__from_node__unit_constraint holds Parameters for the unit_flow variable from the node in question in the custom unit_constraint.\nunit__investment_stochastic_structure defines the stochastic_structure used for the investment Variables for the unit.\nunit__investment_temporal_block defines the temporal blocks used for the investment Variables for the unit.\nunit__to_node__unit_constraint holds Parameters for the unit_flow variable to the node in question in the custom unit_constraint.","category":"page"},{"location":"concept_reference/the_basics/#Meta-relationship-classes-1","page":"Basics of the model structure","title":"Meta relationship classes","text":"","category":"section"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"Meta Relationship Classes are used for defining model-level settings, like which temporal blocks or stochastic structures are active, and what the model output is. These include:","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"model__default_investment_stochastic_structure defines a default stochastic_structure to be used for investment Variables when no other definitions exist.\nmodel__default_investment_temporal_block defines a default temporal_block to be used for investment Variables when no other definitions exist.\nmodel__default_stochastic_structure defines a default stochastic_structure to be used for nodes and units when no other definitions exist.\nmodel__default_temporal_block defines a default temporal_block to be used for nodes and units when no other definitions exist.\nmodel__report connects each report to the desired model.\nmodel__stochastic_structure defines which stochastic structures are active in which models.\nmodel__temporal_block defines which temporal blocks are active in which models.\nreport__output defines which outputs are part of which report.","category":"page"},{"location":"concept_reference/the_basics/#Introduction-to-parameters-1","page":"Basics of the model structure","title":"Introduction to parameters","text":"","category":"section"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"While the primary function of Object Classes and Relationship Classes is to define the system to be modelled and it's structure, Parameters exist to constrain them. Every parameter is attributed to at least one object class or relationship class, but some appear in many classes whenever they serve a similar purpose.","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"Parameters accept different types of values depending on their purpose, e.g. whether they act as a flag for some specific functionality or appear as a coefficient in Constraints, so understanding each parameter is key. Most coefficient-type Parameters accept constant, time series, and even stochastic time series form input, but there are some exceptions. Most flag-type Parameters, on the other hand, have a restricted list of acceptable values defined by their Parameter Value Lists.","category":"page"},{"location":"concept_reference/the_basics/#","page":"Basics of the model structure","title":"Basics of the model structure","text":"The existence of some Constraints is controlled based on if the relevant Parameters are defined. As a rule-of-thumb, a constraint only gets generated if at least one of the Parameters appearing in it is defined, but one should refer to the appropriate Constraints and Parameters sections when in doubt.","category":"page"},{"location":"concept_reference/the_basics/#Introduction-to-groups-of-objects-1","page":"Basics of the model structure","title":"Introduction to groups of objects","text":"","category":"section"},{"location":"concept_reference/storage_investment_variable_type/#","page":"-","title":"-","text":"Within an investments problem storage_investment_variable_type determines the storage investment decision variable type. Since a node's node_state will be limited to the product of the investmentvariable and the corresponding [node\\state_cap](@ref) and since candidate_storages represents the upper bound of the storage investment decision variable, storage_investment_variable_type thus determines what the investment decision represents. If storage_investment_variable_type is integer or binary, then candidate_storages represents the maximum number of discrete storages that may be invested-in. If storage_investment_variable_type is continuous, candidate_storages is more analagous to a capacity with node_state_cap being analagous to a scaling parameter. For example, if storage_investment_variable_type = integer, candidate_storages = 4 and node_state_cap = 1000 MWh, then the investment decision is how many 1000h MW storages to build. If storage_investment_variable_type = continuous, candidate_storages = 1000 and node_state_cao = 1 MWh, then the investment decision is how much storage capacity to build. Finally, if storage_investment_variable_type = integer, candidate_storages = 10 and node_state_cap = 100 MWh, then the investment decision is many 100MWh storage blocks to build.","category":"page"},{"location":"concept_reference/storage_investment_variable_type/#","page":"-","title":"-","text":"See also investment_optimization and candidate_storages","category":"page"},{"location":"concept_reference/model__default_investment_temporal_block/#","page":"-","title":"-","text":"model__default_investment_temporal_block is a two-dimensional relationship between a model and a temporal_block. This relationship defines the default temporal resolution and scope for all investment decisions in the model (units, connections and storages). Specifying model__default_investment_temporal_block for a model avoids the need to specify individual node__investmenttemporalblock, unit__investmenttemporalblock and connection__investmenttemporalblock relationships. Convesely, if any of these individual relationships are defined (e.g. connection__investmenttemporalblock) along with model__temporal_block, these will override model__defaultinvestmenttemporal_block.","category":"page"},{"location":"concept_reference/model__default_investment_temporal_block/#","page":"-","title":"-","text":"See also investment_optimization","category":"page"},{"location":"concept_reference/fix_ratio_out_in_unit_flow/#","page":"-","title":"-","text":"The definition of the fix_ratio_out_in_unit_flow parameter triggers the generation of the constraint_fix_ratio_out_in_unit_flow and fixes the ratio between out and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. To enforce e.g. a fixed ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ngthe fix_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/unit_idle_heat_rate/#","page":"-","title":"-","text":"Used to implement the no-load or idle heat rate of a unit. This is the y-axis offset of the heat rate function and is the fuel consumed per unit time when a unit is online and that results in no additional output. This is defined on the unit__node__node relationship and it is assumed that the input flow from node 1 represents fuel consumption and the output flow to node 2 is the elecrical output. While the units depend on the data, unit_idle_heat_rate is generally expressed in GJ/hr. Used in conjunction with unit_incremental_heat_rate. unit_idle_heat_rate is only currently considered if unit_incremental_heat_rate is specified. A trivial unit_incremental_heat_rate of zero can be defined if there is no incremental heat rate.","category":"page"},{"location":"library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Documentation for SpineOpt.jl.","category":"page"},{"location":"library/#Contents-1","page":"Library","title":"Contents","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\r\nDepth = 3","category":"page"},{"location":"library/#Index-1","page":"Library","title":"Index","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/#Public-interface-1","page":"Library","title":"Public interface","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"run_spineopt","category":"page"},{"location":"library/#SpineOpt.run_spineopt","page":"Library","title":"SpineOpt.run_spineopt","text":"run_spineopt(url_in, url_out; <keyword arguments>)\n\nRun the SpineOpt from url_in and write report to url_out. At least url_in must point to valid Spine database. A new Spine database is created at url_out if it doesn't exist.\n\nKeyword arguments\n\nwith_optimizer=with_optimizer(Cbc.Optimizer, logLevel=0) is the optimizer factory for building the JuMP model.\n\ncleanup=true tells run_spineopt whether or not convenience functors should be set to nothing after completion.\n\nadd_constraints=m -> nothing is called with the Model object in the first optimization window, and allows adding user contraints.\n\nupdate_constraints=m -> nothing is called in windows 2 to the last, and allows updating contraints added by add_constraints.\n\nlog_level=3 is the log level.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"TODO","category":"page"},{"location":"library/#Internals-1","page":"Library","title":"Internals","text":"","category":"section"},{"location":"library/#Variable-library-1","page":"Library","title":"Variable library","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"unit_flow_indices","category":"page"},{"location":"library/#SpineOpt.unit_flow_indices","page":"Library","title":"SpineOpt.unit_flow_indices","text":"unit_flow_indices(\n    unit=anything,\n    node=anything,\n    direction=anything,\n    s=anything\n    t=anything\n)\n\nA list of NamedTuples corresponding to indices of the unit_flow variable where the keyword arguments act as filters for each dimension.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"TODO","category":"page"},{"location":"library/#Constraint-library-1","page":"Library","title":"Constraint library","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"TODO","category":"page"},{"location":"library/#Objective-1","page":"Library","title":"Objective","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"TODO","category":"page"},{"location":"concept_reference/fix_ratio_out_out_unit_flow/#","page":"-","title":"-","text":"The definition of the fix_ratio_out_out_unit_flow parameter triggers the generation of the constraint_fix_ratio_out_out_unit_flow and fixes the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. To enforce a fixed ratio between to products of a unit u, e.g. fixing the share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"mathematical_formulation/constraints/#Constraints-1","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Balance-constraint-1","page":"Constraints","title":"Balance constraint","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_nodal_balance-1","page":"Constraints","title":"Nodal balance","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In SpineOpt, node is the place where an energy balance is enforced. As universal aggregators, they are the glue that brings all components of the energy system together. An energy balance is created for each node for all node_stochastic_time_indices, unless the balance_type parameter of the node takes the value balance_type_none or if the node in question is a member of a node group, for which the balance_type is balance_type_group. The parameter nodal_balance_sense defaults to equality, but can be changed to allow overproduction (nodal_balance_sense >=) or underproduction (nodal_balance_sense <=). The energy balance is enforced by the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_injection(nst) \r\n + sum_substack(connnd_inst) in connection_flow_indices  d_out == to_node\r\n v_connection_flow(connnd_inst)\r\n - sum_substack(connnd_outst) in connection_flow_indices  d_out == from_node\r\n v_connection_flow(connnd_outst)\r\n  + v_node_slack_pos(nst) \r\n  - v_node_slack_neg(nst) \r\n ==== \r\n 0 \r\n forall (nst) in node_stochastic_time_indices \r\n p_balance_type(n) = balance_type_none \r\n nexists ng in groups(n)  balance_type_group \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The constraint consists of the node injections, the net connections flows and node slack variables.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_node_injection-1","page":"Constraints","title":"Node injection","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The node injection itself represents all local production and consumption, represented by the sum of all connected unit flows and the nodal demand. The node injection is created for each node in the network (unless the node is only used for parameter aggregation purposes, see Introduction to groups of objects).","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_injection(nst) \r\n == \r\n + sum_substack(und_inst) in unit_flow_indices  d_out == to_node\r\n v_unit_flow(und_inst)\r\n - sum_substack(und_outst) in unit_flow_indices  d_out == from_node\r\n v_unit_flow(und_outst)\r\n - p_demand(nst)\r\n forall (nst) in node_stochastic_time_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_node_injection2-1","page":"Constraints","title":"Node injection with storage capability","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"If a node corresponds to a storage node, the parameter has_state should be set to true for this node. In this case the nodal injection will translate to the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_injection(nst) \r\n == \r\n (v_node_state(n s t_before)\r\n - v_node_state(n s t) cdot p_state_coeff(nst)) \r\n    Delta t_after \r\n  - v_node_state(n s t) cdot p_frac_state_loss(nst) \r\n  + sum_substack(n2st) in node_state_indices  exists diff_coeff(n2n)\r\nv_node_state(n2st)\r\n - sum_substack(n2st) in node_state_indices  exists diff_coeff(nn2)\r\nv_node_state(n2st)\r\n + sum_substack(und_inst) in unit_flow_indices  d_out == to_node\r\n v_unit_flow(und_inst)\r\n - sum_substack(und_outst) in unit_flow_indices  d_out == from_node\r\n v_unit_flow(und_outst)\r\n - demand(nst)\r\n forall (nt) in node_time_indices  p_has_state(n)\r\n forall s in stochastic_scenario_path \r\n t_before in t_before_t(t_after=t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that for simplicity, the stochastic path is assumed to be known. In the constraint constraint_node_injection.jl the active stochastic paths of all involved variables is retrieved beforehand.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_node_state_capacity-1","page":"Constraints","title":"Node state capacity","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"To limit the storage content, the v_node_state variable needs be constrained by the following equation:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_state(n s t)\r\n = p_node_state_cap(n s t)\r\n forall (nst) in node_stochastic_time_indices  \r\n p_has_state(n)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The discharging and charging behavior of storage nodes can be described through unit(s), representing the link between the storage node and the supply node. Note that the dis-/charging efficiencies and capacities are properties of these units. See the capacity constraint and the unit flow ratio constraints","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_cyclic_node_state-1","page":"Constraints","title":"Cyclic condition on node state variable","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"To ensure that the node state at the end of the optimization is at least the same value as the initial value at the beginning of the optimization (or higher), the cyclic node state constraint can be used by setting the cyclic_condition of a node__temporal_block to true. This trigger the following cyclic constraint:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_state(n s t)\r\n =  v_node_state(n s t)\r\n forall (ntb) in p_cyclic_condition(ntb)  \r\n p_cyclic_condition(ntb) == true\r\n p_has_state(n) \r\n forall (nt_initial) in node_time_indices  \r\n n == n \r\n t_initial == t_before_t(t_after=first(t in tb))\r\n forall (nt_last) in node_time_indices  \r\n n == n \r\n t_last == last(t in tb))\r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#Unit-operation-1","page":"Constraints","title":"Unit operation","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In the following, the operational constraints on the variables associated with units will be elaborated on. The static constraints, in contrast to the dynamic constraints, are addressing constraint without sequential time-coupling. It should however be noted that static constraints can still perform temporal aggregation.","category":"page"},{"location":"mathematical_formulation/constraints/#static-constraints-unit-1","page":"Constraints","title":"Static constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The fundamental static constraints for units within SpineOpt relate to the relationships between commodity flows from and to units and to limits on the unit flow capacity.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_ratio_unit_flow-1","page":"Constraints","title":"Conversion constraint / limiting flow shares inprocess / relationship in process","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"A unit can have different commodity flows associated with it. The most simple relationship between these flows is a linear relationship between input and/or output nodes/node groups. SpineOpt holds constraints for each combination of flows and also for the type of relationship, i.e. whether it is a maximum, minimum or fixed ratio between commodity flows. Note that node groups can be used in order to aggregate flows, i.e. to give a ratio between a combination of units flows.","category":"page"},{"location":"mathematical_formulation/constraints/#ratio_out_in-1","page":"Constraints","title":"Ratios between output and input flows of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"By defining the parameters fix_ratio_out_in_unit_flow, max_ratio_out_in_unit_flow or min_ratio_out_in_unit_flow, a ratio can be set between outgoing and incoming flows from and to a unit. Whenever there is only a single input node and a single output node, this relationship relates to the notion of an efficiency. Also, the ratio equation can for instance be used to relate emissions to input primary fuel flows. In the most general form of the equation, two node groups are defined (an input node group ng_in and an output node group ng_out), and a linear relationship is expressed between both node groups. Note that whenever the relationship is specified between groups of multiple nodes, there remains a degree of freedom regarding the composition of the input node flows within group ng_in  and the output node flows within group ng_out.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The constrained given below enforces a fixed, maximum or minimum ratio between outgoing and incoming v_unit_flow. Note that the potential node groups, that the parameters  fix_ratio_out_in_unit_flow, max_ratio_out_in_unit_flow and min_ratio_out_in_unit_flow defined on, are getting internally expanded to the members of the node group within the unit_flow_indices.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst_out) in unit_flow_indices  (undst_out)  in  (ung_outto_nodest) v_unit_flow(undst_out) cdot Delta t_out \r\n  \r\n ==  p_fix_ratio_out_in_unit_flow(ung_outng_inst) \r\n = p_max_ratio_out_in_unit_flow(ung_outng_inst) \r\n = p_min_ratio_out_in_unit_flow(ung_outng_inst)\r\n  \r\n cdot sum_substack(undst_in) in unit_flow_indices (undst_in) in (ung_infrom_nodest) v_unit_flow(undst_in) cdot Delta t_in \r\n + p_fixmaxmin_units_on_coefficient_out_in(ung_outng_inst) \r\n sum_substack(ust_units_on) in units_on_indices\r\n (ust_units_on) in (ust) v_units_on(ust_units_on) \r\n cdot min(Delta t_units_onDelta t) \r\n forall (u ng_out ng_in) in ind(p_fixmaxmin_ratio_out_in_unit_flow) \r\n forall t in time_slices forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that a right-hand side constant coefficient associated with the variable v_{units\\_on} can optionally be included, triggered by the existence of the fix_units_on_coefficient_out_in, max_units_on_coefficient_out_in, min_units_on_coefficient_out_in, respectively.","category":"page"},{"location":"mathematical_formulation/constraints/#ratio_in_out-1","page":"Constraints","title":"Ratios between input and output flows of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Similarly to the ratio between outgoing and incoming unit flows, a ratio can also be defined in reverse between incoming and outgoing flows.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst_in) in unit_flow_indices  (undst_in)  in  (ung_infrom_nodest) v_unit_flow(undst_in) cdot Delta t_in \r\n  \r\n ==  p_fix_ratio_in_out_unit_flow(ung_inng_outst) \r\n = p_max_ratio_in_out_unit_flow(ung_inng_outst) \r\n = p_min_ratio_in_out_unit_flow(ung_inng_outst)\r\n  \r\n cdot sum_substack(undst_out) in unit_flow_indices (undst_in) in (ung_into_nodest) v_unit_flow(undst_out) cdot Delta t_out \r\n + p_fixmaxmin_units_on_coefficient_in_out(ung_inng_outst) \r\n sum_substack(ust_units_on) in units_on_indices\r\n (ust_units_on) in (ust) v_units_on(ust_units_on) \r\n  cdot min(Delta t_units_onDelta t) \r\n forall (u ng_in ng_out) in ind(p_fixmaxmin_ratio_in_out_unit_flow) \r\n forall t in time_slices forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that a right-hand side constant coefficient associated with the variable v_{units\\_on} can optionally be included, triggered by the existence of the fix_units_on_coefficient_in_out, max_units_on_coefficient_in_out, min_units_on_coefficient_in_out, respectively.","category":"page"},{"location":"mathematical_formulation/constraints/#ratio_in_in-1","page":"Constraints","title":"Ratios between input and input flows of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Similarly to the ratio between outgoing and incoming units flows, one can also define a fixed, maximum or minimum ratio between incoming flows of a units.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst_in1) in unit_flow_indices  (undst_in1)  in  (ung_in1from_nodest) v_unit_flow(undst_in1) cdot Delta t_in1 \r\n  \r\n ==  p_fix_ratio_in_in_unit_flow(ung_in1ng_in2st) \r\n = p_max_ratio_in_in_unit_flow(ung_in1ng_in2st) \r\n = p_min_ratio_in_in_unit_flow(ung_in1ng_in2st)\r\n  \r\n cdot sum_substack(undst_in2) in unit_flow_indices (undst_in2) in (ung_in2from_nodest) v_unit_flow(undst_in2) cdot Delta t_in2 \r\n + p_fixmaxmin_units_on_coefficient_in_in(ung_in1ng_in2st) \r\n sum_substack(ust_units_on) in units_on_indices\r\n (ust_units_on) in (ust) v_units_on(ust_units_on) \r\n  cdot min(Delta t_units_onDelta t) \r\n forall (u ng_in1 ng_in2) in ind(p_fixmaxmin_ratio_in_in_unit_flow) \r\n forall t in time_slices forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that a right-hand side constant coefficient associated with the variable v_{units\\_on} can optionally be included, triggered by the existence of the fix_units_on_coefficient_in_in, max_units_on_coefficient_in_in, min_units_on_coefficient_in_in, respectively.","category":"page"},{"location":"mathematical_formulation/constraints/#ratio_out_out-1","page":"Constraints","title":"Ratios between output and output flows of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Similarly to the ratio between outgoing and incoming units flows, one can also define a fixed, maximum or minimum ratio between outgoing flows of a units.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst_out1) in unit_flow_indices  (undst_out1)  in  (ung_out1to_nodest) v_unit_flow(undst_out1) cdot Delta t_out1 \r\n  \r\n ==  p_fix_ratio_out_out_unit_flow(ung_out1ng_out2st) \r\n = p_max_ratio_out_out_unit_flow(ung_out1ng_out2st) \r\n = p_min_ratio_out_out_unit_flow(ung_out1ng_out2st)\r\n  \r\n cdot sum_substack(undst_out2) in unit_flow_indices (undst_out2) in (ung_out2to_nodest) v_unit_flow(undst_out2) cdot Delta t_out2 \r\n + p_fixmaxmin_units_on_coefficient_out_out(ung_out1ng_out2st) \r\n sum_substack(ust_units_on) in units_on_indices\r\n (ust_units_on) in (ust) v_units_on(ust_units_on) \r\n  cdot min(Delta t_units_onDelta t) \r\n forall (u ng_out1 ng_out2) in ind(p_fixmaxmin_ratio_out_out_unit_flow) \r\n forall t in time_slices forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that a right-hand side constant coefficient associated with the variable v_{units\\_on} can optionally be included, triggered by the existence of the fix_units_on_coefficient_out_out, max_units_on_coefficient_out_out, min_units_on_coefficient_out_out, respectively.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_unit_flow_capacity-1","page":"Constraints","title":"Bounds on the unit capacity","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In a multi-commodity setting, there can be different commodities entering/leaving a certain technology/unit. These can be energy-related commodities (e.g., electricity, natural gas, etc.), emissions, or other commodities (e.g., water, steel). The unit_capacity be specified for at least one unit__to_node or unit__from_node relationship, in order to trigger a constraint on the maximum commodity flows to this location in each time step. When desirable, the capacity can be specified for a group of nodes (e.g. combined capacity for multiple products).","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst) in unit_flow_indices  (undst)  in  (ungdst) v_unit_flow(undst) cdot Delta t \r\n = p_unit_capacity(ungdst) \r\n  cdot p_unit_conv_cap_to_flow(ungdst) \r\n  cdot sum_substack(ust_units_on) in units_on_indices\r\n(uDelta t_units_on in (ut) v_units_on(ust_units_on) \r\n cdot min(t_units_onDelta t) \r\n forall (ungd) in ind(p_unit_capacity) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that the conversion factor unit_conv_cap_to_flow has a default value of 1, but can be adjusted in case the unit of measurement for the capacity is different the unit flows unit of measurement.","category":"page"},{"location":"mathematical_formulation/constraints/#Dynamic-constraints-1","page":"Constraints","title":"Dynamic constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Commitment-constraints-1","page":"Constraints","title":"Commitment constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"For modeling certain technologies/units, it is important to not only have v_unit_flow variables of different commodities, but also model the online (\"commitment\") status of the unit/technology at every time step. Therefore, an additional variable v_units_on is introduced. This variable represents the number of online units of that technology (for a normal unit commitment model, this variable might be a binary, for investment planning purposes, this might also be an integer or even a continuous variable). To define the type of a commitment variable, see online_variable_type. Commitment variables will be introduced by the following constraints (with corresponding parameters):","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"constraint on units_on\nconstraint on units_available\nconstraint on the unit state transition\nconstraint on the minimum operating point\nconstraint on minimum down time\nconstraint on minimum up time\nconstraint on ramp rates","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_units_on-1","page":"Constraints","title":"Bound on online units","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The number of online units need to be restricted to the number of available units:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n  v_units_on(ust) \r\n = v_units_available(ust) \r\n forall (ust) in units_on_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_units_available-1","page":"Constraints","title":"Bound on available units","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The number of available units itself is constrained by the parameters unit_availability_factor and number_of_units, and the variable number of invested units v_units_invested_available):","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_available(ust) \r\n == p_unit_availability_factor(ust) \r\n cdot (p_number_of_units(ust) \r\n + sum_(ust) in units_invested_available_indices v_units_invested_available(ust) ) \r\n forall (ust) in units_on_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The investment formulation is described in chapter Investments.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_unit_state_transition-1","page":"Constraints","title":"Unit state transition","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The units on status is furtheron constraint by shutting down and starting up actions. This transition is defined as follows:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_on(ust_after) \r\n - v_units_started_up(ust_after) \r\n + v_units_shut_down(ust_after) \r\n == v_units_on(ust_before) \r\n forall (ust_after) in units_on_indices \r\n forall t_before in t_before_t(t_after=t_after)  t_before in units_on_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_minimum_operating_point-1","page":"Constraints","title":"Constraint on minimum operating point","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The minimum operating point of a unit can be based on the v_unit_flow's of input or output nodes/node groups ng:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst) in unit_flow_indices  (undt)  in  (ungdt) v_unit_flow(undst) cdot Delta t \r\n = p_minimum_operating_point(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n  cdot cdot p_conv_cap_to_flow(ungdst) \r\n  cdot sum_substack(ust_units_on) in units_on_indices (uDelta t_units_on in (ut) v_units_on(ust_units_on) \r\n cdot min(Delta t_units_onDelta t) \r\n forall (ungd) in ind(p_minimum_operating_point) \r\n forall t in t_lowest_resolution(node__temporal_block(node=members(ng)))\r\n  forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that this constraint is always generated for the lowest resolution of all involved members of the node group ng, i.e. the lowest resolution of the involved units flows. This is also why the term \\min(t_{units\\_on},\\Delta t) is added for the units on variable, in order to dis-/aggregate the units on resolution to the resolution of the unit flows.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_down_time-1","page":"Constraints","title":"Minimum down time (basic version)","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In order to impose a minimum offline time of a unit, before it can be started up again, the min_down_time parameter needs to be defined, which triggers the generation of the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_available(ust) \r\n - v_units_on(ust) \r\n = sum_substack(ust) in units_on_indices  t =t-p_min_down_time(ust)  t = t\r\nv_units_shut_down(ust) \r\n forall (ust) in units_on_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that for the use reserves the generated minimum down time constraint will include startups for non-spinning reserves.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_up_time-1","page":"Constraints","title":"Minimum up time (basic version)","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Similarly to the minimum down time constraint, a minimum time that a unit needs to remain online after a startup can be imposed by defining the min_up_time parameter. This will trigger the generation of the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_on(ust) \r\n = sum_substack(ust) in units_on_indices  t =t-p_min_up_time(ust)  t = t\r\nv_units_started_up(ust) \r\n forall (ust) in units_on_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"This constraint can be extended to the use of nonspinning reserves. See also.","category":"page"},{"location":"mathematical_formulation/constraints/#Ramping-and-reserve-constraints-1","page":"Constraints","title":"Ramping and reserve constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"To include ramping and reserve constraints, it is a pre requisite that minimum operating points and maximum capacity constraints are enforced as described.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"For dispatchable units, additional ramping constraints can be introduced. For setting up ramping characteristics of units see Ramping and Reserves. First, the unit flows are split into their online, start-up, shut-down and non-spinning ramping contributions.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_split_ramps-1","page":"Constraints","title":"Splitting unit flows into ramps","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst_after) in unit_flow_indices  (undt_after)  in  (undt_after) p_is_reserve(n) v_unit_flow(undst_after) \r\n + sum_substack(undst_after) in unit_flow_indices  (undt_after)  in  (undt_after) p_is_reserve(n)  p_upward_reserve(n) v_unit_flow(undst_after) \r\n - sum_substack(undst_after) in unit_flow_indices  (undt_after)  in  (undt_after) p_is_reserve(n)  p_downward_reserve(n) v_unit_flow(undst_after) \r\n - sum_substack(undst_before) in unit_flow_indices  (undt_before)  in  (undt_before) p_is_reserve(n) v_unit_flow(undst_before) \r\n ==  \r\n + sum_substack(undst_after) in ramp_up_unit_flow_indices  (undt_after)  in  (undt_after) v_ramp_up_unit_flow(undst_after)  \r\n + sum_substack(undst_after) in start_up_unit_flow_indices  (undt_after)  in  (undt_after) v_start_up_unit_flow(undst_after) \r\n + sum_substack(undst_after) in nonspin_ramp_up_unit_flow_indices  (undt_after)  in  (undt_after) v_nonspin_ramp_up_unit_flow(undst_after) \r\n - sum_substack(undst_after) in ramp_down_unit_flow_indices  (undt_after)  in  (undt_after) v_ramp_down_unit_flow(undst_after) \r\n - sum_substack(undst_after) in shut_down_unit_flow_indices  (undt_after)  in  (undt_after) v_shut_down_unit_flow(undst_after) \r\n - sum_substack(undst_after) in nonspin_ramp_down_unit_flow_indices  (undt_after)  in  (undt_after) v_nonspin_ramp_down_unit_flow(undst_after) \r\n forall (undst_after) in (\r\n ramp_up_unit_flow_indices\r\n start_up_unit_flow_indices\r\n nonspin_ramp_up_unit_flow_indices \r\n ramp_down_unit_flow_indices\r\n shut_down_unit_flow_indices\r\n nonspin_ramp_down_unit_flow_indices) \r\n forall t_before in t_before_t(t_after=t_after)  t_before in unit_flow_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that each individual tuple of the unitflowindices is split into its ramping contributions, if any of the ramping variables exist for this tuple. How to set-up ramps for units is described in Ramping and Reserves.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_ramp_up-1","page":"Constraints","title":"Constraint on spinning upwards ramp_up","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The maximum online ramp up ability of a unit can be constraint by the ramp_up_limit, expressed as a share of the unit_capacity. With this constraint, online (i.e. spinning) ramps can be applied to groups of commodities (e.g. electricity + balancing capacity). Moreover, balancing product might have specific ramping requirements, which can herewith also be enforced.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in ramp_up_unit_flow_indices  (und)  in  (ungd) v_ramp_up_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t)\r\n (v_units_on(ust)\r\n - v_units_started_up(ust)) \r\n min(Delta tDelta t) \r\n cdot p_ramp_up_limit(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_ramp_up_limit)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that only online units that are not started up during this timestep are considered.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_start_up_ramp-1","page":"Constraints","title":"Constraint on minimum upward start up ramp_up","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"To enforce a lower bound on the ramp of a unit during start-up, the min_startup_ramp given as a share of the unit_capacity needs to be defined, which triggers the constraint below. Usually, only non-reserve commodities can have a start-up ramp. However, it is possible to include them, by adding them to the ramp defining node ng.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in start_up_unit_flow_indices  (und)  in  (ungd) v_start_up_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t) \r\n cdot p_min_startup_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_min_startup_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_start_up_ramp-1","page":"Constraints","title":"Constraint on maximum upward start up ramp_up","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"This constraint enforces a upper limit on the unit ramp during startup process, triggered by the existence of the max_startup_ramp, which should be given as a share of the unit_capacity. Typically, only  ramp flows to non-reserve nodes are considered during the start-up process. However, it is possible to include them, by adding them to the ramp defining node ng.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in start_up_unit_flow_indices  (und)  in  (ungd) v_start_up_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t) \r\n cdot p_max_startup_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_max_startup_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_down_time2-1","page":"Constraints","title":"Constraint on upward non-spinning start ups","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"For non-spinning reserve provision, offline units can be scheduled to provide nonspinning reserves, if they have recovered their minimum down time. If nonspinning reserves are used for a unit, the minimum down-time constraint takes the following form:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_available(ust) \r\n - v_units_on(ust) \r\n = sum_substack(ust) in units_on_indices  t t-p_min_down_time(ust)  t = t\r\nv_units_shut_down(ust) \r\n sum_substack(unst) in nonspin_units_started_up_indices (ust) in (ust)\r\n  v_nonspin_units_started_up(unst) \r\n forall (ust) in units_on_indices\r\n (u) in nonspin_units_started_up_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_nonspin_ramp_up-1","page":"Constraints","title":"Minimum nonspinning ramp up","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The nonspinning ramp flows of a units v_{nonspin\\_ramp\\_up\\_unit\\_flow} are dependent on the units holding available for nonspinning reserve provision, i.e. v_{nonspin\\_units\\_started\\_up}. A lower bound on these nonspinning reserves can be enforced by defining the min_res_startup_ramp parameter (given as a fraction of the unit_capacity).","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in nonspin_ramp_up_unit_flow_indices  (und)  in (ungd) v_nonspin_ramp_up_unit_flow(undst)  \r\n = \r\n + sum_substack(unst) in nonspin_units_started_up_indices  (un)  in (ung v_nonspin_units_started_up(unst)  \r\n cdot p_min_res_startup_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_min_res_startup_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_nonspin_ramp_up-1","page":"Constraints","title":"Maximum nonspinning ramp up","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The nonspinning ramp flows of a units v_{nonspin\\_ramp\\_up\\_unit\\_flow} are dependent on the units holding available for nonspinning reserve provision, i.e. v_{nonspin\\_units\\_started\\_up}. An upper bound on these nonspinning reserves can be enforced by defining the max_res_startup_ramp parameter (given as a fraction of the unit_capacity).","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in nonspin_ramp_up_unit_flow_indices  (und)  in (ungd) v_nonspin_ramp_up_unit_flow(undst)  \r\n = \r\n + sum_substack(unst) in nonspin_units_started_up_indices  (un)  in (ung v_nonspin_units_started_up(unst)  \r\n cdot p_max_res_startup_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_max_res_startup_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_ramp_down-1","page":"Constraints","title":"Constraint on spinning downward ramps","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Similarly to the online ramp up capbility of a unit, it is also possible to impose an upper bound on the online ramp down ability of unit by defining a ramp_down_limit, expressed as a share of the unit_capacity.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in ramp_down_unit_flow_indices  (und)  in  (ungd) v_ramp_down_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t)\r\n (v_units_on(ust)\r\n - v_units_started_up(ust)) \r\n cdot p_ramp_down_limit(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_ramp_down_limit)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_shut_down_ramp-1","page":"Constraints","title":"Lower bound on downward shut-down ramps","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"This constraint enforces a lower bound on the unit ramp during shutdown process. Usually, units will only provide shutdown ramps to non-reserve nodes. However, it is possible to include them, by adding them to the ramp defining node ng. The constraint is triggered by the existence of the min_shutdown_ramp parameter.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in shut_down_unit_flow_indices  (und)  in  (ungd) v_shut_down_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t) v_units_shut_down(ust) \r\n cdot p_min_shutdown_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_min_shutdown_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_shut_down_ramp-1","page":"Constraints","title":"Upper bound on downward shut-down ramps","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"This constraint enforces an upper bound on the unit ramp during shutdown process. Usually, units will only provide shutdown ramps to non-reserve nodes. However, it is possible to include them, by adding them to the ramp defining node ng. The constraint is triggered by the existence of the max_shutdown_ramp parameter.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in shut_down_unit_flow_indices  (und)  in  (ungd) v_shut_down_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t) v_units_shut_down(ust) \r\n cdot p_max_shutdown_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_max_shutdown_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_up_time2-1","page":"Constraints","title":"Constraint on upward non-spinning shut-downs","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"For non-spinning downward reserves, online units can be scheduled for reserve provision through shut down if they have recovered their minimum up time. If nonspinning reserves are used the minimum up-time constraint becomes:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_on(ust) \r\n = sum_substack(ust) in units_on_indices  t t-p_min_up_time(ust)  t = t\r\nv_units_started_up(ust) \r\n sum_substack(unst) in nonspin_units_shut_down_indices  (ust) in (ust)\r\n  v_nonspin_units_shut_down(unst) \r\n forall (ust) in units_on_indices\r\n u in nonspin_units_started_up_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_nonspin_ramp_down-1","page":"Constraints","title":"Lower bound on the nonspinning downward reserve provision","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"A lower bound on the nonspinning reserve provision of a unit can be imposed by defining the min_res_shutdown_ramp parameter, which leads to the creation of the following constraint in the model:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in nonspin_ramp_down_unit_flow_indices  (undst)  in (undst) v_nonspin_ramp_down_unit_flow(undst)  \r\n = \r\n + sum_substack(unst) in nonspin_units_shut_down_indices  (unst)  in (unst) v_nonspin_units_shut_down(unst)  \r\n cdot p_min_res_shutdown_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_min_res_shutdown_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_nonspin_ramp_down-1","page":"Constraints","title":"Upper bound on the nonspinning downward reserve provision","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"An upper limit on the nonspinning reserve provision of a unit can be imposed by defining the max_res_shutdown_ramp parameter, which leads to the creation of the following constraint in the model:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in nonspin_ramp_down_unit_flow_indices  (undst)  in (undst) v_nonspin_ramp_down_unit_flow(undst)  \r\n = \r\n + sum_substack(unst) in nonspin_units_shut_down_indices  (unst)  in (unst) v_nonspin_units_shut_down(unst)  \r\n cdot p_max_res_shutdown_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_max_res_shutdown_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_res_minimum_node_state-1","page":"Constraints","title":"Constraint on minimum node state for reserve provision","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Storage nodes can also contribute to the provision of reserves. The amount of balancing contributions is limited by the ramps of the storage unit (see above) and by the node state:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_state(n_stor s t)\r\n = p_node_state_min(n_stor s t) \r\n + sum_substack(un_resdst) in unit_flow_indices  u in unit_flow_indicesn=n_stor)  p_is_reserve_node(n_res)  v_unit_flow(un_resdst)  \r\n cdot p_minimum_reserve_activation_time(n_res) \r\n forall (n_storst) in node_stochastic_time_indices  p_has_state(n)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_unit_flow_capacity_w_ramps-1","page":"Constraints","title":"Bounds on the unit capacity including ramping constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"(Currently under development)","category":"page"},{"location":"mathematical_formulation/constraints/#Operating-segments-1","page":"Constraints","title":"Operating segments","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_operating_point_bounds-1","page":"Constraints","title":"Operating segments of units","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_operating_point_sum-1","page":"Constraints","title":"Bounding unit flows by summing over operating segments","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_unit_pw_heat_rate-1","page":"Constraints","title":"Heat rate?","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Bounds-on-commodity-flows-1","page":"Constraints","title":"Bounds on commodity flows","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_max_cum_in_unit_flow_bound-1","page":"Constraints","title":"Upper bound on cumulated unit flows","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"To impose a limit on the cumulative amount of certain commodity flows, a cumulative bound can be set by defining the parameter max_cum_in_unit_flow_bound for entire optimization window:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst) in unit_flow_indices  (undt)  in  (ugngd) v_unit_flow(undst) cdot Delta t \r\n = p_max_cum_unit_flow_bound(ugngdst) \r\n forall (ugngd) in ind(p_max_cum_unit_flow_bound)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"***TODO this constraint needs to be revised. It should be defined on a unitnodegroup as indicated here (which is different from the current implementation)***","category":"page"},{"location":"mathematical_formulation/constraints/#Network-constraints-1","page":"Constraints","title":"Network constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#static-constraints-connection-1","page":"Constraints","title":"Static constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connection_flow_capacity-1","page":"Constraints","title":"Capacity constraint on connections","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_ratio_out_in_connection_flow-1","page":"Constraints","title":"Fixed ratio between outgoing and incoming flows of a connection","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Specific-network-representation-1","page":"Constraints","title":"Specific network representation","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In the following, the different specific network representations are introduced. While the Static constraints find application in any of the different networks, the following equations are specific to the discussed use cases. Currently, SpineOpt incorporated equations for pressure driven gas networks, nodal lossless DC power flows and PTDF based lossless DC power flow.","category":"page"},{"location":"mathematical_formulation/constraints/#pressure-driven-gas-transfer-math-1","page":"Constraints","title":"Pressure driven gas transfer","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"For gas pipelines it can be relevant a pressure driven gas transfer can be modelled, i.a. to account for linepack flexibility. Generally speaking, the main challenges related to pressure driven gas transfers are the non-convexities associated with the Weymouth equation. In SpineOpt, a convexified MILP representation has been implemented, which as been presented in Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling. The approximation approach is based on the Taylor series expansion around fixed pressure points.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In addition to the already known variables, such as connection_flow and node_state, the start and end points of a gas pipeline connection are associated with the variable node_pressure. The variable is trigger by the has_pressure parameter. For more details on how to set up a gas pipeline, see also the advanced concept section on pressure driven gas transfer.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_node_pressure-1","page":"Constraints","title":"Maximum node pressure","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In order to impose an upper limit on the maximum pressure at a node the maximum node pressure constraint can be included, by defining the parameter max_node_pressure which trigger the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(nst) in node_pressure_indices  (nst)  in  (nst) v_node_pressure(nst) cdot Delta t \r\n = p_max_node_pressure(ngst) \r\n cdot Delta t \r\n forall (ng) in ind(p_max_node_pressure) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"As indicated in the equation, the parameter max_node_pressure can also be defined on a node group, in order to impose an upper limit on the aggregated node_pressure within one node group.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_node_pressure-1","page":"Constraints","title":"Minimum node pressure","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In order to impose a lower limit on the pressure at a node the maximum node pressure constraint can be included, by defining the parameter min_node_pressure which trigger the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(nst) in node_pressure_indices  (nst)  in  (nst) v_node_pressure(nst) cdot Delta t \r\n = p_min_node_pressure(ngst) \r\n cdot Delta t \r\n forall (ng) in ind(p_min_node_pressure) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"As indicated in the equation, the parameter min_node_pressure can also be defined on a node group, in order to impose a lower limit on the aggregated node_pressure within one node group.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_compression_factor-1","page":"Constraints","title":"Constraint on the pressure ratio between to nodes","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"If a compression station is located in between to nodes, the connection is considered to be active and a compression ratio between the two nodes can be imposed. The parameter compression_factor needs to be defined on a connection__node__node relationship, where the first node corresponds the origin node, before the compression, while the second node corresponds to the destination node, after compression. The existence of this parameter will trigger the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(nst) in node_pressure_indices  (nst)  in  (ng2st) v_node_pressure(nst) cdot Delta t \r\n = p_compression_factor(connng1ng2st) \r\n sum_substack(nst) in node_pressure_indices  (nst)  in  (ng1st) v_node_pressure(nst) cdot Delta t \r\n forall (connng1ng2) in ind(p_compression_factor) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_fixed_node_pressure_point-1","page":"Constraints","title":"Outer approximation through fixed pressure points","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The Weymouth relates the average flows through a connection to the difference between the adjacent squared node pressures.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n   ((v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2 \r\n     -\r\n     (v_connection_flow(conn n_destfrom_nodest) + v_connection_flow(conn n_origto_nodest))2)\r\n     cdot\r\n   ((v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2\r\n     -\r\n     (v_connection_flow(conn n_destfrom_nodest) + v_connection_flow(conn n_origto_nodest))2 ) \r\n    =\r\n   K(conn)\r\n   cdot (v_node_pressure(n_origst)^2 - n_destst)^2) \r\n  endaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Which can be rewritten as","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n     ((v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2 \r\n       -\r\n       (v_connection_flow(conn n_destfrom_nodest) + v_connection_flow(conn n_origto_nodest))2)\r\n      =\r\n     sqrtK(conn)\r\n     cdot (v_node_pressure(n_origst)^2 - n_destst)^2) \r\n     for (v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2  0\r\n  endaligned\r\n  beginaligned\r\n   ((v_connection_flow(conn n_destfrom_nodest) + v_connection_flow(conn n_origto_nodest))2\r\n   -\r\n   (v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2) \r\n    =\r\n   sqrtK(conn)\r\n   cdot (v_node_pressure(n_destst)^2 - v_node_pressure(n_origst)^2) \r\n     for (v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2  0\r\n  endaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"where K corresponds to the natural gas flow constant.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The cone described by the Weymouth equation can be outer approximated by a number of tangent planes, using a set of fixed pressure points, as illustrated in Schwele - Integration of Electricity, Natural Gas and Heat Systems With Market-based Coordination. The bigM method is used to replace the sign function.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The linearized version of the Weymouth equation implemented in SpineOpt is given as follows:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n     ((v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2 \r\n      =\r\n     p_fixed_pressure_constant_1(connn_orign_destjst) \r\n     cdot v_node_pressure(n_origst) \r\n     - p_fixed_pressure_constant_0(connn_orign_destjst) \r\n     cdot v_node_pressure(n_destst) \r\n     + p_big_m cdot (1 - v_binary_gas_connection_flow(conn n_dest to_node s t)) \r\n      forall (conn n_orig n_dest) in ind(p_fixed_pressure_constant_1) \r\n     forall j in 1n(p_fixed_pressure_constant_1(connection=conn node1=n_orig node2=n_dest)) \r\n     p_fixed_pressure_constant_1(conn n_orig n_dest i=j) = 0 \r\n     forall t in time_slices \r\n     forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The parameters fixed_pressure_constant_1 and fixed_pressure_constant_0 should be defined in the database. For each considered fixed pressure point, they can be calculated as follows:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n   p_fixed_pressure_constant_1(connn_orign_destj) \r\n   = K(conn) * p_fixed_pressure(n_origj) sqrtp_fixed_pressure(n_origj) - p_fixed_pressure(n_destj\r\n   p_fixed_pressure_constant_0(connn_orign_destj) \r\n   = K(conn) * p_fixed_pressure(n_destj) sqrtp_fixed_pressure(n_origj) - p_fixed_pressure(n_destj\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"where K corrsponds to the natural gas flow constant.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"The big_m parameter combined with the variable binary_gas_connection_flow together with the equations on unitary gas flow and on the maximum gas flow ensure that the bound on the average flow through the fixed pressure points becomes active, if the flow is in a positive direction for the observed set of connection, node1 and node2.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_connection_unitary_gas_flow-1","page":"Constraints","title":"Enforcing unidirectional flow","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"As stated above, the flow through a connection can only be in one direction at at time. Whever a flow is active in a certain direction is indicated by the binary_gas_connection_flow variable, which takes a value of 1 if the direction of flow is positive. To ensure that the binary_gas_connection_flow in the opposite direction then takes the value 0, the following constraint is enforced:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_binary_gas_connection_flow(conn n_orig to_node s t)) \r\n (1 - v_binary_gas_connection_flow(conn n_dest to_node s t)) \r\n forall (ndst) in binary_gas_connection_flow_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_connection_flow_gas_capacity-1","page":"Constraints","title":"Gas connection flow capacity","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"To enforce that the averge flow of a connection is only in one direction, the flow in the opposite direction is forced to be 0 by the following euqation. For the connection flow in the direction of flow the parameter big_m should be chosen large enough to not become binding.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n     ((v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2 \r\n      =\r\n     + p_big_m cdot v_binary_gas_connection_flow(conn n_dest to_node s t) \r\n      forall (conn n_orig n_dest) in ind(p_fixed_pressure_constant_1) \r\n     forall t in time_slices \r\n     forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_storage_line_pack-1","page":"Constraints","title":"Linepack storage flexibility","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In order to account for linepack flexibility, i.e. storage capability of a connection, the linepack storage is linked to the average pressure of the adjacent nodes by the following equation, triggered by the parameter connection_linepack_constant:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n     v_node_state(n_storst) Delta t\r\n      =\r\n     p_connection_linepack_constant(connn_storn_ngroup) 2 \r\n     sum_substack(nst) in node_pressure_indices  (nst)  in  (ngst) v_node_pressure(nst) cdot Delta t \r\n      forall (conn n_stor n_ngroup) in ind(p_connection_linepack_constant) \r\n     forall t in time_slices \r\n     forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note that the parameter connection_linepack_constant should be defined on a connection__node___node relationship, where the first node corresponds to the linepack storage node, whereas the second node corresponds to the node group of both start and end nodes of the pipeline.","category":"page"},{"location":"mathematical_formulation/constraints/#nodal-lossless-DC-1","page":"Constraints","title":"Nodebased lossless DC power flow","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"For the implementation of the nodebased loss DC powerflow model, a new variable node_voltage_angle is introduced. See also has_voltage_angle. For further explanation on setting up a database for nodal lossless DC power flow, see the advanced concept chapter on Lossless nodal DC power flows.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_node_voltage_angle-1","page":"Constraints","title":"Maximum node voltage angle","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In order to impose an upper limit on the maximum voltage angle at a node the maximum node voltage angle constraint can be included, by defining the parameter max_voltage_angle which trigger the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(nst) in node_voltage_angle_indices  (nst)  in  (nst) v_node_voltage_angle(nst) cdot Delta t \r\n = p_max_voltage_angle(ngst) \r\n cdot Delta t \r\n forall (ng) in ind(p_max_voltage_angle) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"As indicated in the equation, the parameter max_voltage_angle can also be defined on a node group, in order to impose an upper limit on the aggregated node_voltage_angle within one node group.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_node_voltage_angle-1","page":"Constraints","title":"Minimum node voltage angle","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"In order to impose a lower limit on the voltage angle at a node the maximum node voltage angle constraint can be included, by defining the parameter min_voltage_angle which trigger the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(nst) in node_voltage_angle_indices  (nst)  in  (nst) v_node_voltage_angle(nst) cdot Delta t \r\n = p_min_voltage_angle(ngst) \r\n cdot Delta t \r\n forall (ng) in ind(p_min_voltage_angle) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"As indicated in the equation, the parameter min_voltage_angle can also be defined on a node group, in order to impose a lower limit on the aggregated node_voltage_angle within one node group.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_node_voltage_angle-1","page":"Constraints","title":"Voltage angle to connection flows","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"To link the flow over a connection to the voltage angles of the adjacent nodes, the following constraint is imposed. Note that this constraint is only generated if the parameter connection_reactance is defined for a connection__node__node relationship and if a fix_ratio_out_in_connection_flow is defined for the corresponding connection, node, node tuples.","category":"page"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(connndst) in connection_flow_indices  d_from == from_node  n in n_from\r\n v_connection_flow(connndst)\r\n - sum_substack(connndst) in connection_flow_indices  d_from == from_node  n in n_to\r\n v_connection_flow(connnst)\r\n = \r\n 1p_connection_reactance(conn) cdot p_connection_reactance_base(conn)\r\n cdot (sum_substack(nst) in node_voltage_angle_indices  (nst)  in  (n_fromst) v_node_voltage_angle(nst) cdot Delta t \r\n sum_substack(nst) in node_voltage_angle_indices  (nst)  in  (n_tost) v_node_voltage_angle(nst) cdot Delta t \r\n (conn n_to n_from) in indices(p_fix_ratio_out_in_connection_flow)\r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#PTDF-lossless-DC-1","page":"Constraints","title":"PTDF based DC lossless powerflow ?","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connection_flow_lodf-1","page":"Constraints","title":"connection flow LODF?","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Investments-1","page":"Constraints","title":"Investments","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Investments-in-units-1","page":"Constraints","title":"Investments in units","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_unit_lifetime-1","page":"Constraints","title":"Economic lifetime of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Technical-lifetime-of-a-unit-1","page":"Constraints","title":"Technical lifetime of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_units_invested_transition-1","page":"Constraints","title":"Investment transfer","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Investments-in-connections-1","page":"Constraints","title":"Investments in connections","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connections_invested_available-1","page":"Constraints","title":"Available connection?","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connections_invested_transition-1","page":"Constraints","title":"Transfer of previous investments","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connection_flow_intact_flow-1","page":"Constraints","title":"Intact connection flows?","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connection_intact_flow_capacity-1","page":"Constraints","title":"Intact connection flows capacity?","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connection_intact_flow_ptdf-1","page":"Constraints","title":"Intact flow ptdf","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_ratio_out_in_connection_intact_flow-1","page":"Constraints","title":"Fixed ratio between outgoing and incoming intact ? flows of a connection","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note: is this actually an investment or a network constraint?","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_candidate_connection_flow_lb-1","page":"Constraints","title":"Lower bound on candidate connection flow","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_candidate_connection_flow_ub-1","page":"Constraints","title":"Upper bound on candidate connection flow","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connection_lifetime-1","page":"Constraints","title":"Economic lifetime of a connection","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Technical-lifetime-of-a-connection-1","page":"Constraints","title":"Technical lifetime of a connection","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Investments-in-storages-1","page":"Constraints","title":"Investments in storages","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Note: can we actually invest in nodes that are not storages? (e.g. new location)","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_storages_invested_available-1","page":"Constraints","title":"Available invested storages","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_storages_invested_transition-1","page":"Constraints","title":"Storage capacity transfer? ","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_storage_lifetime-1","page":"Constraints","title":"Economic lifetime of a storage","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Technical-lifetime-of-a-storage-1","page":"Constraints","title":"Technical lifetime of a storage","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Capacity-transfer-1","page":"Constraints","title":"Capacity transfer","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Early-retirement-of-capacity-1","page":"Constraints","title":"Early retirement of capacity","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Benders-decomposition-1","page":"Constraints","title":"Benders decomposition","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#","page":"Constraints","title":"Constraints","text":"Can we add some detail on the mathematics here","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_mp_any_invested_cuts-1","page":"Constraints","title":"Benders cuts","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#User-constraints-1","page":"Constraints","title":"User constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_unit_constraint-1","page":"Constraints","title":"Unit constraint","text":"","category":"section"},{"location":"concept_reference/min_startup_ramp/#","page":"-","title":"-","text":"The definition of the min_startup_ramp parameter will trigger the creation of the TODO. It sets a lower bound on the unit_flow variable the timestep right after a startup.","category":"page"},{"location":"concept_reference/min_startup_ramp/#","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/Object Classes/#Object-Classes-1","page":"Object Classes","title":"Object Classes","text":"","category":"section"},{"location":"concept_reference/Object Classes/#commodity-1","page":"Object Classes","title":"commodity","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A good or product that can be consumed, produced, traded. E.g., electricity, oil, gas, water...","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: commodity_lodf_tolerance, commodity_physics, commodity_ptdf_threshold and is_active","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: node__commodity and unit__commodity","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Commodities correspond to the type of energy traded. When associated with a node through the node__commodity relationship, a specific form of energy, i.e. commodity, can be associated with a specific location. Furthermore, by linking commodities with units, it is possible to track the flows of a certain commodity and impose limitations on the use of a certain commodity (See also max_cum_in_unit_flow_bound). For the representation of specific commodity physics, related to e.g. the representation of the electric network, designated parameters can be defined to enforce commodity specific behaviour. (See also commodity_physics)","category":"page"},{"location":"concept_reference/Object Classes/#connection-1","page":"Object Classes","title":"connection","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A transfer of commodities between nodes. E.g. electricity line, gas pipeline...","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: candidate_connections, connection_availability_factor, connection_binary_gas_flow, connection_contingency, connection_flow_cost, connection_investment_cost, connection_investment_lifetime, connection_investment_variable_type, connection_monitored, connection_reactance_base, connection_reactance, connection_resistance, connection_type, fix_connections_invested_available, fix_connections_invested and is_active","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: connection__from_node__unit_constraint, connection__from_node, connection__investment_stochastic_structure, connection__investment_temporal_block, connection__node__node, connection__to_node__unit_constraint and connection__to_node","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A connection represents a transfer of energy of one commodity over space. For example, an electricity transmission line, a gas pipe, a river branch, can be modelled using a connection.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A connection always takes energy from one or more nodes, and releases that same energy to one or more (possibly the same) nodes. The former are specificed through the connection__from_node relationship, and the latter through connection__to_node. Every connection inherits the temporal and stochastic structures from the associated nodes. The model will generate connection_flow variables for every combination of connection, node, direction (from node or to node), time slice, and stochastic scenario, according to the above relationships.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"The operation of the connection is specified through a number of parameter values. For example, the capacity of the connection, as the maximum amount of energy that can enter or leave it, is given by connection_capacity. The conversion ratio of input to output can be specified using any of fix_ratio_out_in_connection_flow, max_ratio_out_in_connection_flow, and min_ratio_out_in_connection_flow. The delay on a connection, as the time it takes for the energy to go from one end to the other, is given by connection_flow_delay.","category":"page"},{"location":"concept_reference/Object Classes/#model-1","page":"Object Classes","title":"model","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"An instance of SpineOpt, that specifies general parameters such as the temporal horizon.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: big_m, duration_unit, is_active, max_gap, max_iterations, model_end, model_start, model_type, roll_forward, write_lodf_file, write_mps_file and write_ptdf_file","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: model__default_investment_stochastic_structure, model__default_investment_temporal_block, model__default_stochastic_structure, model__default_temporal_block, model__report, model__stochastic_structure and model__temporal_block","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"The model object holds general information about the optimization problem at hand. Firstly, the modelling horizon is specified on the model object, i.e. the scope of the optimization model, and if applicable the duration of the rolling window (see also model_start, model_end and roll_forward). Secondly, the model works as an overarching assembler - only through linking temporal_blocks and stochastic_structures to a model object via relationships, they become part of the optimization problem, and respectively linked nodes, connections and units. If desired the user can also specify defaults for temporals and stochastic via the designated default relationships (see e.g., model__default_temporal_block. In this case, the default temporal is populated for missing node__temporal_block relationships.  Lastly, the model object contains information about the algorithm used for solving the problem (see model_type).","category":"page"},{"location":"concept_reference/Object Classes/#node-1","page":"Object Classes","title":"node","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A universal aggregator of commodify flows over units and connections, with storage capabilities.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: balance_type, candidate_storages, demand, downward_reserve, fix_node_pressure, fix_node_state, fix_node_voltage_angle, fix_storages_invested_available, fix_storages_invested, frac_state_loss, fractional_demand, has_pressure, has_state, has_voltage_angle, is_active, is_reserve_node, max_node_pressure, max_voltage_angle, min_node_pressure, min_voltage_angle, minimum_reserve_activation_time, nodal_balance_sense, node_opf_type, node_slack_penalty, node_state_cap, node_state_min, state_coeff, storage_investment_cost, storage_investment_lifetime, storage_investment_variable_type, tax_in_unit_flow, tax_net_unit_flow, tax_out_unit_flow and upward_reserve","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: connection__from_node__unit_constraint, connection__from_node, connection__node__node, connection__to_node__unit_constraint, connection__to_node, node__commodity, node__investment_stochastic_structure, node__investment_temporal_block, node__node, node__stochastic_structure, node__temporal_block, node__unit_constraint, unit__from_node__unit_constraint, unit__from_node, unit__node__node, unit__to_node__unit_constraint and unit__to_node","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"The node is perhaps the most important object class out of the Systemic object classes, as it is what connects the rest together via the Systemic relationship classes. Essentially, nodes act as points in the modelled commodity network where commodity balance is enforced via the node balance and node injection constraints, tying together the inputs and outputs from units and connections, as well as any external demand. Furthermore, nodes play a crucial role for defining the temporal and stochastic structures of the model via the node__temporal_block and node__stochastic_structure relationships. For more details about the Temporal Framework and the Stochastic Framework, please refer to the dedicated sections.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"As nodes act the points where [commodity]@(ref) balance is enforced, this also makes them a natural fit for implementing storage. The has_state parameter controls whether a node has a node_state variable, which essentially represents the commodity content of the node, The state_coeff parameter tells how the node_state variable relates to all the commodity flows. Storage losses are handled via the frac_state_loss parameter, and potential diffusion of commodity content to other nodes via the diff_coeff parameter for the node__node relationship.","category":"page"},{"location":"concept_reference/Object Classes/#output-1","page":"Object Classes","title":"output","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A variable name from SpineOpt that can be included in a report.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: is_active","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: report__output","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"An output is essentially a handle for a SpineOpt variable to be included in a report and written into an output database. Typically, e.g. the unit_flow variables are desired as output from most models, so creating an output object called unit_flow allows one to designate it as something to be written in the desired report. Note that unless appropriate model__report and report__output relationships are defined, SpineOpt doesn't write any output!","category":"page"},{"location":"concept_reference/Object Classes/#report-1","page":"Object Classes","title":"report","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A results report from a particular SpineOpt run, including the value of specific variables.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: is_active and output_db_url","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: model__report and report__output","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A report is essentially a group of outputs from a model, that gets written into the output database as a result of running SpineOpt. Note that unless appropriate model__report and report__output relationships are defined, SpineOpt doesn't write any output!","category":"page"},{"location":"concept_reference/Object Classes/#stochastic_scenario-1","page":"Object Classes","title":"stochastic_scenario","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A scenario for stochastic optimisation in SpineOpt.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: is_active","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: parent_stochastic_scenario__child_stochastic_scenario and stochastic_structure__stochastic_scenario","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Essentially, a stochastic_scenario is a label for an alternative period of time, describing one possibility of what might come to pass. They are the basic building blocks of the scenario-based Stochastic Framework in SpineOpt.jl, but aren't really meaningful on their own. Only when combined into a stochastic_structure using the stochastic_structure__stochastic_scenario and parent_stochastic_scenario__child_stochastic_scenario relationships, along with Parameters like the weight_relative_to_parents and stochastic_scenario_end, they become meaningful.","category":"page"},{"location":"concept_reference/Object Classes/#stochastic_structure-1","page":"Object Classes","title":"stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A group of stochastic scenarios that represent a structure.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: is_active","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: connection__investment_stochastic_structure, model__default_investment_stochastic_structure, model__default_stochastic_structure, model__stochastic_structure, node__investment_stochastic_structure, node__stochastic_structure, stochastic_structure__stochastic_scenario, unit__investment_stochastic_structure and units_on__stochastic_structure","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"The stochastic_structure is the key component of the scenario-based Stochastic Framework in SpineOpt.jl, and essentially represents a group of stochastic_scenarios with set Parameters. The stochastic_structure__stochastic_scenario relationship defines which stochastic_scenarios are included in which stochastic_structures, and the weight_relative_to_parents and stochastic_scenario_end Parameters define the exact shape and impact of the stochastic_structure, along with the parent_stochastic_scenario__child_stochastic_scenario relationship.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"The main reason as to why stochastic_structures are so important is, that they act as handles connecting the Stochastic Framework to the modelled system. This is handled using the Structural relationship classes e.g. node__stochastic_structure, which define the stochastic_structure applied to each object describing the modelled system. Connecting each system object to the appropriate stochastic_structure individually can be a bit bothersome at times, so there are also a number of convenience Meta relationship classes like the model__default_stochastic_structure, which allow setting model-wide defaults to be used whenever specific definitions are missing.","category":"page"},{"location":"concept_reference/Object Classes/#temporal_block-1","page":"Object Classes","title":"temporal_block","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A length of time with a particular resolution.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: block_end, block_start, is_active, representative_periods_mapping, resolution and weight","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: connection__investment_temporal_block, model__default_investment_temporal_block, model__default_temporal_block, model__temporal_block, node__investment_temporal_block, node__temporal_block, unit__investment_temporal_block and units_on__temporal_block","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A temporal block defines the temporal properties of the optimization that is to be solved in the current window. It is the key building block of the Temporal Framework. Most importantly, it holds the necessary information about the resolution and horizon of the optimization. A single model can have multiple temporal blocks, which is one of the main sources of temporal flexibility in Spine: by linking different parts of the model to different temporal blocks, a single model can contain aspects that are solved with different temporal resolutions or time horizons.","category":"page"},{"location":"concept_reference/Object Classes/#unit-1","page":"Object Classes","title":"unit","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A conversion of one/many comodities between nodes.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: candidate_units, curtailment_cost, fix_units_invested_available, fix_units_invested, fix_units_on, fom_cost, is_active, min_down_time, min_up_time, number_of_units, online_variable_type, shut_down_cost, start_up_cost, unit_availability_factor, unit_investment_cost, unit_investment_lifetime and unit_investment_variable_type","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: unit__commodity, unit__from_node__unit_constraint, unit__from_node, unit__investment_stochastic_structure, unit__investment_temporal_block, unit__node__node, unit__to_node__unit_constraint, unit__to_node, unit__unit_constraint, units_on__stochastic_structure and units_on__temporal_block","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A unit represents an energy conversion process, where energy of one commodity can be converted into energy of another commodity. For example, a gas turbine, a power plant, or even a load, can be modelled using a unit.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A unit always takes energy from one or more nodes, and releases energy to one or more (possibly the same) nodes. The former are specificed through the unit__from_node relationship, and the latter through unit__to_node. Every unit has a temporal and stochastic structures given by the units_on__temporal_block and [units_on__stochastic_structure] relationships. The model will generate unit_flow variables for every combination of unit, node, direction (from node or to node), time slice, and stochastic scenario, according to the above relationships.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"The operation of the unit is specified through a number of parameter values. For example, the capacity of the unit, as the maximum amount of energy that can enter or leave it, is given by unit_capacity. The conversion ratio of input to output can be specified using any of fix_ratio_out_in_unit_flow, max_ratio_out_in_unit_flow, and min_ratio_out_in_unit_flow. The variable operating cost is given by vom_cost.","category":"page"},{"location":"concept_reference/Object Classes/#unit_constraint-1","page":"Object Classes","title":"unit_constraint","text":"","category":"section"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"A generic data-driven custom constraint.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Parameters: constraint_sense, is_active and right_hand_side","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: connection__from_node__unit_constraint, connection__to_node__unit_constraint, node__unit_constraint, unit__from_node__unit_constraint, unit__to_node__unit_constraint and unit__unit_constraint","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"The unit_constraint is a generic data-driven custom constraint, which allows for defining constraints involving multiple units, nodes, or connections. The constraint_sense parameter changes the sense of the unit_constraint, while the right_hand_side parameter allows for defining the constant terms of the constraint.","category":"page"},{"location":"concept_reference/Object Classes/#","page":"Object Classes","title":"Object Classes","text":"Coefficients for the different variables appearing in the unit_constraint are defined using relationships, like e.g. unit__from_node__unit_constraint and connection__to_node__unit_constraint for unit_flow and connection_flow variables, or unit__unit_constraint and node__unit_constraint for units_on and node_state variables.","category":"page"},{"location":"concept_reference/max_cum_in_unit_flow_bound/#","page":"-","title":"-","text":"To impose a limit on the cumulative in flows to a unit for the entire modelling horizon, e.g. to enforce limits on emissions, the max_cum_in_unit_flow_bound parameter can be used. Defining this parameter triggers the generation of the constraint_max_cum_in_unit_flow_bound.","category":"page"},{"location":"concept_reference/max_cum_in_unit_flow_bound/#","page":"-","title":"-","text":"Assuming for instance that the total intake of a unit u_A should not exceed 10MWh for the entire modelling horizon, then the max_cum_in_unit_flow_bound would need to take the value 10. (Assuming here that the unit_flow variable is in MW, and the model duration_unit is hours)","category":"page"},{"location":"concept_reference/fixed_pressure_constant_0/#","page":"-","title":"-","text":"For the MILP representation of pressure driven gas transfer, we use an outer approximation approach as described by Schwele et al.. The Weymouth equation is approximated around fixed pressure points, as described by the constraint on fixed node pressure points, constraining the average flow in each direction dependent on the adjacent node pressures. The second fixed pressure constant, which will be multiplied with the pressure of the destination node, is represented by an Array value of the fixed_pressure_constant_0. The first pressure constant corresponds to the related parameter fixed_pressure_constant_1. Note that the fixed_pressure_constant_0 parameter should be defined on a connection__node__node relationship, for which the first node corresponds to the origin node, while the second node corresponds to the destination node. For a typical gas pipeline, the will be a fixed_pressure_constant_1  for both directions of flow.","category":"page"},{"location":"concept_reference/min_ratio_in_in_unit_flow/#","page":"-","title":"-","text":"The definition of the min_ratio_in_in_unit_flow parameter triggers the generation of the constraint_min_ratio_in_in_unit_flow and sets a lower bound for the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply. To enforce e.g. for a unit u a minimum share of 0.2 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the min_ratio_in_in_unit_flow parameter would be set to 0.2 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/res_start_up_cost/#","page":"-","title":"-","text":"By defining the res_start_up_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function whenever a non-spinning reserve unit starts up over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Temporal-Framework-1","page":"Temporal Framework","title":"Temporal Framework","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Spine Model aims to provide a high degree of flexibility in the temporal dimension across different components of the created model. This means that the user has some freedom to choose how the temporal aspects of different components of the model are defined. This freedom increases the variety of problems that can be tackled in Spine: from very coarse, long term models, to very detailed models with a more limited horizon, or a mix of both. The choice of the user on how this flexibility is used will lead to the temporal structure of the model.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"The main components of flexibility consist of the following parts:","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"The horizon that is modeled: end and start time\nTemporal resolution\nPossibility of a rolling optimization window\nSupport for commonly used methods such as representative days","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Part of the temporal flexibility in Spine is due to the fact that these options mentioned above can be taken differently across different components of the model, which can be very useful when different markets are coupled in a single model. The resolution and horizon of the gas market can for example be taken differently than that of the electricity market. This documentation aims to give the reader insight in how these aspects are defined, and which objects are used for this.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"We start by introducing the relevant objects with their parameters, and the relevant relationship classes for the temporal structure. Afterwards, we will discuss how this setting creates flexibility and will present some of the practical approaches to create a variety of temporal structures.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Objects,-relationships,-and-their-parameters-1","page":"Temporal Framework","title":"Objects, relationships, and their parameters","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"In this section, the objects and relationships will be discussed that form the temporal structure together.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Objects-relevant-for-the-temporal-framework-1","page":"Temporal Framework","title":"Objects relevant for the temporal framework","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"For the objects, the relevant parameters will also be introduced, along with the type of values that are allowed, following the format below:  ","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"'parameter_name' : \"Allowed value type\"","category":"page"},{"location":"advanced_concepts/temporal_framework/#[model](@ref)-object-1","page":"Temporal Framework","title":"model object","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Each model object holds general information about the model at hand. Here we only discuss the time related parameters:","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"model_start and model_end : \"Date time value\"","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"These two parameters define the model horizon. A Datetime value is to be taken for both parameters, in which case they directly mark respectively the beginning and end of the modeled time horizon.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"duration_unit (optional): \"hour or minute\"","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"This parameters gives the unit of duration that is used in the model calculations. The default value for this parameter is 'minute'.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"roll_forward (optional): \"duration value\"","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"This parameter defines how much the optimization window rolls forward in a rolling horizon optimization and should be expressed as a duration. In the practical approaches presented below, the rolling window optimization will be explained in more detail.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[temporal_block](@ref)-object-1","page":"Temporal Framework","title":"temporal_block  object","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"A temporal block defines the properties of the optimization that is to be solved in the current window. Most importantly, it holds the necessary information about the resolution and horizon of the optimization.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"resolution (optional): \"duration value\" or \"array of duration values\"","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"This parameter specifies the resolution of the temporal block, or in other words: the length of the timesteps used in the optimization run.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"block_start (optional): \"duration value\" or \"Date time value\"","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Indicates the start of this temporal block.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"block_end(optional): \"duration value\" or \"Date time value\"","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Indicates the end of this temporal block.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Relationships-relevant-for-the-temporal-framework-1","page":"Temporal Framework","title":"Relationships relevant for the temporal framework","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#[model__temporal_block](@ref)-relationship-1","page":"Temporal Framework","title":"model__temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"In this relationship, a model instance is linked to a temporal block. If this relationship doesn't exist - the temporal block is disregarded from this optimization model.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[model__default_temporal_block](@ref)-relationship-1","page":"Temporal Framework","title":"model__default_temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Defines the default temporal block used for model objects, which will be replaced when a specific relationship is defined for a model in model__temporal_block.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[node__temporal_block](@ref)-relationship-1","page":"Temporal Framework","title":"node__temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"This relationship will link a node to a temporal block.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[units_on__temporal_block](@ref)-relationship-1","page":"Temporal Framework","title":"units_on__temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"This relationship links the units_on variable of a unit to a temporal block and will therefore govern the time-resolution of the unit's online/offline status.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[unit__investment_temporal_block](@ref)-relationship-1","page":"Temporal Framework","title":"unit__investment_temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"This relationship sets the temporal dimensions for investment decisions of a certain unit. The separation between this relationship and the units_on__temporal_block, allows the user for example to give a much finer resolution to a unit's on- or offline status than to it's investment decisions.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[model__default_investment_temporal_block](@ref)-relationship-1","page":"Temporal Framework","title":"model__default_investment_temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Defines the default temporal block used for investment decisions, which will be replaced when a specific relationship is defined for a unit in unit__investment_temporal_block.","category":"page"},{"location":"advanced_concepts/temporal_framework/#General-principle-of-the-temporal-framework-1","page":"Temporal Framework","title":"General principle of the temporal framework","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"The general principle of the Spine modeling temporal structure is that different temporal blocks can be defined and linked to different objects in a model. This leads to great flexibility in the temporal structure of the model as a whole. To illustrate this, we will discuss some of the possibilities that arise in this framework.","category":"page"},{"location":"advanced_concepts/temporal_framework/#One-single-temporal_block-1","page":"Temporal Framework","title":"One single temporal_block","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#Single-solve-with-single-block-1","page":"Temporal Framework","title":"Single solve with single block","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"The simplest case is a single solve of the entire time horizon (so roll_forward not defined) with a fixed resolution. In this case, only one temporal block has to be defined with a fixed resolution. Each node has to be linked to this temporal_block.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Alternatively, a variable resolution can be defined by choosing an array of durations for the resolution parameter. The sum of the durations in the array then have to match the length of the temporal block. The example below illustrates an optimization that spans one day for which the resolution is hourly in the beginning and then gradually decreases to a 6h resolution at the end.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"temporal_block_1\nblock_start: 0h\nblock_start: 1D\nresolution: [1h 1h 1h 1h 2h 2h 2h 4h 4h 6h]","category":"page"},{"location":"advanced_concepts/temporal_framework/#Rolling-window-optimization-with-single-block-1","page":"Temporal Framework","title":"Rolling window optimization with single block","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"A model with a single temporal_block can also be optimized in a rolling horizon framework. In this case, the roll_forward parameter has to be defined in the model object. The roll_forward parameter will then determine how much the optimization moves forward with every step, while the size of the temporal block will determine how large a time frame is optimized in each step. To see this more clearly, let's take a look at an example.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Suppose we want to model a horizon of one week, with a rolling window size of one day. The roll_forward parameter will then be a duration value of 1d. If we take the temporal_block parameters block_start and block_end to be the duration values 0h and 1d respectively, the model will optimize each day of the week separately. However, we could also take the block_end parameter to be 2d. Now the model will start by optimizing day 1 and day 2 together, after which it keeps only the values obtained for the first day, and moves forward to optimize the second and third day together.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Again, a variable resolution can be implemented for the rolling window optimization. The sum of the durations must in this case match the size of the optimized window.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Advanced-usage:-multiple-temporal_block-objects-1","page":"Temporal Framework","title":"Advanced usage: multiple temporal_block objects","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#Single-solve-with-multiple-blocks-1","page":"Temporal Framework","title":"Single solve with multiple blocks","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#Disconnected-time-periods-1","page":"Temporal Framework","title":"Disconnected time periods","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Multiple temporal blocks can be used to optimize disconnected periods. Let's take a look at an example in which two temporal blocks are defined.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"temporal_block_1\nblock_start: 0h\nblock_end: 4h\ntemporal_block_2\nblock_start: 12h\nblock_end: 16h","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"This example will lead to an optimization of the first four hours of the model horizon, and also of hour 12 to 16. By defining exactly the same relationships for the two temporal blocks, an optimization of disconnected periods is achieved for exactly the same model components. This leads to the possibility of implementing the widely used representative days method. If desired, it is possible to choose a different temporal resolution for the different temporal_blocks.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Different-regions/commodities-in-different-resolutions-1","page":"Temporal Framework","title":"Different regions/commodities in different resolutions","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Multiple temporal blocks can also be used to model different regions or different commodities with a different resolution. This is especially useful when there is a certain region or commodity of interest, while other elements are connected to this but require less detail. For this kind of usage, the relationships that are defined for the temporal blocks will be different, as shown in the example below.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"temporal_blocks\ntemporal_block_1\nresolution: 1h\ntemporal_block_2\nresolution: 2h\nnodes\nnode_1\nnode_2\nnode_temporal_block relationships\nnode_1_temporal_block_1\nnode_2_temporal_block_2","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Similarly, the on- and offline status of a unit can be modeled with a lower resolution than the actual output of that unit, by defining the units_on_temporal_block relationship with a different temporal block than the one used for the node_temporal_block relationship (of the node to which the unit is connected).","category":"page"},{"location":"advanced_concepts/temporal_framework/#Rolling-horizon-with-multiple-blocks-1","page":"Temporal Framework","title":"Rolling horizon with multiple blocks","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#Rolling-horizon-with-different-window-sizes-1","page":"Temporal Framework","title":"Rolling horizon with different window sizes","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Similar to what has been discussed above in Different regions/commodities in different resolutions, different commodities or regions can be modeled with a different resolution in the rolling horizon setting. The way to do it is completely analogous. Furthermore, when using the rolling horizon framework, a different window size can be chosen for the different modeled components, by simply using a different block_end parameter. #TODO: What happens to coupling constraints between different regions?","category":"page"},{"location":"advanced_concepts/temporal_framework/#Rolling-horizon-where-the-resolution-is-dependent-on-the-absolute-time-1","page":"Temporal Framework","title":"Rolling horizon where the resolution is dependent on the absolute time","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"TODO : How can this be done, since there is no parameter that indicates whether a temporal block is static or rolling","category":"page"},{"location":"advanced_concepts/temporal_framework/#Putting-it-all-together:-rolling-horizon-with-variable-resolution-that-differs-for-different-model-components-1","page":"Temporal Framework","title":"Putting it all together: rolling horizon with variable resolution that differs for different model components","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"Below is an example of an advanced use case in which a rolling horizon optimization is used, and different model components are optimized with a different resolution. By choosing the relevant parameters in the following way:","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"model\nroll_forward: 4h\ntemporal_blocks\ntemporal_block_A\nresolution: [1h 1h 2h 2h 2h 3h 3h]\nblock_end: 14h\ntemporal_block_B\nresolution: [2h 2h 4h 6h]\nblock_end: 14h\nnodes\nnode_1\nnode_2\nnode_temporal_block relationships\nnode_1_temporal_block_1\nnode_2_temporal_block_2","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"The two model components that are considered have a different resolution, and their own resolution is also varying within the optimization window. Note that in this case the two optimization windows have the same size, but this is not strictly necessary. The image below visualizes the first two window optimizations of this model.","category":"page"},{"location":"advanced_concepts/temporal_framework/#","page":"Temporal Framework","title":"Temporal Framework","text":"(Image: temporal structure)","category":"page"},{"location":"concept_reference/fix_binary_gas_connection_flow/#","page":"-","title":"-","text":"The binary flow of a gas pipelines for pressure driven gas transfer is enables through the binary variable binary_gas_connection_flow and the big_m constant. To fix this binary variable, i.e. pre-define the direction of gas through the pipelines, the fix_binary_gas_connection_flow parameter can be used.","category":"page"},{"location":"concept_reference/connection_capacity/#","page":"-","title":"-","text":"Defines the upper bound on the corresponding connection_flow variable. If the connection is a candidate connection, the effective connection_flow upper bound is the product of the investment variable, connections_invested_available and connection_capacity. If ptdf based dc load flow is enabled, connection_capacity represents the normal rating of a connection (line) while connectionemergencycapacity represents the maximum post contingency flow.","category":"page"},{"location":"concept_reference/fix_units_invested/#","page":"-","title":"-","text":"Used primarily to fix the value of the units_invested variable which represents the point-in-time unit investment decision variable and how many candidate units are invested-in in a particular timeslice. ","category":"page"},{"location":"concept_reference/fix_units_invested/#","page":"-","title":"-","text":"See also investment_optimization, candidate_units and unit_investment_variable_type","category":"page"},{"location":"concept_reference/candidate_connections/#","page":"-","title":"-","text":"The candidate_connections parameter denotes the possibility of investing on a certain connection.","category":"page"},{"location":"concept_reference/candidate_connections/#","page":"-","title":"-","text":"The default value of nothing means that the connection can't be invested in, because it's already in operation.  An integer value represents the maximum investment possible at any point in time, as a factor of the connection_capacity.","category":"page"},{"location":"concept_reference/candidate_connections/#","page":"-","title":"-","text":"In other words, candidate_connections is the upper bound of the connections_invested_available variable.","category":"page"},{"location":"concept_reference/connection__to_node__unit_constraint/#","page":"-","title":"-","text":"connection__to_node__unit_constraint is a three-dimensional relationship between a connection, a node and a unit_constraint. The relationship specifies that the connection_flow variable from the specified connection to the specified node is involved in the specified unit_constraint. Parameters on this relationship generally apply to this specific connection_flow variable. For example the parameter connectionflowcoefficient defined on connection__to_node__unit_constraint represents the coefficient on the specific connection_flow variable in the specified unit_constraint","category":"page"},{"location":"concept_reference/is_reserve_node/#","page":"-","title":"-","text":"By defining the parameter is_reserve_node to true, a node is treated as a reserve node in the model. Units that are linked through a unit__to_node relationship will be able to provide balancing services to the reserve node, but within their technical feasibility. The mathematical formulation holds a chapter on Ramping and reserve constraints and the general concept of setting up a model with reserves is described in Ramping and Reserves.","category":"page"},{"location":"mathematical_formulation/objective_function/#Objective-function-1","page":"Objective","title":"Objective function","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"The objective function of SpineOpt expresses the minimization of the total system costs associated with maintaining and operating the considered energy system.","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n min obj = v_unit_investment_costs + v_connection_investment_costs + v_storage_investment_costs\r\n + v_fixed_om_costs + v_variable_om_costs + v_fuel_costs + v_operation_costs +  v_start_up_costs \r\n + v_shut_down_costs + v_ramp_costs + v_res_proc_costs + v_res_start_up_costs\r\n + v_renewable_curtailment_costs + v_connection_flow_costs +  v_taxes +\r\nv_objective_penalties\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"Note that each cost term is reflected here as a separate variable that can be expressed mathematically by the equations below. All cost terms are weighted by the associated scenario and temporal block weights. To enhance readability and avoid writing a product of weights in every cost term, all weights are combined in a single weight parameter p_{weight}(). As such, the indices associated with each weight parameter indicate which weights are included.","category":"page"},{"location":"mathematical_formulation/objective_function/#Unit-investment-costs-1","page":"Objective","title":"Unit investment costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"To take into account unit investments in the objective function, the parameter unit_investment_cost can be defined. For all tuples of (unit, scenario, timestep) in the set units_invested_available_indices for which this parameter is defined, an investment cost term is added to the objective function if a unit is invested in during the current optimization window. The total unit investment costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_unit_investment_costs \r\n = sum_substack(ust) in units_invested_available_indices\r\n      u in ind(p_unit_investment_cost)\r\n    v_units_invested(u s t) cdot p_unit_investment_cost(ust) cdot p_weight(ust)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Connection-investment-costs-1","page":"Objective","title":"Connection investment costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"To take into account connection investments in the objective function, the parameter connection_investment_cost can be defined. For all tuples of (connection, scenario, timestep) in the set connections_invested_available_indices for which this parameter is defined, an investment cost term is added to the objective function if a connection is invested in during the current optimization window. The total connection investment costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_connection_investment_costs \r\n = sum_substack(connst) in connections_invested_available_indices  conn in ind(p_connection_investment_cost)\r\n v_connections_invested(conn s t) cdot p_connection_investment_cost(connst) cdot p_weight(connst) \r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Storage-investment-costs-1","page":"Objective","title":"Storage investment costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"To take into account connection investments in the objective function, the parameter storage_investment_cost can be defined. For all tuples of (node, scenario, timestep) in the set storages_invested_available_indices for which this parameter is defined, an investment cost term is added to the objective function if a node storage is invested in during the current optimization window. The total storage investment costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_storage_investment_costs \r\n = sum_substack(nst) in storages_invested_available_indices n in ind(p_storage_investment_cost)\r\n v_storages_invested(n s t) cdot p_storage_investment_cost(nst) cdot p_weight(nst) \r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Fixed-O-and-M-costs-1","page":"Objective","title":"Fixed O&M costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"Fixed operation and maintenance costs associated with a specific unit can be accounted for by defining the parameters fom_cost and unit_capacity. For all tuples of (unit, {node,node_group}, direction) for which these parameters are defined, and for which tuples (unit, scenario, timestep) exist in the set units_on_indices, a fixed O&M cost term is added to the objective function. Note that, as the units_on_indices are used to retrieve the relevant time slices, the unit of the fom_cost parameter should per given per resolution of the units_on. The total fixed O&M costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_fixed_om_costs \r\n = sum_substack(und) in ind(p_unit_capacity) u in ind(p_fom_cost)\r\nsum_substack(ust)  in  units_on_indices\r\n p_unit_capacity(undst) cdot p_number_of_units(ust)cdot\r\n p_fom_cost(ust)cdot p_weight(t) cdot\r\n p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Variable-O-and-M-costs-1","page":"Objective","title":"Variable O&M costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"Variable operation and maintenance costs associated with a specific unit can be accounted for by defining the parameter (vom_cost). For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the set unit_flow_indices for which this parameter is defined, a variable O&M cost term is added to the objective function. As the parameter vom_cost is a dynamic parameter, the cost term is multiplied with the duration of each timestep. The total variable O&M costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_variable_om_costs \r\n = sum_substack(undst) in unit_flow_indices (und) in ind(p_vom_cost)\r\n v_unit_flow(u n d s t) cdot  p_vom_cost(undst) cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Fuel-costs-1","page":"Objective","title":"Fuel costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"Fuel costs associated with a specific unit can be accounted for by defining the parameter fuel_cost. For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the set unit_flow_indices for which this parameter is defined, a fuel cost term is added to the objective function. As the parameter fuel_cost is a dynamic parameter, the cost term is multiplied with the duration of each timestep. The total fuel costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_fuel_costs \r\n = sum_substack(undst) in unit_flow_indices (und) in ind(p_fuel_cost)\r\n v_unit_flow(u n d s t) cdot  p_fuel_cost(undst) cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Operating-costs-1","page":"Objective","title":"Operating costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"To account for other operating costs associated with a specific unit, the operating_cost parameter can be defined. For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the set unit_flow_indices for which this parameter is defined, an operating cost term is added to the objective function. As the parameter operating_cost is a dynamic parameter, the cost term is multiplied with the duration of each timestep. The total operating costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_operating_costs \r\n = sum_substack(undst) in unit_flow_indices  (und) in ind(p_operating_cost)\r\n v_unit_flow(u n d s t) cdot  p_operating_cost(undst) cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Connection-flow-costs-1","page":"Objective","title":"Connection flow costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"To account for operational costs associated with flows over a specific connection, the connection_flow_cost parameter can be defined. For all tuples of (conn, {node,node_group}, direction, scenario, timestep) in the set connection_flow_indices for which this parameter is defined, a connection flow cost term is added to the objective function. The total connection flow costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_connection_flow_costs \r\n = sum_substack(connndst) in connection_flow_indices  conn in ind(p_connection_flow_cost)\r\nv_connection_flow (conn n d s t) cdot  p_connection_flow_cost(connst) cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Start-up-costs-1","page":"Objective","title":"Start up costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"Start up costs associated with a specific unit can be included by defining the start_up_cost parameter. For all tuples of (unit, scenario, timestep) in the set units_on_indices for which this parameter is defined, a start up cost term is added to the objective function. The total start up costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_start_up_costs \r\n = sum_substack(ust) in units_on_indices u in ind(p_start_up_cost)\r\n v_units_started_up(u s t) cdot p_start_up_cost(ust)cdot p_weight(ust)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Shut-down-costs-1","page":"Objective","title":"Shut down costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"Shut down costs associated with a specific unit can be included by defining the shut_down_cost parameter. For all tuples of (unit, scenario, timestep) in the set units_on_indices for which this parameter is defined, a shut down cost term is added to the objective function. The total shut down costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_shut_down_costs \r\n = sum_substack(ust) in units_on_indices u in ind(p_shut_down_cost)\r\nv_units_shut_down(ust) cdot p_start_up_cost(ust)cdot p_weight(ust)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Ramping-costs-1","page":"Objective","title":"Ramping costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"To account for the ramping costs (up and down) associated with a specific unit, the parameters ramp_up_cost and ramp_down_cost can be defined. For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the sets ramp_up_unit_flow_indices and ramp_down_unit_flow_indices for which ramp_up_cost, respectively ramp_down_cost is  defined, a ramping cost term is added to the objective function. The total ramping costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_ramp_costs \r\n = sum_substack(undst) in ramp_up_unit_flow_indices  (und) in ind(p_ramp_up_cost)\r\nv_ramp_up_unit_flow(u n d s t)cdot p_ramp_up_cost(undst)cdot p_weight(nst)cdot p_duration(t)\r\n  + sum_substack(undst) in ramp_down_unit_flow_indices  (und) in ind(p_ramp_down_cost)\r\n  v_ramp_down_unit_flow(u n d s t) cdot p_ramp_down_cost(undst)cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Reserve-procurement-costs-1","page":"Objective","title":"Reserve procurement costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"The procurement costs for reserves provided by a specific unit can be accounted for by defining the reserve_procurement_cost parameter. For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the set unit_flow_indices for which this parameter is defined, a reserve procurement cost term is added to the objective function. The total reserve procurement costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_res_proc_costs \r\n = sum_substack(undst) in unit_flow_indices  (und) in ind(p_reserve_procurement_cost)\r\nv_unit_flow(u n d s t) cdot p_reserve_procurement_cost(undst) cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Reserve-start-up-costs-1","page":"Objective","title":"Reserve start up costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"The start up costs for reserves provided by a specific unit can be accounted for by defining the res_start_up_cost parameter. For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the set nonspin_units_started_up_indices for which this parameter is defined, a reserve start up cost term is added to the objective function. The total reserve start up costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_res_start_up_costs \r\n = sum_substack(unst) in nonspin_units_started_up_indices  (und) in ind(p_res_start_up_cost) \r\nv_nonspin_units_started_up(u n s t) cdot p_res_start_up_cost(undst)cdot p_weight(ust)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Renewable-curtailment-costs-1","page":"Objective","title":"Renewable curtailment costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"The curtailment costs of renewable units can be accounted for by defining the parameters curtailment_cost and unit_capacity. For all tuples of (unit,  {node,node_group}, direction) for which these parameters are defined, and for which tuples (unit, scenario, timestep_long) exist in the set units_on_indices, and for which tuples (unit, {node,node_group}, direction, scenario, timestep_short) exist in the set unit_flow_indices, a renewable curtailment cost term is added to the objective function. The total renewable curtailment costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_renewable_curtailment_costs \r\n = sum_substack(und) in ind(p_unit_capacity)  u in ind(p_curtailment_cost)\r\nsum_substack(ust_long) in units_on_indices\r\nsum_substack(unst_short) in unit_flow_indices\r\n\r\n\r\n  p_curtailment_cost(ust_short)cdotleft  v_units_available(u s t_long)cdot p_unit_capacity(undst_short) cdot  p_unit_conv_cap_to_flow(undst_short) - v_unit_flow(u n d s t_short)  right cdot p_weight(nst_short) cdot p_duration(t_short)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Taxes-1","page":"Objective","title":"Taxes","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"To account for taxes on certain commodity flows, the tax unit flow parameters (i.e., tax_net_unit_flow, tax_out_unit_flow and tax_in_unit_flow) can be defined. For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the set unit_flow_indices for which these parameters are defined, a tax term is added to the objective function. The total taxes can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_taxes \r\n = sum_substack(undst) in unit_flow_indices n in ind(p_tax_net_unit_flow)  d=  to_node\r\nv_unit_flow(u n d s t)cdot p_tax_net_unit_flow(nst)cdot p_weight(nst) cdot p_duration(t)\r\n - sum_substack(undst) in unit_flow_indices n in ind(p_tax_net_unit_flow)  d=  from_node\r\nv_unit_flow(u n d s t)cdot p_tax_net_unit_flow(nst)cdot p_weight(nst)cdot p_duration(t)\r\n  + sum_substack(undst) in unit_flow_indices n in ind(p_tax_out_unit_flow)  d=  from_node\r\n v_unit_flow(u n d s t)cdot p_tax_out_unit_flow(nst)cdot p_weight(nst) cdot p_duration(t)\r\n  + sum_substack(undst) in unit_flow_indices n in ind(p_tax_in_unit_flow)  d=  to_node\r\n v_unit_flow(u n d s t)cdot p_tax_in_unit_flow(nst)cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Objective-penalties-1","page":"Objective","title":"Objective penalties","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"Penalty cost terms associated with the slack variables of a specific constraint can be accounted for by defining a node_slack_penalty parameter. For all tuples of ({node,node_group}, scenario, timestep) in the set node_slack_indices for which this parameter is defined, a penalty term is added to the objective function. The total objective penalties can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"beginaligned\r\n v_objective_penalties \r\n = sum_substack(ust) in node_slack_indices\r\nleftv_node_slack_neg(n s t)-v_node_slack_pos(n s t) rightcdot p_node_slack_penalty(nst)cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#","page":"Objective","title":"Objective","text":"@JDillon, could we have an example for the objective penalties?","category":"page"},{"location":"concept_reference/node__investment_temporal_block/#","page":"-","title":"-","text":"node__investment_temporal_block is a two-dimensional relationship between a node and a temporal_block. This relationship defines the temporal resolution and scope of a node's investment decisions (currently only storage invesments). Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__defaultinvestmenttemporal_block is specified and no node__investment_temporal_block relationship is specified, the model__defaultinvestmenttemporal_block relationship will be used. Conversely if node__investment_temporal_block is specified along with model__temporal_block, this will override model__defaultinvestmenttemporal_block for the specified node.","category":"page"},{"location":"concept_reference/node__investment_temporal_block/#","page":"-","title":"-","text":"See also investment_optimization","category":"page"},{"location":"advanced_concepts/investment_optimization/#Investment-Optimization-1","page":"Investment Optimization","title":"Investment Optimization","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"SpineOpt offers numerous ways to optimise investment decisions energy system models and in particular, offers a number of methologogies for capturing increaesd detail in investment model while containing the impact on run time. The basic principles of investments will be discussed first and this will be followed by more advanced approaches.","category":"page"},{"location":"advanced_concepts/investment_optimization/#Key-concepts-for-investments-1","page":"Investment Optimization","title":"Key concepts for investments","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"Investment Decisions","category":"page"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"These are the investment decisions that SpineOpt currently supports. At a high level, these means that the activity of the entities in question is controlled by an investment decision variable. The current implementation supports investments in :","category":"page"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"unit: \nconnection \nStorage - Note: while the above investment decisions correspond to an object class (i.e.) an investment in a unit or a connection, Storages are not an object class in themselves and are rather a property of a node. As such, a storage investment controls whether a particular node has a state variable or not    ","category":"page"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"Investment Variable Types","category":"page"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"In all cases the capacity of the unit or connection or the maximum node state of a node is multuplied by the investment variable which may either be continuous, binary or integer. This is determined, for units, by setting the unit_investment_variable_type parameter accordingly. Similary, for connections and node storages where the connection_investment_variable_type and storage_investment_variable_type are specified.  ","category":"page"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"Investment Variable Bounds","category":"page"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"The parameter candidate_units specifies the upper bound of the investment variable. If the unit_investment_variable_type is set to :variable_type_integer, the investment variable can be interpreted as the number of discrete units that may be invested in. However, if unit_investment_variable_type is :variable_type_continuous and the unit_capacity is set to unity, the investment decision variable can then be intpreted as the capacity of the unit rather than the number of units with candidate_units being the maximum capacity that can be invested in. Finally, we can invest in discrete blocks of capacity by setting unit_capacity to the size of the investment capacity blocks and have unit_investment_variable_type set to :variable_type_integer with candidate_units representing the maximum number of capacity blocks that may be invested in. The key points here are:","category":"page"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"The upper bound on the relevant flow variables are determined by the product of the investment variable and the unit_capacity or connection_capacity for connections or node_state_cap for storages.\ncandidate_units sets the upper bound on the investment variable, candidate_connections for connections and candidate_storages for storages\nunit_investment_variable_type determines wheter the investment variable is integer, binary or continuous (connection_investment_variable_type for connections and storage_investment_variable_type for storages).","category":"page"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"Temporal and Stochastic Structure of Investment Decisions ","category":"page"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"SpineOpt's flexible stochastic and temporal structure extend to investments where individual investment decisions can have their own temporal and stochastic structure indepedent of other investment decisions and other model variables. A global temporal resolution for all investment decisions can be defined by specifying the relationship model__default_investment_temporal_block. If a specific temporal resolution is required for specific investment decisions, then one can specifying the following relationships:     - unit__investment_temporal_block for unit     - connection__investment_temporal_block for connection      - node__investment_temporal_block for storages Specifying any of the above relationships will override the corresponding model__default_investment_temporal_block. ","category":"page"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"Similarly, a global stochastic structure can be defined for all investment decisions by specifying the relationship model__default_investment_stochastic_structure. If a specific stochastic structure is required for specific investment decisions, then one can specifying the following relationships:     - unit__investment_stochastic_structure for unit     - connection__investment_stochastic_structure for connection      - node__investment_stochastic_structure for storages Specifying any of the above relationships will override the corresponding model__default_investment_stochastic_structure. ","category":"page"},{"location":"advanced_concepts/investment_optimization/#Model-Reference-1","page":"Investment Optimization","title":"Model Reference","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/#Variables-for-investments-1","page":"Investment Optimization","title":"Variables for investments","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"Variable Name Indices Description\nunits_invested_available unit, s, t The number of invested in units that are available at a given (s, t)\nunits_invested unit, s, t The point-in-time investment decision corresponding to the number of units invested in at (s,t)\nunits_mothballed unit, s, t \"Instantaneous\" decision variable to mothball a unit\nconnections_invested_available connection, s, t The number of invested-in connectionss that are available at a given (s, t)\nconnections_invested connection, s, t The point-in-time investment decision corresponding to the number of connectionss invested in at (s,t)\nconnections_decommissioned connection, s, t \"Instantaneous\" decision variable to decommission a connection\nstorages_invested_available node, s, t The number of invested-in storages that are available at a given (s, t)\nstorages_invested node, s, t The point-in-time investment decision corresponding to the number of storages invested in at (s,t)\nstorages_decommissioned node, s, t \"instantaneous\" decision variable to decommission a storage","category":"page"},{"location":"advanced_concepts/investment_optimization/#Relationships-for-investments-1","page":"Investment Optimization","title":"Relationships for investments","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"Relationship Name Related Object Class List Description\nmodel__default_investment_temporal_block model, temporal_block Default temporal resolution for investment decisions effective if unit__investmenttemporalblock is not specified\nmodel__default_investment_stochastic_structure model, stochastic_structure Default stochastic structure for investment decisions effective if unit__investmentstochasticstructure is not specified\nunit__investment_temporal_block unit, temporal_block Set temporal resolution of investment decisions - overrides model__defaultinvestmenttemporal_block\nunit__investment_stochastic_structure unit, stochastic_structure Set stochastic structure for investment decisions - overrides model__defaultinvestmentstochastic_structure","category":"page"},{"location":"advanced_concepts/investment_optimization/#Parameters-for-investments-1","page":"Investment Optimization","title":"Parameters for investments","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"Parameter Name Object Class List Description\ncandidate_units unit The number of additional units of this type that can be invested in\nunit_investment_cost unit The total overnight investment cost per candidate unit over the model horizon\nunit_investment_lifetime unit The investment lifetime of the unit - once invested-in, a unit must exist for at least this amount of time\nunit_investment_variable_type unit Whether the units_invested_available variable is continuous, integer or binary\nfix_units_invested unit Fix the value of units_invested\nfix_units_invested_available unit Fix the value of connections_invested_available\ncandidate_connections connection The number of additional connections of this type that can be invested in\nconnection_investment_cost connection The total overnight investment cost per candidate connection over the model horizon\nconnection_investment_lifetime connection The investment lifetime of the connection - once invested-in, a connection must exist for at least this amount of time\nconnection_investment_variable_type connection Whether the connections_invested_available variable is continuous, integer or binary\nfix_connections_invested connection Fix the value of connections_invested\nfix_connections_invested_available connection Fix the value of connection_invested_available\ncandidate_storages node The number of additional storages of this type that can be invested in at node\nstorage_investment_cost node The total overnight investment cost per candidate storage over the model horizon\nstorage_investment_lifetime node The investment lifetime of the storage - once invested-in, a storage must exist for at least this amount of time\nstorage_investment_variable_type node Whether the storages_invested_available variable is continuous, integer or binary\nfix_storages_invested node Fix the value of storages_invested\nfix_storages_invested_available node Fix the value of storages_invested_available","category":"page"},{"location":"advanced_concepts/investment_optimization/#Related-Model-Files-1","page":"Investment Optimization","title":"Related Model Files","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/#","page":"Investment Optimization","title":"Investment Optimization","text":"Filename Relative Path Description\nconstraintunitsinvested_available.jl \\constraints constrains units_invested_available to be less than candidate_units\nconstraintunitsinvested_transition.jl \\constraints defines the relationship between units_invested_available, units_invested and units_mothballed. Analagous to units_on, units_started and units_shutdown\nconstraintunitlifetime.jl \\constraints once a unit is invested-in, it must remain in existence for at least unit_investment_lifetime - analagous to min_up_time.\nconstraintunitsavailable.jl \\constraints Enforces units_available is the sum of number_of_units and units_invested_available\nconstraintconnectionsinvested_available.jl \\constraints constrains connections_invested_available to be less than candidate_connections\nconstraintconnectionsinvested_transition.jl \\constraints defines the relationship between connections_invested_available, connections_invested and connections_decommissioned. Analagous to units_on, units_started and units_shutdown\nconstraintconnectionlifetime.jl \\constraints once a connection is invested-in, it must remain in existence for at least connection_investment_lifetime - analagous to min_up_time.\nconstraintstoragesinvested_available.jl \\constraints constrains storages_invested_available to be less than candidate_storages\nconstraintstoragesinvested_transition.jl \\constraints defines the relationship between storages_invested_available, storages_invested and storages_decommissioned. Analagous to units_on, units_started and units_shutdown\nconstraintstoragelifetime.jl \\constraints once a storage is invested-in, it must remain in existence for at least storage_investment_lifetime - analagous to min_up_time.","category":"page"},{"location":"concept_reference/max_startup_ramp/#","page":"-","title":"-","text":"The definition of the max_startup_ramp parameter will trigger the creation of the Constraint on upward start up ramp_up. It sets an upper bound on the unit_flow variable the timestep right after a startup.","category":"page"},{"location":"concept_reference/max_startup_ramp/#","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/node__node/#","page":"-","title":"-","text":"The node__node relationship is used for defining direct interactions between two nodes, like diffusion of commodity content. Note that the node__node relationship is assumed to be one-directional, meaning that","category":"page"},{"location":"concept_reference/node__node/#","page":"-","title":"-","text":"node__node(node1=n1, node2=n2) != node__node(node1=n2, node2=n1).","category":"page"},{"location":"concept_reference/node__node/#","page":"-","title":"-","text":"Thus, when one wants to define symmetric relationships between two nodes, one needs to define both directions as separate relationships.","category":"page"},{"location":"concept_reference/commodity_ptdf_threshold/#","page":"-","title":"-","text":"Given a connection and a node, the power transfer distribution factor (PTDF) is the fraction of the flow injected into the node that will flow on the connection. commodity_ptdf_threshold is the minimum absolute value of the PTDF that is considered meaningful. Any value below this threshold (in absolute value) will be treated as zero.","category":"page"},{"location":"concept_reference/commodity_ptdf_threshold/#","page":"-","title":"-","text":"The PTDFs are used to model DC power flow on certain connections. To model DC power flow on a connection, set connection_monitored to true.","category":"page"},{"location":"concept_reference/commodity_ptdf_threshold/#","page":"-","title":"-","text":"In addition, define a commodity with commodity_physics set to either commodity_physics_ptdf, or commodity_physics_lodf. and associate that commodity (via node__commodity) to both connections' nodes (given by connection__to_node and connection__from_node).","category":"page"},{"location":"concept_reference/model_type_list/#","page":"-","title":"-","text":"model_type_list holds the possible values for the model parameter model_type parameter. See model_type for more details","category":"page"},{"location":"concept_reference/ramp_up_limit/#","page":"-","title":"-","text":"The definition of the ramp_up_limit parameter will trigger the creation of the Constraint on spinning upwards ramp_up. It limits the maximum increase in the unit_flow variable between two consecutive timesteps for which the unit is online.","category":"page"},{"location":"concept_reference/ramp_up_limit/#","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/ramp_up_limit/#","page":"-","title":"-","text":"For a more complete description of how ramping restrictions can be implemented, see Ramping and Reserves.","category":"page"},{"location":"concept_reference/fix_units_invested_available/#","page":"-","title":"-","text":"Used primarily to fix the value of the units_invested_available variable which represents the unit investment decision variable and how many candidate units are invested-in and available at the corresponding node, time step and stochastic scenario. Used also in the decomposition framework to communicate the value of the master problem solution variables to the operational sub-problem. ","category":"page"},{"location":"concept_reference/fix_units_invested_available/#","page":"-","title":"-","text":"See also investment_optimization, candidate_units and unit_investment_variable_type","category":"page"},{"location":"concept_reference/node__unit_constraint/#","page":"-","title":"-","text":"node__unit_constraint is a two-dimensional relationship between a node and a unit_constraint. The relationship specifies that a variable associated only with the node (currently only the node_state) is involved in the constraint. For example, the nodestatecoefficient defined on node__unit_constraint specifies the coefficient of the node's node_state variable in the specified unit_constraint. ","category":"page"},{"location":"concept_reference/node__unit_constraint/#","page":"-","title":"-","text":"See also unit_constraints","category":"page"},{"location":"concept_reference/state_coeff/#","page":"-","title":"-","text":"The state_coeff parameter acts as a coefficient for the node_state variable in the node injection constraint. Essentially, it tells how the node_state variable should be treated in relation to the commodity flows and demand, and can be used for e.g. scaling or unit conversions. For most use-cases a state_coeff parameter value of 1.0 should suffice, e.g. having a MWh storage connected to MW flows in a model with hour as the basic unit of time.","category":"page"},{"location":"concept_reference/state_coeff/#","page":"-","title":"-","text":"Note that in order for the state_coeff parameter to have an impact, the node must first have a node_state variable to begin with, defined using the has_state parameter. By default, the state_coeff is set to zero as a precaution, so that the user always has to set its value explicitly for it to have an impact on the model.","category":"page"},{"location":"concept_reference/commodity/#","page":"-","title":"-","text":"Commodities correspond to the type of energy traded. When associated with a node through the node__commodity relationship, a specific form of energy, i.e. commodity, can be associated with a specific location. Furthermore, by linking commodities with units, it is possible to track the flows of a certain commodity and impose limitations on the use of a certain commodity (See also max_cum_in_unit_flow_bound). For the representation of specific commodity physics, related to e.g. the representation of the electric network, designated parameters can be defined to enforce commodity specific behaviour. (See also commodity_physics)","category":"page"},{"location":"concept_reference/demand_coefficient/#","page":"-","title":"-","text":"The demand_coefficient is an optional parameter that can be used to include the demand of the a node in a unit_constraint via the node__unit_constraint relationship. Essentially, demand_coefficient appears as a coefficient for the demand parameter of the connected node in the unit constraint.","category":"page"},{"location":"concept_reference/min_voltage_angle/#","page":"-","title":"-","text":"If a node has a node_voltage_angle variable (see also the parameter has_voltage_angle and this chapter), a lower bound on the pressure can be introduced through the min_voltage_angle parameter, which triggers the generation of the minimum node voltage angle constraint.","category":"page"},{"location":"concept_reference/fix_storages_invested_available/#","page":"-","title":"-","text":"Used primarily to fix the value of the storages_invested_available variable which represents the storages investment decision variable and how many candidate storages are available at the corresponding node, time step and stochastic scenario. Used also in the decomposition framework to communicate the value of the master problem solution variables to the operational sub-problem. ","category":"page"},{"location":"concept_reference/fix_storages_invested_available/#","page":"-","title":"-","text":"See also candidate_storages and investment_optimization","category":"page"},{"location":"concept_reference/connection_availability_factor/#","page":"-","title":"-","text":"To indicate that a connection is only available to a certain extend or at certain times of the optimization, the connection_availability_factor can be used. A typical use case could be an availability timeseries for connection with expected outage times. By default the availability factor is set to 1. The availability is, among others, used in the constraintconnectionflow_capacity.","category":"page"},{"location":"concept_reference/connection__from_node/#","page":"-","title":"-","text":"connection__from_node is a two-dimensional relationship between a connection and a node and implies a connection_flow to the connection from the node. Specifying such a relationship will give rise to a connection_flow_variable with indices connection=connection, node=node, direction=:from_node. Relationships defined on this relationship will generally apply to this specific flow variable. For example, connection_capacity will apply only to this specific flow variable, unless the connection parameter connection_type is specified.","category":"page"},{"location":"concept_reference/duration_unit_list/#","page":"-","title":"-","text":"The duration_unit_list parameter value list contains the possible values for the duration_unit parameter.","category":"page"},{"location":"concept_reference/commodity_physics_list/#","page":"-","title":"-","text":"commodity_physics_list holds the possible values for the commodity parameter commodity_physics parameter. See commodity_physics for more details","category":"page"},{"location":"concept_reference/connection_investment_variable_type/#","page":"-","title":"-","text":"The connection_investment_variable_type parameter represents the type of the connections_invested_available decision variable.","category":"page"},{"location":"concept_reference/connection_investment_variable_type/#","page":"-","title":"-","text":"The default value, variable_type_integer, means that only integer factors of the connection_capacity can be invested in. The value variable_type_continuous means that any fractional factor can also be invested in. The value variable_type_binary means that only a factor of 1 or zero are possible.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_in_in/#","page":"-","title":"-","text":"The fix_units_on_coefficient_in_in parameter is an optinal coefficient in the unit input-input ratio constraint controlled by the fix_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_in_in/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_out, fix_units_on_coefficient_out_in, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_in_in and max_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/block_end/#","page":"-","title":"-","text":"Indicates the end of this temporal block. The default value is equal to a duration of 0. It is useful to distinguish here between two cases: a single solve, or a rolling window optimization.","category":"page"},{"location":"concept_reference/block_end/#","page":"-","title":"-","text":"single solve When a Date time value is chosen, this is directly the end of the optimization for this temporal block. In a single solve optimization, a combination of block_start and block_end can easily be used to run optimizations that cover only part of the model horizon. Multiple temporal_block objects can then be used to create optimizations for disconnected time periods, which is commonly used in the method of representative days. The default value coincides with the model_end.","category":"page"},{"location":"concept_reference/block_end/#","page":"-","title":"-","text":"rolling window optimization To create a temporal block that is rolling along with the optimization window, a rolling temporal block, a duration value should be chosen. The block_end parameter will in this case determine the size of the optimization window, with respect to the start of each optimization window. If multiple temporal blocks with different block_end parameters exist, the maximum value will determine the size of the optimization window. Note, this is different from the roll_forward parameter, which determines how much the window moves for after each optimization. For more info, see One single temporal_block. The default value is equal to the roll_forward parameter.","category":"page"},{"location":"concept_reference/block_end/#","page":"-","title":"-","text":"To create a static temporalblock, that doesn't move along with the rolling optimization window, the `blockendneeds to be defined as aDateTime` value. #TODO: this is not yet supported","category":"page"},{"location":"concept_reference/model_end/#","page":"-","title":"-","text":"Together with the model_start parameter, it is used to define the temporal horizon of the model. In case of a single solve optimization, the parameter marks the end of the last timestep that is possibly part of the optimization. Note that it poses an upper bound, and that the optimization does not necessarily include this timestamp when the block_end parameters are more stringent.","category":"page"},{"location":"concept_reference/model_end/#","page":"-","title":"-","text":"In case of a rolling horizon optimization, it will tell to the model to stop rolling forward once an optimization has been performed for which the result of the indicated timestamp has been kept in the final results. For example, assume that a model_end value of 2030-01-01T05:00:00 has been chosen, a block_end of 3h, and a roll_forward of 2h. The roll_forward parameter indicates here that the results of the first two hours of each optimization window are kept as final, therefore the last optimization window will span the timeframe [2030-01-01T04:00:00 - 2030-01-01T06:00:00].","category":"page"},{"location":"concept_reference/model_end/#","page":"-","title":"-","text":"A DateTime value should be chosen for this parameter. ","category":"page"},{"location":"concept_reference/model__report/#","page":"-","title":"-","text":"The model__report relationship tells which reports are written by which model, where the contents of the reports are defined separately using the report__output relationship. Without appropriately defined model__report and report__output and relationships, SpineOpt doesn't write any output, so be sure to include at least one report connected to all the output variables of interest in the model!","category":"page"},{"location":"concept_reference/max_units_on_coefficient_out_in/#","page":"-","title":"-","text":"The max_units_on_coefficient_out_in parameter is an optinal coefficient in the unit output-input ratio constraint controlled by the max_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/max_units_on_coefficient_out_in/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_in_out, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_out_in and fix_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/fix_node_voltage_angle/#","page":"-","title":"-","text":"For a lossless nodal DC power flow network, each node is associated with a node_voltage_angle variable. In order to fix the voltage angle at a certain node or to give initial conditions the fix_node_voltage_angle parameter can be used.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_out_out/#","page":"-","title":"-","text":"The fix_units_on_coefficient_out_out parameter is an optinal coefficient in the unit output-output ratio constraint controlled by the fix_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_out_out/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_in_out, and fix_units_on_coefficient_out_in, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_out_out and max_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/node_state_min/#","page":"-","title":"-","text":"The node_state_min parameter sets the lower bound for the node_state variable, if one has been enabled by the [has_state] parameter. For reserve nodes with minimum_reserve_activation_time, the node_state_min is considered also via a special constraint.","category":"page"},{"location":"concept_reference/min_res_shutdown_ramp/#","page":"-","title":"-","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning downward reserves are provided by contracted units holding available to shutdown to a downward_reserve node. If a unit is scheduled to provide nonspinning reserve, a limit on the minimum amount of reserves provided can be imposed by defining the parameter min_res_shutdown_ramp on a unit__to_node relationship, which triggers the constraint on minimum downward nonspinning reserve provision. The parameter min_res_shutdown_ramp is given as a fraction of the unit_capacity of the corresponding unit__to_node relationship.","category":"page"},{"location":"concept_reference/min_res_shutdown_ramp/#","page":"-","title":"-","text":"Note that to include the provision of nonspinning downward reserves, the parameter max_res_shutdown_ramp needs to be defined on the corresponding unit__to_node relationship, which triggers the generation of the variables nonspin_units_shut_down and nonspin_ramp_down_unit_flow.","category":"page"},{"location":"concept_reference/min_res_shutdown_ramp/#","page":"-","title":"-","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/node_slack_penalty/#","page":"-","title":"-","text":"node_slack_penalty triggers the creation of node slack variables, node_slack_pos and node_slack_neg.  This allows the model to violate the node_balance constraint with these violations penalised in the objective function  with a coefficient equal to node_slack_penalty. If node_slack_penalty = 0 the slack variables are created and violations are  unpenalised. If set to none or undefined, the variables are not created and violation of the node_balance constraint is  not possible. ","category":"page"},{"location":"concept_reference/downward_reserve/#","page":"-","title":"-","text":"If a node has a true is_reserve_node parameter, it will be treated as a reserve node in the model. To define whether the node corresponds to an upward or downward reserve commodity, the [upward_reserve] or the [downward_reserve] parameter needs to be set to true, respectively.","category":"page"},{"location":"concept_reference/node_opf_type/#","page":"-","title":"-","text":"Used to identify the reference node (or slack bus) when ptdf based dc load flow is enabled (commodity_physics set to commodity_physics_ptdf or commodity_physics_lodf. To identify the reference node, set node_opf_type = :node_opf_type_reference","category":"page"},{"location":"concept_reference/node_opf_type/#","page":"-","title":"-","text":"See also powerflow","category":"page"},{"location":"concept_reference/balance_type/#","page":"-","title":"-","text":"The balance_type parameter determines whether or not a node needs to be balanced, in the classical sense that the sum of flows entering the node is equal to the sum of flows leaving it.","category":"page"},{"location":"concept_reference/balance_type/#","page":"-","title":"-","text":"The values balance_type_node (the default) and balance_type_group mean that the node is always balanced. The only exception is if the node belongs in a group that has itself balance_type equal to balance_type_group. The value balance_type_none means that the node doesn't need to be balanced.","category":"page"},{"location":"advanced_concepts/decomposition/#Decomposition-1","page":"Decomposition","title":"Decomposition","text":"","category":"section"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"Decomposition approaches take advantage of certain problem structures to separate them into multiple related problems which are each more easily solved. Decomposition also allows us to do the inverse, which is to combine independent problems into a single problem, where each can be solved separately but with communication between them (e.g. investments and operations problems)","category":"page"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"Decomposition thus allows us to do a number of things","category":"page"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"Solve larger problems which are otherwise intractable\nInclude more detail in problems which otherwise need to be simplified\nCombine related problems (e.g. investments/operations) in a more scientific way (rather than ad-hoc).\nEmploy parallel computing methods to solve multiple problems simultaneously.","category":"page"},{"location":"advanced_concepts/decomposition/#High-level-Decomposition-Algorithm-1","page":"Decomposition","title":"High-level Decomposition Algorithm","text":"","category":"section"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"The high-level algorithm works as follows:","category":"page"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"Model initialisation (preprocessdatastructure, generate temporal structures etc.)\nFor each benders_iteration\nSolve master problem\nProcess master-problem solution:\nset unitsinvestedbi(unit=u, benders_iteration=bi) equal to a timeseries representing the investment variables solution from the master problem\nRewind and update operations problem\nSolve operations problem loop\nProcess operations sub-problem\nset unitsavailablemw(unit=u, bendersiteration=bi) equal to a timeseries representing the marginal value of the unitson bound constraint\nTest for convergence\nUpdate master problem\nAdd Benders cuts constraints (constraintmpunitsinvestedcuts)\nNext benders iteration","category":"page"},{"location":"advanced_concepts/decomposition/#Duals-calculation-for-decomposition-1","page":"Decomposition","title":"Duals calculation for decomposition","text":"","category":"section"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"The optimize_model!() function has been updated to optionally include an additional step for the calculation of duals. The dual solution to a MIP problem is not well defined. The standard approach to obtaining marginal values from a MIP model is to relax the integer variables, fix them to their last solution value and re-solve the problem as an LP. This is the standard approach in energy system modelling to obtain energy prices. However, although this is the standard approach, it does need to be used with caution (see here for example). The main hazard associated with inferring duals in this way is that the impact on costs of an investment may be overstated. However, since these duals are used in Benders decomposition to obtain a lower bound on costs (i.e. the maximum potential value from an investment), this is ok and can be \"corrected\" in the next iteration. And finally, the benders gap will tell us how close our decomposed problem is to the optimal global solution.","category":"page"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"This additional relaxed LP solve is done as follows:","category":"page"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"add_varialbe!() stores the list of integer and binary variables in m.ext[:integer_variables]\nthe fix_value for integer variables is set to the last MIP solution value\nthe integer constraints on the integer variables are unset()\nA final LP is solved\nrequired dual values are saved\ninteger constraints on integer variables are set()","category":"page"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"This final fixed LP solve is trigged by specifying calculate_duals=true in the call to optimize_model!()","category":"page"},{"location":"advanced_concepts/decomposition/#Reporting-dual-values:-1","page":"Decomposition","title":"Reporting dual values:","text":"","category":"section"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"To report the dual of a constraint, one can add an output item with the corresponding constraint name (e.g. constraint_nodal_balance) and add that to a report. This will cause the corresponding constraint's relaxed problem marginal value will be reported in the output DB. When adding a constraint name as an output we need to preface the actual constraint name with \"constraint\" to avoid ambiguity with variable names (e.g. `unitsavailable). So to report the marginal value ofunitsavailable` we add an output object called \"constraintunits_available\".","category":"page"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"To report the reduced_cost() for a variable which is the marginal value of the associated active bound or fix constraints on that variable, one can add an output object with the variable name prepended by \"bound\". So, to report the unitson reducedcost value, one would create an output item called \"boundunitson\". If added to a report, this will cause the reduced cost of unitson in the final fixed LP to be written to the output db. Finally, if any constraint duals or reducedcost values are requested via a report, calculateduals is set to true and the final fixed LP solve is triggered.","category":"page"},{"location":"advanced_concepts/decomposition/#Using-Decomposition-1","page":"Decomposition","title":"Using Decomposition","text":"","category":"section"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"The decomposition framework creates a master problem where the investment variables are optimised. The decomposition framework is invoked when a model object with the parameter model_type set to :spineopt_operations is found and a second model object with model_type set to :spineopt_master. Once these conditions are met, all investment decisions in the model are automatically decomposed and optimised in the master problem. This behavriour may change in the future to allow some investment decisions to be optimised in the operations problem and some optimised in the master problem as desired.","category":"page"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"Additionally, the following should be specified:  ","category":"page"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"master problem model parameter, max_gap - This determines the master problem convergence criterion for the relative benders gap\nmaster problem model max_iterations - This determines the master problem convergence criterion for the number of iterations  - \nmodel_report: relationship which determines which reports are written for which model","category":"page"},{"location":"advanced_concepts/decomposition/#","page":"Decomposition","title":"Decomposition","text":"","category":"page"},{"location":"concept_reference/node__commodity/#","page":"-","title":"-","text":"node__commodity is a two-dimensional relationship between a node and a commodity and specifies the commodity that flows to or from the node. Generally, since flows are not dimensioned by commodity, this has no meaning in terms of the variables and constraint equations. However, there are two specific uses for this relationship:","category":"page"},{"location":"concept_reference/node__commodity/#","page":"-","title":"-","text":"To specify that specific network physics should apply to the network formed by the member nodes for that commodity. See powerflow\nOnly connection flows that are between nodes of the same or no commodity are included in the node_balance constraint.","category":"page"},{"location":"concept_reference/duration_unit/#","page":"-","title":"-","text":"The duration_unit parameter specifies the unit of time in a model.","category":"page"},{"location":"concept_reference/duration_unit/#","page":"-","title":"-","text":"Two values are currently supported, hour (the default) and minute.","category":"page"},{"location":"concept_reference/resolution/#","page":"-","title":"-","text":"This parameter specifies the resolution of the temporal block, or in other words: the length of the timesteps used in the optimization run. Generally speaking, variables and constraints are generated for each timestep of an optimization. For example, the nodal balance constraint must hold for each timestep.","category":"page"},{"location":"concept_reference/resolution/#","page":"-","title":"-","text":"An array of duration values can be used to have a resolution that varies with time itself. It can for example be used when uncertainty in one of the inputs rises as the optimization moves away from the model start. Think of a forecast of for instance wind power generation, which might be available in quarter hourly detail for one day in the future, and in hourly detail for the next two days. It is possible to take a quarter hourly resolution for the full horizon of three days. However, by lowering the temporal resolution after the first day, the computational burden is lowered substantially.","category":"page"},{"location":"mathematical_formulation/sets/#Sets-1","page":"Sets","title":"Sets","text":"","category":"section"},{"location":"mathematical_formulation/sets/#","page":"Sets","title":"Sets","text":"Name Description\n(conn n d s t) in connection_flow_indices Indices of the variable(s) v_connection_flow (conn n d s t)\n(conn n d s t) in connection_intact_flow_indices Indices of the variable(s) v_connection_intact_flow(conn n d s t)\n(conn s t) in connections_invested_available_indices Indices of the variable(s) v_connections_decommissioned(conn s t),v_connections_invested(conn s t),v_connections_invested_available(conn s t)\nt in mp_objective_lowerbound_indices Indices of the variable(s) v_mp_objective_lowerbound_indices(t)\n(n s t) in node_injection_indices Indices of the variable(s) v_node_injection(n s t)\n(n s t) in node_slack_indices Indices of the variable(s) v_node_slack_neg(n s t),v_node_slack_pos(n s t)\n(n s t) in node_state_indices Indices of the variable(s) v_node_state(n s t)\n(u n d s t) in nonspin_ramp_down_unit_flow_indices Indices of the variable(s) v_nonspin_ramp_down_unit_flow(u n d s t)\n(u n d s t) in nonspin_ramp_up_unit_flow_indices Indices of the variable(s) v_nonspin_ramp_up_unit_flow(u n d s t)\n(u n s t) in nonspin_units_shut_down_indices Indices of the variable(s) v_nonspin_units_shut_down(u n s t)\n(u n s t) in nonspin_units_started_up_indices Indices of the variable(s) v_nonspin_units_started_up(u n s t)\n(u n d s t) in ramp_down_unit_flow_indices Indices of the variable(s) v_ramp_down_unit_flow(u n d s t)\n(u n d s t) in ramp_up_unit_flow_indices Indices of the variable(s) v_ramp_up_unit_flow(u n d s t)\n(u n d s t) in shut_down_unit_flow_indices Indices of the variable(s) v_shut_down_unit_flow(u n d s t)\n(u n d s t) in start_up_unit_flow_indices Indices of the variable(s) v_start_up_unit_flow(u n d s t)\n(n s t) in storages_invested_available_indices Indices of the variable(s) v_storages_decommissioned(n s t),v_storages_invested(n s t),v_storages_invested_available(n s t)\n(u n d s t) in unit_flow_indices Indices of the variable(s) v_unit_flow(u n d s t)\n(u n d i s t) in unit_flow_op_indices Indices of the variable(s) v_unit_flow_op(u n d i s t)\n(u s t) in units_on_indices Indices of the variable(s) v_units_available(u s t),v_units_on(u s t),v_units_shut_down(u s t),v_units_started_up(u s t)\n(u s t) in units_invested_available_indices Indices of the variable(s) v_units_invested(u s t),v_units_invested_available(u s t),v_units_mothballed(u s t)\n(u s t) in units_on_indices Indices of the variable(s) v_units_available(u s t),v_units_on(u s t),v_units_shut_down(u s t),v_units_started_up(u s t)\n in ind(*parameter*) Tuple of all objects, for which the parameter is defined\nt in t_before_t(t_after=t) Set of timeslices that are directly before timeslice t'.\nt in t_before_t(t_before=t) Set of timeslices that are directly after timeslice t'.\nt in t_in_t(t_short=t) Set of timeslices that contain timeslice t'\nt in t_in_t(t_long=t) Set of timeslices that are contained in timeslice t'\nt in t_overlaps_t(t) Set of timeslices that overlap with timeslice t'\ns_path in full_stochastic_paths Set of all possible scenario branches\ns_path in active_stochastic_paths(s) Set of all active scenario branches, based on active scenarios s","category":"page"},{"location":"mathematical_formulation/variables/#Variables-1","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"mathematical_formulation/variables/#","page":"Variables","title":"Variables","text":"Variable name Description\nv_connection_flow (conn n d s t) Commodity flow associated with node n over the connection conn in the direction d for the stochastic scenario s at timestep t\nv_connection_intact_flow(conn n d s t) ???\nv_connections_decommissioned(conn s t) Number of decomissioned connections conn for the stochastic scenario s at timestep t\nv_connections_invested(conn s t) Number of connections conn invested at timestep t in for the stochastic scenario s\nv_connections_invested_available(conn s t) Number of invested connections conn  that are available still the stochastic scenario s at timestep t\nv_mp_objective_lowerbound_indices(t) Updating lowerbound for master problem of Benders decomposition\nv_node_injection(n s t) Commodity injections at node n for the stochastic scenario s at timestep t\nv_node_slack_pos(n s t) Positive slack variable at node n for the stochastic scenario s at timestep t\nv_node_slack_neg(n s t) Negative slack variable at node n for the stochastic scenario s at timestep t\nv_node_state(n s t) Storage state at node n for the stochastic scenario s at timestep t\nv_nonspin_ramp_down_unit_flow(u n d s t) Non-spinning down ward reserve commodity flows of unit u at node n  in the direction d for the stochastic scenario s at timestep t\nv_nonspin_ramp_up_unit_flow(u n d s t) Non-spinning upward reserve commodity flows of unit u at node n  in the direction d for the stochastic scenario s at timestep t\nv_nonspin_units_shut_down(u n s t) Number of units u held available for non-spinning downward reserve provision via shutdown to node n  for the stochastic scenario s at timestep t\nv_nonspin_units_started_up(u n s t) Number of units u held available for non-spinning upward reserve provision via startup to node n  for the stochastic scenario s at timestep t\nv_ramp_down_unit_flow(u n d s t) Spinning downward ramp commodity flow associated with node n of unit u  with node n over the connection conn in the direction d for the stochastic scenario s at timestep t\nv_ramp_up_unit_flow(u n d s t) Spinning upward ramp commodity flow associated with node n of unit u  with node n over the connection conn in the direction d for the stochastic scenario s at timestep t\nv_shut_down_unit_flow(u n d s t) Downward ramp commodity flow during shutdown associated with node n of unit u  with node n over the connection conn in the direction d for the stochastic scenario s at timestep t\nv_start_up_unit_flow(u n d s t) Upward ramp commodity flow during start-up associated with node n of unit u  with node n over the connection conn in the direction d for the stochastic scenario s at timestep t\nv_storages_decommissioned(n s t) Number of decomissioned storage nodes n for the stochastic scenario s at timestep t\nv_storages_invested(n s t) Number of storage nodes n invested in  at timestep t for the stochastic scenario s\nv_storages_invested_available(n s t) Number of invested storage nodes n  that are available still the stochastic scenario s at timestep t\nv_unit_flow(u n d s t) Commodity flow associated with node n over the unit u in the direction d for the stochastic scenario s at timestep t\nv_unit_flow_op(u n d i s t) Contribution of the unit flow assocaited with operating point i\nv_units_available(u s t) Number of available units u for the stochastic scenario s at timestep t\nv_units_invested(u s t) Number of units u for the stochastic scenario s  invested in at timestep t\nv_units_invested_available(u s t) Number of invested units u  that are available still the stochastic scenario s at timestep t\nv_units_mothballed(u s t) Number of units u for the stochastic scenariocenario s  mothballed at timestep t\nv_units_on(u s t) Number of online units u for the stochastic scenario s at timestep t\nv_units_shut_down(u s t) Number of units u for the stochastic scenario s that switched to offline status at timestep t\nv_units_started_up(u s t) Number of units u for the stochastic scenario s that switched to online status at timestep t","category":"page"},{"location":"concept_reference/minimum_reserve_activation_time/#","page":"-","title":"-","text":"The parameter minimum_reserve_activation_time is the duration a reserve product needs to be online, before it can be replaced by another (slower) reserve product.","category":"page"},{"location":"concept_reference/minimum_reserve_activation_time/#","page":"-","title":"-","text":"In SpineOpt, the parameter is used to model reserve provision through storages. If a storage provides reserves to a reserve node (see also is_reserve_node) one needs to ensure that the node state is sufficiently high to provide these scheduled reserves as least for the duration of the minimum_reserve_activation_time. The constraint on the minimum node state with reserve provision is trigger by the existence of the minimum_reserve_activation_time. See also Ramping and Reserves","category":"page"},{"location":"concept_reference/fixed_pressure_constant_1/#","page":"-","title":"-","text":"For the MILP representation of pressure driven gas transfer, we use an outer approximation approach as described by Schwele et al.. The Weymouth equation is approximated around fixed pressure points, as described by the constraint on fixed node pressure points, constraining the average flow in each direction dependent on the adjacent node pressures. The first fixed pressure constant, which will be multiplied with the pressure of the origin node, is represented by an Array value of the fixed_pressure_constant_1. The second pressure constant corresponds to the related parameter fixed_pressure_constant_0. Note that the fixed_pressure_constant_1 parameter should be defined on a connection__node__node relationship, for which the first node corresponds to the origin node, while the second node corresponds to the destination node. For a typical gas pipeline, the will be a fixed_pressure_constant_1  for both directions of flow.","category":"page"},{"location":"concept_reference/fuel_cost/#","page":"-","title":"-","text":"By defining the fuel_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for costs associated with the unit's fuel usage over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/online_variable_type/#","page":"-","title":"-","text":"online_variable_type is a method parameter closely related to the number_of_units and can take the values \"unit_online_variable_type_binary\", \"unit_online_variable_type_integer\", \"unit_online_variable_type_linear\". If the binary value is chosen, the units status is modelled as a binary (classic UC). For clustered unit commitment units, the integer type is applicable. Note that if the parameter is not defined, the default will be linear. If the units status is not crucial, this can reduce the computational burden.","category":"page"},{"location":"concept_reference/stochastic_scenario_end/#","page":"-","title":"-","text":"The stochastic_scenario_end is a Duration-type parameter, defining when a stochastic_scenario ends relative to the start of the current optimization. As it is a parameter for the stochastic_structure__stochastic_scenario relationship, different stochastic_structures can have different values for the same stochastic_scenario, making it possible to define slightly different stochastic_structures using the same stochastic_scenarios. See the Stochastic Framework section for more information about how different stochastic_structures interact in SpineOpt.jl.","category":"page"},{"location":"concept_reference/stochastic_scenario_end/#","page":"-","title":"-","text":"When a stochastic_scenario ends at the point in time defined by the stochastic_scenario_end parameter, it spawns its children according to the parent_stochastic_scenario__child_stochastic_scenario relationship. Note that the children will be inherently assumed to belong to the same stochastic_structure their parent belonged to, even without explicit stochastic_structure__stochastic_scenario relationships! Thus, you might need to define the weight_relative_to_parents parameter for the children.","category":"page"},{"location":"concept_reference/stochastic_scenario_end/#","page":"-","title":"-","text":"If no stochastic_scenario_end is defined, the stochastic_scenario is assumed to go on indefinitely.","category":"page"},{"location":"concept_reference/fractional_demand/#","page":"-","title":"-","text":"Whenever a node is a member of a group, the fractional_demand parameter represents its share of the group's demand.","category":"page"},{"location":"concept_reference/node/#","page":"-","title":"-","text":"The node is perhaps the most important object class out of the Systemic object classes, as it is what connects the rest together via the Systemic relationship classes. Essentially, nodes act as points in the modelled commodity network where commodity balance is enforced via the node balance and node injection constraints, tying together the inputs and outputs from units and connections, as well as any external demand. Furthermore, nodes play a crucial role for defining the temporal and stochastic structures of the model via the node__temporal_block and node__stochastic_structure relationships. For more details about the Temporal Framework and the Stochastic Framework, please refer to the dedicated sections.","category":"page"},{"location":"concept_reference/node/#","page":"-","title":"-","text":"As nodes act the points where [commodity]@(ref) balance is enforced, this also makes them a natural fit for implementing storage. The has_state parameter controls whether a node has a node_state variable, which essentially represents the commodity content of the node, The state_coeff parameter tells how the node_state variable relates to all the commodity flows. Storage losses are handled via the frac_state_loss parameter, and potential diffusion of commodity content to other nodes via the diff_coeff parameter for the node__node relationship.","category":"page"},{"location":"concept_reference/node__investment_stochastic_structure/#","page":"-","title":"-","text":"The node__investment_stochastic_structure relationship defines the stochastic_structure of node-related investment decisions. Essentially, it sets the stochastic_structure used by the storages_invested_available variable of the node.","category":"page"},{"location":"concept_reference/node__investment_stochastic_structure/#","page":"-","title":"-","text":"The node__investment_stochastic_structure relationship uses the model__default_investment_stochastic_structure relationship if not defined.","category":"page"},{"location":"concept_reference/candidate_units/#","page":"-","title":"-","text":"Within an investments problem candidate_units determines the upper bound on the unit investment decision variable in constraint units_invested_available. In constraint unit_flow_capacity the maximum unit_flow will be the product of the units_invested_available and the corresponding unit_capacity. Thus, the interpretation of candidate_units depends on @refunit_investment_variable_type which determines the unit investment decision variable type. If unit_investment_variable_type is integer or binary, then candidate_units represents the maximum number of discrete units that may be invested in. If unit_investment_variable_type is continuous, candidate_units is more analagous to a maximum storage capacity.","category":"page"},{"location":"concept_reference/candidate_units/#","page":"-","title":"-","text":"Note that candidate_units is the main investment switch and setting a value other than none/nothing triggers the creation of the investment variable for the unit. Note that a value of zero will still trigger the variable creation but its value will be fixed to zero. This can be useful if as inspection of the related dual variables will yield the value of this resource.","category":"page"},{"location":"concept_reference/candidate_units/#","page":"-","title":"-","text":"See also investment_optimization and unit_investment_variable_type","category":"page"},{"location":"getting_started/installation/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"getting_started/installation/#","page":"Installation","title":"Installation","text":"TODO: Explain what is needed to install SpineOpt, Spine Toolbox, etc. so that one is ready to start working on creating models or running optimizations.","category":"page"},{"location":"getting_started/installation/#Compatibility-1","page":"Installation","title":"Compatibility","text":"","category":"section"},{"location":"getting_started/installation/#","page":"Installation","title":"Installation","text":"This package requires Julia 1.2 or later.","category":"page"},{"location":"getting_started/installation/#Prerequisites-1","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"getting_started/installation/#","page":"Installation","title":"Installation","text":"To make use of the full functionality of SpineOpt, we strongly recommend the installation of Spine Toolbox. SpineToolbox provides all the necessary tools for data management required by SpineOpt.","category":"page"},{"location":"getting_started/installation/#How-to-Install-1","page":"Installation","title":"How to Install","text":"","category":"section"},{"location":"getting_started/installation/#","page":"Installation","title":"Installation","text":"julia> using Pkg\n\njulia> pkg\"registry add https://github.com/Spine-project/SpineJuliaRegistry\"\n\njulia> pkg\"add SpineOpt\"\n","category":"page"},{"location":"concept_reference/variable_type_list/#","page":"-","title":"-","text":"The variable_type_list parameter value list contains the possible values for the connection_investment_variable_type and storage_investment_variable_type parameters.","category":"page"},{"location":"concept_reference/fom_cost/#","page":"-","title":"-","text":"By defining the fom_cost parameter for a specific unit, a cost term will be added to the objective function to account for the fixed operation and maintenance costs associated with that unit during the current optimization window.","category":"page"},{"location":"concept_reference/max_res_shutdown_ramp/#","page":"-","title":"-","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning downward reserves are provided to a downward_reserve node by contracted units holding available to shutdown. To include the provision of nonspinning downward reserves, the parameter max_res_shutdown_ramp needs to be defined on the corresponding unit__to_node relationship. This will trigger the generation of the variables nonspin_units_shut_down and nonspin_ramp_down_unit_flow and the constraint on maximum downward nonspinning reserve provision. Note that max_res_shutdown_ramp is given as a fraction of the unit_capacity.","category":"page"},{"location":"concept_reference/max_res_shutdown_ramp/#","page":"-","title":"-","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/max_ratio_out_in_unit_flow/#","page":"-","title":"-","text":"The definition of the max_ratio_out_in_unit_flow parameter triggers the generation of the constraint_max_ratio_out_in_unit_flow and enforces an upper bound on the ratio between outgoing and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. To enforce e.g. a maximum ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ng the max_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/connection__investment_temporal_block/#","page":"-","title":"-","text":"connection__investment_temporal_block is a two-dimensional relationship between a connection and a temporal_block. This relationship defines the temporal resolution and scope of a connection's investment decision. Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__defaultinvestmenttemporal_block is specified and no connection__investment_temporal_block relationship is specified, the model__defaultinvestmenttemporal_block relationship will be used. Conversely if connection__investment_temporal_block is specified along with model__temporal_block, this will override model__defaultinvestmenttemporal_block for the specified connection.","category":"page"},{"location":"concept_reference/connection__investment_temporal_block/#","page":"-","title":"-","text":"See also investment_optimization","category":"page"},{"location":"concept_reference/Parameter Value Lists/#Parameter-Value-Lists-1","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#balance_type_list-1","page":"Parameter Value Lists","title":"balance_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: balance_type_none","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"The balance_type_list parameter value list contains the possible values for the balance_type parameter.","category":"page"},{"location":"concept_reference/Parameter Value Lists/#boolean_value_list-1","page":"Parameter Value Lists","title":"boolean_value_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: true","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"A list of boolean values (True or False).","category":"page"},{"location":"concept_reference/Parameter Value Lists/#commodity_physics_list-1","page":"Parameter Value Lists","title":"commodity_physics_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: commodity_physics_ptdf","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"commodity_physics_list holds the possible values for the commodity parameter commodity_physics parameter. See commodity_physics for more details","category":"page"},{"location":"concept_reference/Parameter Value Lists/#connection_investment_variable_type_list-1","page":"Parameter Value Lists","title":"connection_investment_variable_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: connection_investment_variable_type_integer","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"TODO","category":"page"},{"location":"concept_reference/Parameter Value Lists/#connection_type_list-1","page":"Parameter Value Lists","title":"connection_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: connection_type_normal","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"connection_type_list holds the possible values for the connection_type parameter. See connection_type for more details","category":"page"},{"location":"concept_reference/Parameter Value Lists/#constraint_sense_list-1","page":"Parameter Value Lists","title":"constraint_sense_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: >=","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"The constraint_sense_list parameter value list contains the possible values for the constraint_sense parameter.","category":"page"},{"location":"concept_reference/Parameter Value Lists/#duration_unit_list-1","page":"Parameter Value Lists","title":"duration_unit_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: minute","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"The duration_unit_list parameter value list contains the possible values for the duration_unit parameter.","category":"page"},{"location":"concept_reference/Parameter Value Lists/#model_type_list-1","page":"Parameter Value Lists","title":"model_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: spineopt_other","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"model_type_list holds the possible values for the model parameter model_type parameter. See model_type for more details","category":"page"},{"location":"concept_reference/Parameter Value Lists/#node_opf_type_list-1","page":"Parameter Value Lists","title":"node_opf_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: node_opf_type_reference","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"TODO","category":"page"},{"location":"concept_reference/Parameter Value Lists/#unit_investment_variable_type_list-1","page":"Parameter Value Lists","title":"unit_investment_variable_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: unit_investment_variable_type_integer","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"unit_investment_variable_type_list holds the possible values for the type of a unit's investment variable which may be chosen from integer, binary or continuous. ","category":"page"},{"location":"concept_reference/Parameter Value Lists/#unit_online_variable_type_list-1","page":"Parameter Value Lists","title":"unit_online_variable_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: unit_online_variable_type_linear","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"TODO","category":"page"},{"location":"concept_reference/Parameter Value Lists/#variable_type_list-1","page":"Parameter Value Lists","title":"variable_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: variable_type_integer","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"The variable_type_list parameter value list contains the possible values for the connection_investment_variable_type and storage_investment_variable_type parameters.","category":"page"},{"location":"concept_reference/Parameter Value Lists/#write_mps_file_list-1","page":"Parameter Value Lists","title":"write_mps_file_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Default value: write_mps_on_no_solve","category":"page"},{"location":"concept_reference/Parameter Value Lists/#","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"TODO","category":"page"},{"location":"concept_reference/has_pressure/#","page":"-","title":"-","text":"If a node is to present a node in a pressure driven gas network, the boolean parameter has_pressure should be set true, in order to trigger the generation of the v{nodepressure} variable. The pressure at a certain node can also be constrainted through the parameters max_node_pressure and min_node_pressure. More details on the use of pressure driven gas transfer are described here","category":"page"},{"location":"concept_reference/max_units_on_coefficient_in_in/#","page":"-","title":"-","text":"The max_units_on_coefficient_in_in parameter is an optinal coefficient in the unit input-input ratio constraint controlled by the max_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/max_units_on_coefficient_in_in/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_out, max_units_on_coefficient_out_in, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_in_in and fix_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/unit_start_flow/#","page":"-","title":"-","text":"Used to implement unit startup fuel consumption where node 1 is assumed to be input fuel and node 2 is assumed to be output elecrical energy. This is a flow from node 1 that is incurred when the value of the variable unitsstartedup is 1 in the corresponding time period. This flow does not result in additional output flow at node 2. Used in conjunction with unit_incremental_heat_rate. unit_start_flow is only currently considered if unit_incremental_heat_rate is specified. A trivial unit_incremental_heat_rate of zero can be defined if there is no incremental heat rate.","category":"page"},{"location":"concept_reference/balance_type_list/#","page":"-","title":"-","text":"The balance_type_list parameter value list contains the possible values for the balance_type parameter.","category":"page"},{"location":"concept_reference/connection_reactance/#","page":"-","title":"-","text":"The per unit reactance of a transmission line. Used in ptdf based dc load flow where the relative reactances of lines determine the ptdfs of the network and in lossless dc powerflow where the flow on a line is given by flow = 1/x(thetato-thetafrom) where x is the reatance of the line, thetato is the voltage angle of the remote node and thetafrom is the voltage angle of the sending node. ","category":"page"},{"location":"concept_reference/fix_node_pressure/#","page":"-","title":"-","text":"In a pressure driven gas model, gas network nodes are associated with the node_pressure variable. In order to fix the pressure at a certain node or to give intial conditions the fix_node_pressure parameter can be used.","category":"page"},{"location":"concept_reference/fix_ratio_out_in_connection_flow/#","page":"-","title":"-","text":"The definition of the fix_ratio_out_in_connection_flow parameter triggers the generation of the constraint_fix_ratio_out_in_connection_flow and fixes the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. In most cases the fix_ratio_out_in_connection_flow parameter is set to equal or lower than 1, linking the flows entering to the flows leaving the connection. The parameter can be used to e.g. account for losses over a connection in a certain direction.","category":"page"},{"location":"concept_reference/fix_ratio_out_in_connection_flow/#","page":"-","title":"-","text":"Note that the ratio can also be defined for unit__node__node relationships, where one or both of the nodes correspond to node groups in order to impose a ratio on aggregated connection flows. ","category":"page"},{"location":"concept_reference/fix_ratio_out_in_connection_flow/#","page":"-","title":"-","text":"To enforce e.g. a fixed ratio of 0.8 for a connection conn between its outgoing electricity flow to node el1 and its incoming flows from the node node el2, the fix_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship u__el1__el2.","category":"page"},{"location":"concept_reference/Relationship Classes/#Relationship-Classes-1","page":"Relationship Classes","title":"Relationship Classes","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#connection__from_node-1","page":"Relationship Classes","title":"connection__from_node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the nodes the connection can take input from, and holds most connection_flow variable specific parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and node","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: connection_capacity, connection_conv_cap_to_flow, connection_emergency_capacity, fix_binary_gas_connection_flow, fix_connection_flow, fix_connection_intact_flow and graph_view_position","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"connection__from_node is a two-dimensional relationship between a connection and a node and implies a connection_flow to the connection from the node. Specifying such a relationship will give rise to a connection_flow_variable with indices connection=connection, node=node, direction=:from_node. Relationships defined on this relationship will generally apply to this specific flow variable. For example, connection_capacity will apply only to this specific flow variable, unless the connection parameter connection_type is specified.","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__from_node__unit_constraint-1","page":"Relationship Classes","title":"connection__from_node__unit_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"when specified this relationship allows the relevant flow connection flow variable to be included in the specified user constraint","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection, node and unit_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: connection_flow_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"connection__from_node__unit_constraint is a three-dimensional relationship between a connection, a node and a unit_constraint. The relationship specifies that the connection_flow variable to the specified connection from the specified node is involved in the specified unit_constraint. Parameters on this relationship generally apply to this specific connection_flow variable. For example the parameter connectionflowcoefficient defined on connection__from_node__unit_constraint represents the coefficient on the specific connection_flow variable in the specified unit_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__investment_stochastic_structure-1","page":"Relationship Classes","title":"connection__investment_stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the stochastic structure of the connections investments variable","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__investment_temporal_block-1","page":"Relationship Classes","title":"connection__investment_temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the temporal resolution of the connections investments variable","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"connection__investment_temporal_block is a two-dimensional relationship between a connection and a temporal_block. This relationship defines the temporal resolution and scope of a connection's investment decision. Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__defaultinvestmenttemporal_block is specified and no connection__investment_temporal_block relationship is specified, the model__defaultinvestmenttemporal_block relationship will be used. Conversely if connection__investment_temporal_block is specified along with model__temporal_block, this will override model__defaultinvestmenttemporal_block for the specified connection.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"See also investment_optimization","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__node__node-1","page":"Relationship Classes","title":"connection__node__node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Holds parameters spanning multiple connection_flow variables to and from multiple nodes.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and node","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: compression_factor, connection_flow_delay, connection_linepack_constant, fix_ratio_out_in_connection_flow, fixed_pressure_constant_0, fixed_pressure_constant_1, max_ratio_out_in_connection_flow and min_ratio_out_in_connection_flow","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"connection__node__node is a three-dimensional relationship between a connection, a node (node 1) and another node (node 2). connection__node__node infers a conversion and a direction with respect to that conversion. Node 1 is assumed to be the input node and node 2 is assumed to be the output node. For example, the fixratiooutinconnection_flow parameter defined on connection__node__node relates the output connection_flow to node 2 to the intput connection_flow from node 1","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__to_node-1","page":"Relationship Classes","title":"connection__to_node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the nodes the connection can output to, and holds most connection_flow variable specific parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and node","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: connection_capacity, connection_conv_cap_to_flow, connection_emergency_capacity, fix_connection_flow, fix_connection_intact_flow and graph_view_position","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"connection__to_node is a two-dimensional relationship between a connection and a node and implies a connection_flow from the connection to the node. Specifying such a relationship will give rise to a connection_flow_variable with indices connection=connection, node=node, direction=:to_node. Relationships defined on this relationship will generally apply to this specific flow variable. For example, connection_capacity will apply only to this specific flow variable, unless the connection parameter connection_type is specified.","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__to_node__unit_constraint-1","page":"Relationship Classes","title":"connection__to_node__unit_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"when specified this relationship allows the relevant flow connection flow variable to be included in the specified user constraint","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection, node and unit_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: connection_flow_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"connection__to_node__unit_constraint is a three-dimensional relationship between a connection, a node and a unit_constraint. The relationship specifies that the connection_flow variable from the specified connection to the specified node is involved in the specified unit_constraint. Parameters on this relationship generally apply to this specific connection_flow variable. For example the parameter connectionflowcoefficient defined on connection__to_node__unit_constraint represents the coefficient on the specific connection_flow variable in the specified unit_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/#model__default_investment_stochastic_structure-1","page":"Relationship Classes","title":"model__default_investment_stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the default stochastic structure used for investment variables, which will be replaced by more specific definitions","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The model__default_investment_stochastic_structure relationship can be used to set model-wide default unit__investment_stochastic_structure, connection__investment_stochastic_structure, and node__investment_stochastic_structure relationships. Its main purpose is to allow users to avoid defining each relationship individually, and instead allow them to focus on defining only the exceptions. As such, any specific unit__investment_stochastic_structure, connection__investment_stochastic_structure, and node__investment_stochastic_structure relationships take priority over the model__default_investment_stochastic_structure relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/#model__default_investment_temporal_block-1","page":"Relationship Classes","title":"model__default_investment_temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the default temporal block used for investment variables, which will be replaced by more specific definitions","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"model__default_investment_temporal_block is a two-dimensional relationship between a model and a temporal_block. This relationship defines the default temporal resolution and scope for all investment decisions in the model (units, connections and storages). Specifying model__default_investment_temporal_block for a model avoids the need to specify individual node__investmenttemporalblock, unit__investmenttemporalblock and connection__investmenttemporalblock relationships. Convesely, if any of these individual relationships are defined (e.g. connection__investmenttemporalblock) along with model__temporal_block, these will override model__defaultinvestmenttemporal_block.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"See also investment_optimization","category":"page"},{"location":"concept_reference/Relationship Classes/#model__default_stochastic_structure-1","page":"Relationship Classes","title":"model__default_stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the default stochastic structure used for model variables, which will be replaced by more specific definitions","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The model__default_stochastic_structure relationship can be used to set a model-wide default for the node__stochastic_structure and units_on__stochastic_structure relationships. Its main purpose is to allow users to avoid defining each relationship individually, and instead allow them to focus on defining only the exceptions. As such, any specific node__stochastic_structure or units_on__stochastic_structure relationships take priority over the model__default_stochastic_structure relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/#model__default_temporal_block-1","page":"Relationship Classes","title":"model__default_temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the default temporal block used for model variables, which will be replaced by more specific definitions","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#model__report-1","page":"Relationship Classes","title":"model__report","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Determines which reports are written for each model and in turn, which outputs are written for each model","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and report","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The model__report relationship tells which reports are written by which model, where the contents of the reports are defined separately using the report__output relationship. Without appropriately defined model__report and report__output and relationships, SpineOpt doesn't write any output, so be sure to include at least one report connected to all the output variables of interest in the model!","category":"page"},{"location":"concept_reference/Relationship Classes/#model__stochastic_structure-1","page":"Relationship Classes","title":"model__stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which stochastic_structures are included in which models.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The [model__stochastic_structure] relationship defines which stochastic_structures are active in which models. Essentially, this relationship allows for e.g. attributing multiple node__stochastic_structure relationships for a single node, and switching between them in different models. Any stochastic_structure in model__default_stochastic_structure is automatically assumed to be active in the connected model, so there's no need to include it in [model__stochastic_structure] separately.","category":"page"},{"location":"concept_reference/Relationship Classes/#model__temporal_block-1","page":"Relationship Classes","title":"model__temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which temporal_blocks are included in which models.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#node__commodity-1","page":"Relationship Classes","title":"node__commodity","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Define a commodity for a node. Only a single commodity is permitted per node","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: commodity and node","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"node__commodity is a two-dimensional relationship between a node and a commodity and specifies the commodity that flows to or from the node. Generally, since flows are not dimensioned by commodity, this has no meaning in terms of the variables and constraint equations. However, there are two specific uses for this relationship:","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"To specify that specific network physics should apply to the network formed by the member nodes for that commodity. See powerflow\nOnly connection flows that are between nodes of the same or no commodity are included in the node_balance constraint.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__investment_stochastic_structure-1","page":"Relationship Classes","title":"node__investment_stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"defines the stochastic structure for node related investments, currently only storages","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The node__investment_stochastic_structure relationship defines the stochastic_structure of node-related investment decisions. Essentially, it sets the stochastic_structure used by the storages_invested_available variable of the node.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The node__investment_stochastic_structure relationship uses the model__default_investment_stochastic_structure relationship if not defined.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__investment_temporal_block-1","page":"Relationship Classes","title":"node__investment_temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"defines the temporal resolution for node related investments, currently only storages","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"node__investment_temporal_block is a two-dimensional relationship between a node and a temporal_block. This relationship defines the temporal resolution and scope of a node's investment decisions (currently only storage invesments). Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__defaultinvestmenttemporal_block is specified and no node__investment_temporal_block relationship is specified, the model__defaultinvestmenttemporal_block relationship will be used. Conversely if node__investment_temporal_block is specified along with model__temporal_block, this will override model__defaultinvestmenttemporal_block for the specified node.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"See also investment_optimization","category":"page"},{"location":"concept_reference/Relationship Classes/#node__node-1","page":"Relationship Classes","title":"node__node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Holds parameters for direct interactions between two nodes, e.g. node_state diffusion coefficients.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: diff_coeff","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The node__node relationship is used for defining direct interactions between two nodes, like diffusion of commodity content. Note that the node__node relationship is assumed to be one-directional, meaning that","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"node__node(node1=n1, node2=n2) != node__node(node1=n2, node2=n1).","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Thus, when one wants to define symmetric relationships between two nodes, one needs to define both directions as separate relationships.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__stochastic_structure-1","page":"Relationship Classes","title":"node__stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which specific stochastic_structure is used by the node and all flow variables associated with it. Only one stochastic_structure is permitted per node.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The node__stochastic_structure relationship defines which stochastic_structure the node uses. Essentially, it sets the stochastic_structure of all the flow variables connected to the node, as well as the potential node_state variable. Note that only one stochastic_structure can be defined per node per model, as interpreted based on the node__stochastic_structure and model__stochastic_structure relationships. Investment variables use dedicated relationships, as detailed in the Investment Optimization section.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The node__stochastic_structure relationship uses the model__default_stochastic_structure relationship if not specified.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__temporal_block-1","page":"Relationship Classes","title":"node__temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the temporal_blocks used by the node and all the flow variables associated with it.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: cyclic_condition","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"This relationship links a node to a temporal_block and as such it will determine which temporal block governs the temporal horizon and resolution of the variables associated with this node. Specifically, the resolution of the temporal block will directly imply the time slices for which both the regular and ramping flow variables and their associated constraints are created.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"For a more detailed description of how the temporal structure in SpineOpt can be created, see Temporal Framework.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__unit_constraint-1","page":"Relationship Classes","title":"node__unit_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"specifying this relationship allows a node's demand or node_state to be included in the specified unit constraint","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and unit_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: demand_coefficient and node_state_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"node__unit_constraint is a two-dimensional relationship between a node and a unit_constraint. The relationship specifies that a variable associated only with the node (currently only the node_state) is involved in the constraint. For example, the nodestatecoefficient defined on node__unit_constraint specifies the coefficient of the node's node_state variable in the specified unit_constraint. ","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"See also unit_constraints","category":"page"},{"location":"concept_reference/Relationship Classes/#parent_stochastic_scenario__child_stochastic_scenario-1","page":"Relationship Classes","title":"parent_stochastic_scenario__child_stochastic_scenario","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the master stochastic direct acyclic graph, meaning how the stochastic_scenarios are related to each other.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: stochastic_scenario","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The parent_stochastic_scenario__child_stochastic_scenario relationship defines how the individual stochastic_scenarios are related to each other, forming what is referred to as the stochastic direct acyclic graph (DAG) in the Stochastic Framework section. It acts as a sort of basis for the stochastic_structures, but doesn't contain any Parameters necessary for describing how it relates to the Temporal Framework or the Objective function.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The parent_stochastic_scenario__child_stochastic_scenario relationship and the stochastic DAG it forms are crucial for Constraint generation with stochastic path indexing. Every finite stochastic DAG has a limited number of unique ways of traversing it, called full stochastic paths, which are used when determining how many different constraints need to be generated over time periods where stochastic_structures branch or converge, or when generating constraints involving different stochastic_structures. See the Stochastic Framework section for more information.","category":"page"},{"location":"concept_reference/Relationship Classes/#report__output-1","page":"Relationship Classes","title":"report__output","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Output object related to a report object are returned to the output database (if they appear in the model as variables)","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: output and report","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The report__output relationship tells which output variables to include in which report when writing SpineOpt output. Note that the reports also need to be connected to a model using the model__report relationship. Without appropriately defined model__report and report__output and relationships, SpineOpt doesn't write any output, so be sure to include at least one report connected to all the output variables of interest in the model!","category":"page"},{"location":"concept_reference/Relationship Classes/#stochastic_structure__stochastic_scenario-1","page":"Relationship Classes","title":"stochastic_structure__stochastic_scenario","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which stochastic_scenarios are included in which stochastic_structure, and holds the parameters required for realizing the structure in combination with the temporal_blocks.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: stochastic_scenario and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: stochastic_scenario_end and weight_relative_to_parents","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The stochastic_structure__stochastic_scenario relationship defines which stochastic_scenarios are included in which stochastic_structure, as well as holds the stochastic_scenario_end and weight_relative_to_parents Parameters defining how the stochastic_structure interacts with the Temporal Framework and the Objective function. Along with parent_stochastic_scenario__child_stochastic_scenario, this relationship is used to define the exact properties of each stochastic_structure, which are then applied to the objects describing the modelled system according to the Structural relationship classes, like the node__stochastic_structure relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__commodity-1","page":"Relationship Classes","title":"unit__commodity","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Holds parameters for commodities used by the unit?","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: commodity and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: max_cum_in_unit_flow_bound","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"To impose a limit on the cumulative amount of commodity flows, the max_cum_in_unit_flow_bound can be imposed on a unit__commodity relationship. This can be very helpful, e.g. if a certain amount of emissions should not be surpased throughout the optimization.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Note that, next to the unit__commodity relationship, also the nodes connected to the units need to be associated with their corresponding commodities, see node__commodity.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__from_node-1","page":"Relationship Classes","title":"unit__from_node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the nodes the unit can take input from, and holds most unit_flow variable specific parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: fix_nonspin_ramp_up_unit_flow, fix_nonspin_units_started_up, fix_nonspin_units_starting_up, fix_ramp_up_unit_flow, fix_start_up_unit_flow, fix_unit_flow_op, fix_unit_flow, fuel_cost, graph_view_position, max_res_shutdown_ramp, max_res_startup_ramp, max_shutdown_ramp, max_startup_ramp, min_res_shutdown_ramp, min_res_startup_ramp, min_shutdown_ramp, min_startup_ramp, minimum_operating_point, operating_cost, operating_points, ramp_down_costs, ramp_down_limit, ramp_up_costs, ramp_up_limit, res_start_up_cost, reserve_procurement_cost, unit_capacity, unit_conv_cap_to_flow and vom_cost","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The unit__to_node and unit__from_node unit relationships are core elements of SpineOpt. For each unit__to_node or unit__from_node, a unit_flow variable is automatically added to the model, i.e. a commodity flow of a unit to or from a specific node, respectively.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Various parameters can be defined on the unit__from_node relationship, in order to constrain the associated unit flows. In most cases a unit_capacity will be defined for an upper bound on the commodity flows. Apart from that, ramping abilities of a unit can be defined. For further details on ramps see Ramping and Reserves.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"To associate costs with a certain commodity flows, cost terms, such as fuel_costs and vom_costs, can be included for the unit__from_node relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"It is important to note, that the parameters associated with the unit__from_node can be defined either for a specific node, or for a group of nodes. Grouping nodes for the described parameters will result in an aggregation of the unit flows for the triggered constraint, e.g. the definition of the unit_capacity on a group of nodes will result in an upper bound on the sum of all individual unit_flows.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__from_node__unit_constraint-1","page":"Relationship Classes","title":"unit__from_node__unit_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which input unit_flows are included in the unit_constraint, and holds their parameters?","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node, unit_constraint and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: graph_view_position and unit_flow_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"unit__from_node__unit_constraint is a three-dimensional relationship between a unit, a node and a unit_constraint. The relationship specifies that the unit_flow variable to the specified unit from the specified node is involved in the specified unit_constraint. Parameters on this relationship generally apply to this specific unit_flow variable. For example the parameter unitflowcoefficient defined on unit__from_node__unit_constraint represents the coefficient on the specific unit_flow variable in the specified unit_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__investment_stochastic_structure-1","page":"Relationship Classes","title":"unit__investment_stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Sets the stochastic structure for investment decisions - overrides model__default_investment_stochastic_structure. TODO: THIS RELATIONSHIP DOESN'T CURRENTLY APPEAR IN THE MODEL!","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: stochastic_structure and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__investment_temporal_block-1","page":"Relationship Classes","title":"unit__investment_temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Sets the temporal resolution of investment decisions - overrides model__default_investment_temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: temporal_block and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"unit__investment_temporal_block is a two-dimensional relationship between a unit and a temporal_block. This relationship defines the temporal resolution and scope of a unit's investment decision. Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__defaultinvestmenttemporal_block is specified and no unit__investment_temporal_block relationship is specified, the model__defaultinvestmenttemporal_block relationship will be used. Conversely if unit__investment_temporal_block is specified along with model__temporal_block, this will override model__defaultinvestmenttemporal_block for the specified unit.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"See also investment_optimization","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__node__node-1","page":"Relationship Classes","title":"unit__node__node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Holds parameters spanning multiple unit_flow variables to and from multiple nodes.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: fix_ratio_in_in_unit_flow, fix_ratio_in_out_unit_flow, fix_ratio_out_in_unit_flow, fix_ratio_out_out_unit_flow, fix_units_on_coefficient_in_in, fix_units_on_coefficient_in_out, fix_units_on_coefficient_out_in, fix_units_on_coefficient_out_out, max_ratio_in_in_unit_flow, max_ratio_in_out_unit_flow, max_ratio_out_in_unit_flow, max_ratio_out_out_unit_flow, max_units_on_coefficient_in_in, max_units_on_coefficient_in_out, max_units_on_coefficient_out_in, max_units_on_coefficient_out_out, min_ratio_in_in_unit_flow, min_ratio_in_out_unit_flow, min_ratio_out_in_unit_flow, min_ratio_out_out_unit_flow, min_units_on_coefficient_in_in, min_units_on_coefficient_in_out, min_units_on_coefficient_out_in, min_units_on_coefficient_out_out, unit_idle_heat_rate, unit_incremental_heat_rate and unit_start_flow","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"While the relationships unit__to_node and unit__to_node take care of the automatic generation of the unit_flow variables, the [unit__node__node] relationships hold the information how the different commodity flows of a unit interact. Only through this relationship and the associated parameters, the topology of a unit, i.e. which intakes lead to which porducts etc., becomes unambiguous.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"In almost all cases, at least one of the ..._ratio_... parameters will be defined, e.g. to set a fixed ratio between outgoing and incoming commodity flows of unit (see also e.g. fix_ratio_out_in_unit_flow). Note that the parameters can also be defined on a relationship between groups of objects, e.g. to force a fixed ratio between a group of nodes. In the triggered constraints, this will lead to an aggregation of the individual unit flows.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__to_node-1","page":"Relationship Classes","title":"unit__to_node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the nodes the unit can output to, and holds most unit_flow variable specific parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: fix_nonspin_ramp_down_unit_flow, fix_nonspin_ramp_up_unit_flow, fix_nonspin_units_shut_down, fix_nonspin_units_started_up, fix_nonspin_units_starting_up, fix_ramp_down_unit_flow, fix_ramp_up_unit_flow, fix_shut_down_unit_flow, fix_start_up_unit_flow, fix_unit_flow_op, fix_unit_flow, fuel_cost, graph_view_position, max_res_shutdown_ramp, max_res_startup_ramp, max_shutdown_ramp, max_startup_ramp, min_res_shutdown_ramp, min_res_startup_ramp, min_shutdown_ramp, min_startup_ramp, minimum_operating_point, operating_cost, operating_points, ramp_down_cost, ramp_down_limit, ramp_up_cost, ramp_up_limit, res_start_up_cost, reserve_procurement_cost, unit_capacity, unit_conv_cap_to_flow and vom_cost","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The unit__to_node and unit__from_node unit relationships are core elements of SpineOpt. For each unit__to_node or unit__from_node, a unit_flow variable is automatically added to the model, i.e. a commodity flow of a unit to or from a specific node, respectively.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Various parameters can be defined on the unit__to_node relationship, in order to constrain the associated unit flows. In most cases a unit_capacity will be defined for an upper bound on the commodity flows. Apart from that, ramping abilities of a unit can be defined. For further details on ramps see Ramping and Reserves.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"To associate costs with a certain commodity flows, cost terms, such as fuel_costs and vom_costs, can be included for the unit__to_node relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"It is important to note, that the parameters associated with the unit__to_node can be defined either for a specific node, or for a group of nodes. Grouping nodes for the described parameters will result in an aggregation of the unit flows for the triggered constraint, e.g. the definition of the unit_capacity on a group of nodes will result in an upper bound on the sum of all individual unit_flows.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__to_node__unit_constraint-1","page":"Relationship Classes","title":"unit__to_node__unit_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which output unit_flows are included in the unit_constraint, and holds their parameters?","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node, unit_constraint and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: graph_view_position and unit_flow_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"unit__to_node__unit_constraint is a three-dimensional relationship between a unit, a node and a unit_constraint. The relationship specifies that the unit_flow variable from the specified unit to the specified node is involved in the specified unit_constraint. Parameters on this relationship generally apply to this specific unit_flow variable. For example the parameter unitflowcoefficient defined on unit__to_node__unit_constraint represents the coefficient on the specific unit_flow variable in the specified unit_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__unit_constraint-1","page":"Relationship Classes","title":"unit__unit_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which units_on variables are included in the unit_constraint, and holds their parameters?","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: unit_constraint and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: units_on_coefficient and units_started_up_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"unit__unit_constraint is a two-dimensional relationship between a unit and a unit_constraint. The relationship specifies that a variable or variable(s) associated only with the unit (not a unit_flow for example) are involved in the constraint. For example, the unitsoncoefficient defined on unit__unit_constraint specifies the coefficient of the unit's units_on variable in the specified unit_constraint. ","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"See also unit_constraints","category":"page"},{"location":"concept_reference/Relationship Classes/#units_on__stochastic_structure-1","page":"Relationship Classes","title":"units_on__stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which specific stochastic_structure is used for the units_on variable of the unit. Only one stochastic_structure is permitted per unit.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: stochastic_structure and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The units_on__stochastic_structure relationship defines the stochastic_structure used by the units_on variable. Essentially, this relationship permits defining a different stochastic_structure for the online decisions regarding the units_on variable, than what is used for the production unit_flow variables. A common use-case is e.g. using only one units_on variable across multiple stochastic_scenarios for the unit_flow variables. Note that only one units_on__stochastic_structure relationship can be defined per unit per model, as interpreted by the units_on__stochastic_structure and model__stochastic_structure relationships.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"The units_on__stochastic_structure relationship uses the model__default_stochastic_structure relationship if not specified.","category":"page"},{"location":"concept_reference/Relationship Classes/#units_on__temporal_block-1","page":"Relationship Classes","title":"units_on__temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which specific temporal_blocks are used by the units_on variable of the unit.","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: temporal_block and unit","category":"page"},{"location":"concept_reference/Relationship Classes/#","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/has_state/#","page":"-","title":"-","text":"The has_state parameter is simply a Bool flag for whether a node has a node_state variable. By default, it is set to false, so the nodes enforce instantaneous commodity balance according to the nodal balance and node injection constraints. If set to true, the node will have a node_state variable generated for it, allowing for commodity storage at the node. Note that you'll also have to specify a value for the state_coeff parameter, as otherwise the node_state variable has zero commodity capacity.","category":"page"},{"location":"concept_reference/unit__commodity/#","page":"-","title":"-","text":"To impose a limit on the cumulative amount of commodity flows, the max_cum_in_unit_flow_bound can be imposed on a unit__commodity relationship. This can be very helpful, e.g. if a certain amount of emissions should not be surpased throughout the optimization.","category":"page"},{"location":"concept_reference/unit__commodity/#","page":"-","title":"-","text":"Note that, next to the unit__commodity relationship, also the nodes connected to the units need to be associated with their corresponding commodities, see node__commodity.","category":"page"},{"location":"concept_reference/model/#","page":"-","title":"-","text":"The model object holds general information about the optimization problem at hand. Firstly, the modelling horizon is specified on the model object, i.e. the scope of the optimization model, and if applicable the duration of the rolling window (see also model_start, model_end and roll_forward). Secondly, the model works as an overarching assembler - only through linking temporal_blocks and stochastic_structures to a model object via relationships, they become part of the optimization problem, and respectively linked nodes, connections and units. If desired the user can also specify defaults for temporals and stochastic via the designated default relationships (see e.g., model__default_temporal_block. In this case, the default temporal is populated for missing node__temporal_block relationships.  Lastly, the model object contains information about the algorithm used for solving the problem (see model_type).","category":"page"},{"location":"concept_reference/storage_investment_cost/#","page":"-","title":"-","text":"By defining the storage_investment_cost parameter for a specific node, a cost term will be added to the objective function whenever a storage investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/connection__node__node/#","page":"-","title":"-","text":"connection__node__node is a three-dimensional relationship between a connection, a node (node 1) and another node (node 2). connection__node__node infers a conversion and a direction with respect to that conversion. Node 1 is assumed to be the input node and node 2 is assumed to be the output node. For example, the fixratiooutinconnection_flow parameter defined on connection__node__node relates the output connection_flow to node 2 to the intput connection_flow from node 1","category":"page"},{"location":"concept_reference/node_state_cap/#","page":"-","title":"-","text":"The node_state_cap parameter represents the maximum allowed value for the node_state variable. Note that in order for a node to have a node_state variable in the first place, the has_state parameter must be set to true. However, if the node has storage investments enabled using the candidate_storages parameter, the node_state_cap parameter acts as a coefficient for the storages_invested_available variable. Essentially, with investments, the node_state_cap parameter represents storage capacity per storage investment.","category":"page"},{"location":"concept_reference/operating_points/#","page":"-","title":"-","text":"If operating_points if defined as an array type on a certain unit__to_node or unit__from_node flow, the corresponding unit_flow flow variable is decomposed into a number of sub operating segment variables, unit_flow_op one for each operating segment, with an additional index, i to reference the specific operating segment. Each value in the array represents the upperbound of the operating segment, normalized on unitcapacity for the corresponding `unit__tonodeorunit__fromnodeflow.operatingpointsis used in conjunction with [unit\\_incremental\\_heat\\_rate](@ref) where the array dimension must match and is used to define the normalized operating point bounds for the corresponding incremental heat rate.operatingpoints` is also used in conjunction with [unit\\constraints](@ref) where the array dimension must match any corrponding piecewise linear unit_flow_coefficient. Here operating_points is used also to define the normalized operating point bounds for the corresponding unit_flow_coefficients.","category":"page"},{"location":"concept_reference/operating_points/#","page":"-","title":"-","text":"Note that operating_points is defined on a capacity-normalized basis and the values represent the upper bound of the corresponding operating segment variable. So if operating_points is specified as [0.5, 1], this creates two operating segments, one from zero to 50% of the corresponding unit_capacity and a second from 50% to 100% of the corresponding unit_capacity.","category":"page"},{"location":"concept_reference/tax_out_unit_flow/#","page":"-","title":"-","text":"By defining the tax_out_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with all unit_flow variables with direction from_node over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/connection_emergency_capacity/#","page":"-","title":"-","text":"The connection_emergency_capacity parameter represents the maximum post-contingency flow on a monitored connection if ptdf and lodf based security constrained unit commitment is enabled (commodity_physics is set to [commodity_physics_lodf].)","category":"page"},{"location":"concept_reference/connection_emergency_capacity/#","page":"-","title":"-","text":"If you set this value, make sure that you also set connection_monitored to true for the involved connection.","category":"page"},{"location":"concept_reference/unit_investment_variable_type_list/#","page":"-","title":"-","text":"unit_investment_variable_type_list holds the possible values for the type of a unit's investment variable which may be chosen from integer, binary or continuous. ","category":"page"},{"location":"concept_reference/min_ratio_out_in_connection_flow/#","page":"-","title":"-","text":"The definition of the min_ratio_out_in_connection_flow parameter triggers the generation of the constraint_min_ratio_out_in_connection_flow and sets a lower bound on the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class connection__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the connection, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the connection.","category":"page"},{"location":"concept_reference/min_ratio_out_in_connection_flow/#","page":"-","title":"-","text":"Note that the ratio can also be defined for connection__node__node relationships, where one or both of the nodes correspond to node groups in order to impose a ratio on aggregated connection flows.","category":"page"},{"location":"concept_reference/min_ratio_out_in_connection_flow/#","page":"-","title":"-","text":"To enforce e.g. a minimum ratio of 0.2 for a connection conn between its outgoing electricity flow to node commodity1 and its incoming flows from the node node commodity2, the min_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship conn__commodity1__commodity2.","category":"page"},{"location":"concept_reference/connection_flow_cost/#","page":"-","title":"-","text":"By defining the connection_flow_cost parameter for a specific connection, a cost term will be added to the objective function that values all connection_flow variables associated with that connection during the current optimization window.","category":"page"},{"location":"concept_reference/commodity_lodf_tolerance/#","page":"-","title":"-","text":"Given two connections, the line outage distribution factor (LODF) is the fraction of the pre-contingency flow on the first one, that will flow on the second after the contingency. commodity_lodf_tolerance is the minimum absolute value of the LODF that is considered meaningful. Any value below this tolerance (in absolute value) will be treated as zero.","category":"page"},{"location":"concept_reference/commodity_lodf_tolerance/#","page":"-","title":"-","text":"The LODFs are used to model contingencies on some connections and their impact on some other connections. To model contingencies on a connection, set connection_contingency to true; to study the impact of such contingencies on another connection, set connection_monitored to true.","category":"page"},{"location":"concept_reference/commodity_lodf_tolerance/#","page":"-","title":"-","text":"In addition, define a commodity with commodity_physics set to commodity_physics_lodf, and associate that commodity (via node__commodity) to both connections' nodes (given by connection__to_node and connection__from_node).","category":"page"},{"location":"concept_reference/roll_forward/#","page":"-","title":"-","text":"This parameter defines how much the optimization window rolls forward in a rolling horizon optimization and should be expressed as a duration. In a rolling horizon optimization, a (small) part of the model is optimized at each iteration, after which the window rolls forward to optimize a different part. Overlap between consecutive optimization windows is possible. In the practical approaches presented in Temporal Framework, the rolling window optimization will be explained in more detail. The default value of this parameter is the entire model time horizon, which leads to a single optimization for the entire time horizon.","category":"page"},{"location":"concept_reference/model__stochastic_structure/#","page":"-","title":"-","text":"The [model__stochastic_structure] relationship defines which stochastic_structures are active in which models. Essentially, this relationship allows for e.g. attributing multiple node__stochastic_structure relationships for a single node, and switching between them in different models. Any stochastic_structure in model__default_stochastic_structure is automatically assumed to be active in the connected model, so there's no need to include it in [model__stochastic_structure] separately.","category":"page"},{"location":"concept_reference/unit__from_node__unit_constraint/#","page":"-","title":"-","text":"unit__from_node__unit_constraint is a three-dimensional relationship between a unit, a node and a unit_constraint. The relationship specifies that the unit_flow variable to the specified unit from the specified node is involved in the specified unit_constraint. Parameters on this relationship generally apply to this specific unit_flow variable. For example the parameter unitflowcoefficient defined on unit__from_node__unit_constraint represents the coefficient on the specific unit_flow variable in the specified unit_constraint","category":"page"},{"location":"advanced_concepts/powerflow/#ptdf-based-powerflow-1","page":"Power transfer distribution factors (PTDF) based DC power flow","title":"Power transfer distribution factors (PTDF) based DC power flow","text":"","category":"section"},{"location":"advanced_concepts/powerflow/#","page":"Power transfer distribution factors (PTDF) based DC power flow","title":"Power transfer distribution factors (PTDF) based DC power flow","text":"There are two main methodologies for directly including DC powerflow in unit commitment/energy system models. One method is to directly include the bus voltage angles as variables in the model. This method is described in Angle-Based DC Powerflow.","category":"page"},{"location":"advanced_concepts/powerflow/#","page":"Power transfer distribution factors (PTDF) based DC power flow","title":"Power transfer distribution factors (PTDF) based DC power flow","text":"Here we discuss the method of using power transfer distribution factors (PTDF) for DC power flow and line outage distribution factors for security constrained distribution factors.","category":"page"},{"location":"advanced_concepts/powerflow/#key-concepts-advanced-ptdf-DC-1","page":"Power transfer distribution factors (PTDF) based DC power flow","title":"Key concepts","text":"","category":"section"},{"location":"advanced_concepts/powerflow/#","page":"Power transfer distribution factors (PTDF) based DC power flow","title":"Power transfer distribution factors (PTDF) based DC power flow","text":"ptdf: The power transfer distribution factors are a property of the network reactances and their derivation may be found here. ptdf(n, c) represents the fraction of an injection at node n that will flow on connection c. The flow on connection c is then the sum over all nodes of ptdf(n, c)*net_injection(c). The advantage of this method is that is introduces no additional variables into the problem and instead, introduces only one constraint for each connection whose flow we are interested in monitoring.\nlodf: Line outage distribution factors are a function of the network ptdfs and their derivation is also found here. lodf(ccontingency, cmonitored) represents the fraction of the pre-contingency flow on connection ccontingency that will flow on cmonitored if ccontingency is disconnected. Therefore, the post contingency flow on connection cmonitored is the precontingency flow plus lodf(ccontingency, cmonitored)*precontingencyflow(ccontingency)). Therefore, consideration of N contingencies on M monitored lines introduces N x M constraints into the model. Usually one wishes to contain this number and methods are given below to achieve this.\nDefining your network To identify the network for which ptdfs, lodfs and connection_flows will be calculated according to the ptdf method, one does the following:\nCreate node objects for each bus in the model.\nCreate connection objects representing each line of the network: For each connection specify the connection_reactance parameter and the connection_type parameter. Setting connection_type=connection_type_lossless_bidirectional simplifies the amount of data that needs to be specified for an eletrical network. See connection_type for more details   \nSet the connection__to_node and connection__from_node relationships to define the topology of each connection along with the connection_capacity parameter on one or both of these relationships.\nSet the connection_emergency_capacity parameter to define the post contingency rating if lodf-based N-1 security constraints are to be included\nCreate a commodity object and node__commodity relationships for all the nodes that comprise the electrical network for which PTDFs are to be calculated.\nSpecify the commodity_physics parameter for the commodity to :commodity_physics_ptdf if ptdf-based DC load flow is desired with no N-1 security constraints or to :commodity_physics_lodf if it is desred to include lodf-based N-1 security constraints\nTo identify the reference bus(node) specify the nodeopftype parameter for the appropriate node with the value node_opf_type_reference.\nControlling problem size","category":"page"},{"location":"advanced_concepts/powerflow/#","page":"Power transfer distribution factors (PTDF) based DC power flow","title":"Power transfer distribution factors (PTDF) based DC power flow","text":"The lines to be monitored are specified by setting the connection_monitored property for each connection for which a flow constraint is to be generated\nThe contingencies to be considered are specified by setting the connection_contingency property for the appropriate connections. For N contingencies and M monitored lines, N x M constraints will be generated.\nIf the lodf(ccontingency, cmonitored) is very small, it means the outage of ccontingency has a small impact on the flow on cmonitored and there is little point in including this constraint in the model. This can be achieved by setting the commodity_lodf_tolerance commodity parameter. Contingency / Monotired line combinations with lodfs below this value will be ignored, reducing the size of the model.\nIf ptdf(n, c) is very small, it means an injection at n has a small impact on the flow on c and there is little point in considering it. This can be achieved by setting the commodity_ptdf_threshold commodity parameter. Node / Monotired line combinations with ptdfs below this value will be ignored, reducing the number of coefficients in the model.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/#pressure-driven-gas-transfer-1","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"","category":"section"},{"location":"advanced_concepts/pressure_driven_gas_transfer/#","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"The generic formulation of SpineOpt is based on a trade based model. However, network physics can be different depending on the traded commodity. This chapter specifically addresses the use of pressure driven gas transfer models and enabling linepack flexibility in SpineOpt. To this date, investments in pressure driven pipelines are not yet supported within SpineOpt. The use of multiple feed-in nodes, e.g. to represent multiple commodity flows through a pipeline is not yet supported.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/#","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"For the representation of pressure driven gas transfer, we use the MILP formulation, as described in Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling. Here, the non-linearities associated with the Weymouth equation are convexified through an outer approximation of the Weymouth equation through fixed pressure points.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/#key-concepts-advanced-gas-1","page":"Pressure driven gas transfer","title":"Key concept","text":"","category":"section"},{"location":"advanced_concepts/pressure_driven_gas_transfer/#","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"Here, we briefly describe the key objects and relationships required to model pressure driven gas transfers in SpineOpt.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/#","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"connection: A connection represents the gas pipeline being modelled. Usually the direction of flow is not known a priory. To ensure that the flow through the gas pipeline is unidirectional, the parameter connection_binary_gas_flow needs to be set to true.\nnode: Nodes with different characteristics are used for the representation of pressure driven gas transfer.\nFor each connection, there will be two nodes representing the start and end point of the pipeline. Associated with these nodes are the parameter the following parameter: the has_pressure parameter, which needs to be set to true, in order to create the variable node_pressure; the max_node_pressure and min_node_pressure to constrain the pressure variable.\nTo leverage linepack flexibility, a third node is introduced representing the linepack storage of the pipeline. To trigger the storage linepack and hence, v_{node_state_variables}the has_state parameter needs to be set to true.\nconnection__to_node and connection__from_node To enable flows through the pipeline and into the linepack storage, each node has to have both these relationships in common with the connection pipeline. These relationships will trigger the generation of v_{connection_flow} variables in all possible directions.\nconnection__node__node This relationship is key to the pressure driven gas transfer, holding the information about the pipeline characteristics and bringing the elements into interaction.\nThe parameter connection_linepack_constant holds the linepack constant and triggers the generation of the line pack storage constraint. Note that the first node should be the linepack storage node, while the second node should be a node_group of both, the start and the end node of the pipeline.\nThe linearization of the Weymouth equation through outer approximation relies on the use of fixed pressure points. For this purpose, the two parameters fixed_pressure_constant_1 and fixed_pressure_constant_0 hold the fixed pressure constants and trigger the generation of the constraint_fix_node_pressure_point. The constraint introduces the relationship between pressure and gas flows. Note, that the pressure constants should be entered in a way, that the first node represents the origin node, the second node the destination node. Each connection should have a connection__node__node to each combination of its start and end nodes (and associated parameters). (See Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling)\nBy default, pipelines are considered to be passive. However, a compression station between to pipeline pressure nodes can be represented by defining a compression_factor. The relationship should be defined in such a manner, that the first node represents the sending node, the second node represents the receiving node, which pressure is equal or smaller to the pressure at the sending node times the compression factor.\nLastly, to ensure the balance between incoming/outgoing flows and flows into the linepack, the ratio between the flows need to be fixed. The average incoming flows of the node group (of the pressure start and end nodes) have to equal the flows into the linepack storage, and vice versa. Therefore, the fix_ratio_out_in_connection_flow needs to be set to a value (typically 1) for the (pressure group, linepack storage) node pair, and for the (pressure group,linepack storage) node pair.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/#","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"A complete mathematical formulation can be found here","category":"page"},{"location":"concept_reference/block_start/#","page":"-","title":"-","text":"Indicates the start of this temporal block. The main use of this parameter is to create an offset from the model start. The default value is equal to a duration of 0. It is useful to distinguish here between two cases: a single solve, or a rolling window optimization.","category":"page"},{"location":"concept_reference/block_start/#","page":"-","title":"-","text":"single solve When a Date time value is chosen, this is directly the start of the optimization for this temporal block. When a duration is chosen, it is added to the model_start to obtain the start of this temporal_block. In the case of a duration, the chosen value directly marks the offset of the optimization with respect to the model_start. The default value for this parameter is the model_start.","category":"page"},{"location":"concept_reference/block_start/#","page":"-","title":"-","text":"rolling window optimization To create a temporal block that is rolling along with the optimization window, a rolling temporal block, a duration value should be chosen. The temporal block_start will again mark the offset of the optimization start but now with respect to the start of each optimization window.","category":"page"},{"location":"concept_reference/block_start/#","page":"-","title":"-","text":"To create a static temporal block, that has a fixed block_start (and block_end) and does not move along with the rolling window but rather splats into the rolling window, once the rolling window hits the start of the static temporalblock, the `blockstartparameter needs to be defined as aDateTime` value. #TODO: this is not supported yet!","category":"page"},{"location":"concept_reference/min_units_on_coefficient_out_in/#","page":"-","title":"-","text":"The min_units_on_coefficient_out_in parameter is an optinal coefficient in the unit output-input ratio constraint controlled by the min_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_out_in/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_in_out, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_out_in and fix_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/max_ratio_out_in_connection_flow/#","page":"-","title":"-","text":"The definition of the max_ratio_out_in_connection_flow parameter triggers the generation of the constraint_max_ratio_out_in_connection_flow and sets an upper bound on the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class connection__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the connection, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the connection.","category":"page"},{"location":"concept_reference/max_ratio_out_in_connection_flow/#","page":"-","title":"-","text":"Note that the ratio can also be defined for connection__node__node relationships, where one or both of the nodes correspond to node groups in order to impose a ratio on aggregated connection flows.","category":"page"},{"location":"concept_reference/max_ratio_out_in_connection_flow/#","page":"-","title":"-","text":"To enforce e.g. a maximum ratio of 0.8 for a connection conn between its outgoing electricity flow to node commodity1 and its incoming flows from the node node commodity2, the max_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship conn__commodity1__commodity2.","category":"page"},{"location":"concept_reference/boolean_value_list/#","page":"-","title":"-","text":"A list of boolean values (True or False).","category":"page"},{"location":"concept_reference/frac_state_loss/#","page":"-","title":"-","text":"The frac_state_loss parameter allows setting self-discharge losses for nodes with the node_state variables enabled using the has_state variable. Effectively, the frac_state_loss parameter acts as a coefficient on the node_state variable in the node injection constraint, imposing losses for the node. In simple cases, storage losses are typically fractional, e.g. a frac_state_loss parameter value of 0.01 would represent 1% of node_state lost per unit of time. However, a more general definition of what the frac_state_loss parameter represents in SpineOpt would be loss power per unit of node_state.","category":"page"},{"location":"concept_reference/unit_capacity/#","page":"-","title":"-","text":"To set an upper bound on the commodity flow of a unit in a certain direction, the unit_capacity constraint needs to be defined on a unit__to_node or unit__from_node relationship. By defining the parameter, the unit_flow variables to or from a node or a group of nodes will be constraint by the capacity constraint.","category":"page"},{"location":"concept_reference/unit_capacity/#","page":"-","title":"-","text":"Note that if the unit_capacity parameter is defined on a node group, the sum of all unit_flows within the specified node group will be constrained by the unit_capacity.","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"SpineOpt.jl is an integrated energy systems optimization model created as part of the  Spine project, striving towards adaptability for a multitude of modelling purposes. The data-driven model structure allows for highly customizable energy system descriptions, as well as flexible temporal and stochastic structures, without the need to alter the model source code directly. The methodology is based on mixed-integer linear programming (MILP), and SpineOpt relies on JuMP.jl for interfacing with the different solvers.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"While, in principle, it is possible to run SpineOpt by itself, it has been designed to be used through the Spine toolbox, and take maximum advantage of the data and modelling workflow management tools therein. Thus, we highly recommend installing Spine toolbox as well, as outlined in the Installation guide.","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"In order to make it easier for you to familiarize yourself with the documentation, here's a list of all the different chapters, as well as descriptions of what they're about.","category":"page"},{"location":"#Getting-Started-1","page":"Introduction","title":"Getting Started","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"As the name implies, this chapter contains guides for starting to use SpineOpt.jl for the first time. The Installation section contains a step-by-step guide for how to install SpineOpt.jl and Spine Toolbox on your computer. The Running an Optimization section explains how to run SpineOpt.jl for a simple example system with and without Spine Toolbox, so that you can get a feel for what SpineOpt.jl does, as well as have a simple template to start messing with. The Creating Your Own Model section explains how to create a new model from scratch. This includes a list of the necessary Object Classes and  Relationship Classes, but for more information, you will probably need to consult the Concept Reference chapter.","category":"page"},{"location":"#Concept-Reference-1","page":"Introduction","title":"Concept Reference","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This chapter lists and explains all the important data and model structure related concepts to understand in SpineOpt.jl. For a mathematical modelling point of view, see the Mathematical Formulation chapter instead. Basics of the model structure section briefly explains the general purpose of the most important concepts, like Object Classes and Relationship Classes. Meanwhile, the Object Classes, Relationship Classes, Parameters, and Parameter Value Lists sections contain detailed explanations of each an every aspect of SpineOpt.jl, organized into the respective sections for clarity.","category":"page"},{"location":"#Mathematical-Formulation-1","page":"Introduction","title":"Mathematical Formulation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This chapter provides the mathematical view of SpineOpt.jl, as some of the methodology-related aspects of the model are more easily understood as math than Julia code. The Variables section explains the purpose of each variable in the model, as well as how the variables are related to the different Object Classes and Relationship Classes. The Constraints section contains the mathematical formulation of each constraint, as well as explanations to their purpose and how they are controlled via different Parameters. Finally, the Objective section explains the default objective function used in SpineOpt.jl.","category":"page"},{"location":"#Advanced-Concepts-1","page":"Introduction","title":"Advanced Concepts","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This chapter explains some of the more complicated aspects of SpineOpt.jl in more detail, hopefully making it easier for you to better understand and apply them in your own modelling. The Temporal Framework section explains how defining time works in SpineOpt.jl, and how it can be used for different purposes. The Stochastic Framework section details how different stochastic structures can be defined, how they interact with each other, and how this impacts writing Constraints in SpineOpt.jl. Finally, the Investment Optimization section explains how to enable investment variables in your models.","category":"page"},{"location":"concept_reference/output/#","page":"-","title":"-","text":"An output is essentially a handle for a SpineOpt variable to be included in a report and written into an output database. Typically, e.g. the unit_flow variables are desired as output from most models, so creating an output object called unit_flow allows one to designate it as something to be written in the desired report. Note that unless appropriate model__report and report__output relationships are defined, SpineOpt doesn't write any output!","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Ramping-and-Reserves-1","page":"Ramping and reserves","title":"Ramping and Reserves","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"To enable the representation of units with a high level of technical detail, the ramping ability of units can be constrained in SpineOpt. This means that the user has the freedom to impose restrictions on the change in output of units between consecutive timesteps, for online (spinning) units, units starting up and units shutting down. In this section, the concept of ramps in SpineOpt will be introduced. Furthermore, the use of reserves will be explained.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Relevant-objects,-relationships-and-parameters-1","page":"Ramping and reserves","title":"Relevant objects, relationships and parameters","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"Everything that is related to ramping is defined in parameters of either the unit__to_node, unit__from_node, or unit__to_node_group relationship. Generally speaking, the ramping constraints will impose restrictions on the change in the unit_flow variable between two consecutive timesteps.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"All parameters that limit the ramping abilities of a unit are expressed as a fraction of the unit capacity. This means that a value of 1 indicates the full capacity of a unit.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"The discussion here will be kept conceptual, for the mathematical formulation the reader is referred to the Ramping and reserve constraints","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Constraining-spinning-ramps-(would-probably-name-this-one-first,-as-maybe-most-familiar-to-people)-1","page":"Ramping and reserves","title":"Constraining spinning ramps (would probably name this one first, as maybe most familiar to people)","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"unit_capacity: limit the maximum value of the unit_flow variable for a unit which is currently online. Inclusion of this parameter will trigger the creation of the Define unit/technology capacity constraint.\nramp_up_limit : limit the maximum increase in the unit_flow variable between two consecutive timesteps for which the unit is online. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on spinning upwards ramp_up\nramp_down_limit : limit the maximum decrease in the unit_flow variable between two consecutive timesteps for which the unit is online. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on spinning downward ramps","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"ramp_up_cost : cost associated with upward ramping\nramp_down_cost : cost associated with downward ramping","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Constraining-shutdown-ramps-1","page":"Ramping and reserves","title":"Constraining shutdown ramps","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"max_shutdown_ramp : limit the maximum of the unit_flow variable the timestep right before a shutdown. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on downward shut down ramps\nmin_shutdown_ramp : limit the minimum of the unit_flow variable the timestep right before a shutdown. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on downward shut down ramps","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Constraining-startup-ramps-1","page":"Ramping and reserves","title":"Constraining startup ramps","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"max_startup_ramp : limit the maximum of the unit_flow variable the timestep right after a start-up. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on upward start up ramp_up\nmin_startup_ramp : limit the minimum of the unit_flow variable the timestep right after a start-up. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on upward start up ramp_up","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#General-principle-and-example-use-cases-1","page":"Ramping and reserves","title":"General principle and example use cases","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"The general principle of the Spine modelling ramping constraints is that all of these parameters can be defined separately for each unit. This allows the user to incorporate different units (which can either represent a single unit or a technology type) with different flexibility characteristics.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"It should be noted that it is perfectly possible to omit all of the constraining parameters mentioned above. However, once either of the ramping parameters is defined, it is necessary to also assign values to the other parameters. E.g. if a user only wants to restrict the spinning ramp up capability of a unit, one also has to assign values to the max_startup_ramp, min_Shutdown_Ramp etc.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Illustrative-examples-1","page":"Ramping and reserves","title":"Illustrative examples","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#Step-1:-Simple-case-of-unrestricted-unit-1","page":"Ramping and reserves","title":"Step 1: Simple case of unrestricted unit","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"When none of the ramping parameters mentioned above are defined, the unit is considered to have full ramping flexibility. This means that in any given timestep, its output can be any value between 0 and its capacity, regardless of what the output of the unit was in the previous timestep, and regardless of the on- or offline status or the unit in the previous timestep. Provided that this does not conflict with the Unit commitment restrictions that are defined for this unit. Parameter values for a unit__node relationship are illustratively given below.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"max_shutdown_ramp  : 1\nmin_shutdown_ramp  : 0\nmax_start_up_ramp  : 1\nmin_start_up_ramp  : 0\nramp_up_limit      : 1\nramp_down_limit    : 1\nunit_capacity      : 200","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Step-2:-Spinning-ramp-restriction-1","page":"Ramping and reserves","title":"Step 2: Spinning ramp restriction","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"A unit which is only restricted in spinning ramping can be created by changing the ramp_up/down_limit parameters: (btw, I like this example!)","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"ramp_up_limit      : 0.2\nramp_down_limit    : 0.4","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"This parameter choice implies that the unit's output between two consecutive timesteps can change with no more than 02  * 200 and no less than 04 * 200. For example, when the unit is running at an output of 100 in some timestep t, its output for the next timestep must be somewhere in the interval 20140. Unless it shuts down completely.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Step-3:-Shutdown-restrictions-1","page":"Ramping and reserves","title":"Step 3: Shutdown restrictions","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"By changing the parameter max_shutdown_ramp in the previous example, an additional restriction is imposed on the maximum output of the unit from which it can go offline.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"max_shutdown_ramp      : 0.5\nmax_shutdown_ramp    :   0.3","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"When this unit goes offline in a given timestep t+1, the output of the unit must be below 05*200 = 100 in the timestep t before that.  Similarly, the parameter min_shutdown_ramp can be used to impose a minimum output value in the timestep  before a shutdown. For example, a value of 03 in this example would mean that the unit can not be running below an output of 60 in timestep t.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Step-4:-Startup-restrictions-1","page":"Ramping and reserves","title":"Step 4: Startup restrictions","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"The startup restrictions are very similar to the shutdown restrictions, but of course apply to units that are starting up. Consider for example the same unit as in the example above, but now with a max_start_up_ramp equal to 04 and min_start_up_ramp equal to 02:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"max_start_up_ramp      : 0.4\nmin_start_up_ramp    :   0.2","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"When the unit is offline in timestep t and comes online in timestep t+1, its output in timestep t+1 will be restricted to the interval 4080.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Reserve-concept-1","page":"Ramping and reserves","title":"Reserve concept","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"To include a requirement of reserve provision in a model, SpineOpt offers the possibility of creating reserve nodes. Of course reserve provision is different from regular operation, because the reserved capacity does not actually get activated. In this section, we will take a look at the things that are particular for a reserve node.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Defining-a-reserve-node-1","page":"Ramping and reserves","title":"Defining a reserve node","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"To define a reserve node, the following parameters have to be defined for the relevant node:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"is_reserve_node  : this boolean parameter indicates that this node is a reserve node.\nupward_reserve  : this boolean parameter indicates that the demand for reserve provision of this node concerns upward reserves.\ndownward_reserve  : this boolean parameter indicates that the demand for reserve provision of this node concerns downward reserves.\nbalance_type: this parameter indicates the balance_type of the node\nreserve_procurement_cost: (optional) to be checked how this enters the calculation, I can't see it in the objective","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Defining-a-node-group-1","page":"Ramping and reserves","title":"Defining a node group","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"SpineOpt allows the user to constrain ramping abilities of units that are linked to multiple nodes by defining node groups. This is especially relevant for reserve provision because a unit that provides reserves is linked to a regular, as well as a reserve node. It is then possible to constrain the unit's ramping for the combination of regular operation and reserve provision.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"Since reserve provision in fact literally reserves part of the capacity of a unit, the demand of the reserve node will be subtracted from the part that is available for regular operation. The section below will discuss how this works in SpineOpt by means of an example.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"Since the demand of the nodes is defined on the individual node level (and the node group has no demand), the balance type of the group node should be set to balance_type_none.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Ramping-constraints-on-a-node-group-with-one-reserve-node-1","page":"Ramping and reserves","title":"Ramping constraints on a node group with one reserve node","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#Reserves-step-1:-simple-case-of-unrestricted-unit-1","page":"Ramping and reserves","title":"Reserves step 1: simple case of unrestricted unit","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"Let's assume that we have one unit and two nodes in a model, one for reserves and one for regular demand. The unit is then linked by the unit__to_node relationships to each node individually, and on top of that, it is linked to a node group containing both nodes.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"The ramping of the unit can now be constrained by defining the same parameters as before, but now for the node group. As before, the simplest case is a unit that is only restricted by its capacity:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"max_shutdown_ramp  : 1\nmin_shutdown_ramp  : 0\nmax_start_up_ramp  : 1\nmin_start_up_ramp  : 0\nramp_up_limit      : 1\nramp_down_limit    : 1\nunit_capacity      : 200","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"The capacity restriction now implies that the sum of the reserve demand and regular demand cannot exceed the capacity of the unit. For example: when the reserve node has a demand of 10 in timestep t, the unit_flow variable to the regular node must be smaller than or equal to 190.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Reserves-step-2:-Spinning-ramp-restriction-1","page":"Ramping and reserves","title":"Reserves step 2: Spinning ramp restriction","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"The unit can be restricted only in spinning ramping, as in the previous example, by defining the ramp_up/down_limit parameters in the unit__to_node relationship for the node group:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"ramp_up_limit      : 0.2\nramp_down_limit    : 0.4","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"This parameter choice implies that the unit's flow to the regular demand node between two consecutive timesteps can change with no more than 02  * 200 - upward_reserve_demand and no less than 04 * 200 - downward_reserve_demand. For example, when the unit is running at an output of 100 in some timestep t, and there is an upward reserve demand of 10 its output for the next timestep must be somewhere in the interval 20130.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"It can be seen in this example that the demand for reserves is subtracted from both the generation capacity, and the ramping capacity of the unit that is available for regular operation. This stems from the fact that in providing reserve capacity, the unit is expected to be able to provide the demanded reserve within one timestep.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Reserves-Step-3:-Non-spinning-reserves-1","page":"Ramping and reserves","title":"Reserves Step 3: Non-spinning reserves","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"Units can also be allowed to provide non-spinning reserves, through shutdowns and startups. This can be done by using the following parameters in the unit__to_node relationship for the reserve node :  ","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"max_res_startup_ramp\nmin_res_startup_ramp","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"max_res_shutdown_ramp\nmin_res_shutdown_ramp","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"unit_capacity","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"These parameters are constraining reserve provision in exactly the same way as their equivalents for regular operation. Note that it is now necessary to define a capacity of the unit with respect to the reserve node. The ramping parameters will then be interpreted as fractions of this specific capacity, which can be taken different than the units overall capacity with respect to the node group.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"A unit which can provide both spinning and non-spinning reserves can be defined as follows:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"Parameters to be defined for unit to node group relationship","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"max_shutdown_ramp  : 1\nmin_shutdown_ramp  : 0\nmax_start_up_ramp  : 1\nmin_start_up_ramp  : 0\nramp_up_limit      : 0.2\nramp_down_limit    : 0.4\nunit_capacity      : 200","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"Parameters to be defined for unit to reserve node relationship","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"max_res_startup_ramp: 0.5\nmin_res_startup_ramp: 0.1\nunit_capacity: 150","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"The spinning reserve and ramping restrictions now remain the same as above, but on top of that the unit is able to provide non-spinning upward reserves when it is offline. In this particular example, the contribution of the offline unit to upward reserves can be anything in the interval [15,75].","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Using-node_groups-for-both-combined-and-individual-restrictions-1","page":"Ramping and reserves","title":"Using node_groups for both combined and individual restrictions","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"It can be seen from the example above that when a node group is defined, ramping restrictions can be imposed both on the group level (thus for the nit as a whole) as well as for the individual nodes. If, for example a ramp-up-limit is defined for the node group, the sum of upward ramping of the two nodes will be restricted by this parameter, but it is still possible to limit the individual flows to the nodes as well. We will now discuss an example of this for the ramp_up_limit, but this also holds for other parameters.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"Let's continue with the example above, where an online unit is capable of ramping up by 20% of its capacity and down by 40%. We might want to impose tighter restrictions for upward reserve provision than the ramping in overall operation (e.g. because the reserved capacity has to be available in a shorter time than the duration_unit). One can then simply define an additional parameter for the unit to reserve node relationship as follows.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"ramp_up_limit  : 0.15","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#","page":"Ramping and reserves","title":"Ramping and reserves","text":"Which now restricts the spinning upward ramping provision of the unit to 15% of its capacity, as defined for the reserve node. In this case, the change in the unit's flow to the regular demand node between two consecutive timesteps is still limited to the interval [0.2  * 200 - upward_reserve_demand, 0.4 * 200 - downward_reserve_demand]. But the upward reserves that it can provide has an upper bound of `150 * 015.","category":"page"},{"location":"concept_reference/connection_conv_cap_to_flow/#","page":"-","title":"-","text":"The connection_conv_cap_to_flow can be used to perform the conversion between the measurement unit of the connection_capacity to the measurement unit of the connection_flow variable. The default of this parameter is 1, i.e. assuming that both are given in the same measurement unit.","category":"page"},{"location":"concept_reference/max_voltage_angle/#","page":"-","title":"-","text":"If a node has a node_voltage_angle variable (see also the parameter has_voltage_angle and this chapter), an upper bound on the pressure can be introduced through the max_voltage_angle parameter, which triggers the generation of the maximum node voltage angle constraint.","category":"page"},{"location":"concept_reference/stochastic_structure/#","page":"-","title":"-","text":"The stochastic_structure is the key component of the scenario-based Stochastic Framework in SpineOpt.jl, and essentially represents a group of stochastic_scenarios with set Parameters. The stochastic_structure__stochastic_scenario relationship defines which stochastic_scenarios are included in which stochastic_structures, and the weight_relative_to_parents and stochastic_scenario_end Parameters define the exact shape and impact of the stochastic_structure, along with the parent_stochastic_scenario__child_stochastic_scenario relationship.","category":"page"},{"location":"concept_reference/stochastic_structure/#","page":"-","title":"-","text":"The main reason as to why stochastic_structures are so important is, that they act as handles connecting the Stochastic Framework to the modelled system. This is handled using the Structural relationship classes e.g. node__stochastic_structure, which define the stochastic_structure applied to each object describing the modelled system. Connecting each system object to the appropriate stochastic_structure individually can be a bit bothersome at times, so there are also a number of convenience Meta relationship classes like the model__default_stochastic_structure, which allow setting model-wide defaults to be used whenever specific definitions are missing.","category":"page"},{"location":"concept_reference/connection_flow_delay/#","page":"-","title":"-","text":"The connection_flow_delay parameter denotes the amount of time that it takes for the flow to go through a connection. In other words, the flow that enters the connection is only seen at the other side after connection_flow_delay units of time.","category":"page"},{"location":"concept_reference/constraint_sense_list/#","page":"-","title":"-","text":"The constraint_sense_list parameter value list contains the possible values for the constraint_sense parameter.","category":"page"},{"location":"concept_reference/min_res_startup_ramp/#","page":"-","title":"-","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning upward reserves are provided to an upward_reserve node by contracted offline units holding available to startup. If a unit is scheduled to provide nonspinning reserve, a limit on the minimum amount of reserves provided can be imposed by defining the parameter min_res_startup_ramp on a unit__to_node relationship, which triggers the constraint on minimum upward nonspinning reserve provision. The parameter min_res_startup_ramp is given as a fraction of the unit_capacity of the corresponding unit__to_node relationship.","category":"page"},{"location":"concept_reference/min_res_startup_ramp/#","page":"-","title":"-","text":"Note that to include the provision of nonspinning upward reserves, the parameter max_res_startup_ramp needs to be defined on the corresponding unit__to_node relationship, which triggers the generation of the variables nonspin_units_started_up and nonspin_ramp_upunitflow.","category":"page"},{"location":"concept_reference/min_res_startup_ramp/#","page":"-","title":"-","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/parent_stochastic_scenario__child_stochastic_scenario/#","page":"-","title":"-","text":"The parent_stochastic_scenario__child_stochastic_scenario relationship defines how the individual stochastic_scenarios are related to each other, forming what is referred to as the stochastic direct acyclic graph (DAG) in the Stochastic Framework section. It acts as a sort of basis for the stochastic_structures, but doesn't contain any Parameters necessary for describing how it relates to the Temporal Framework or the Objective function.","category":"page"},{"location":"concept_reference/parent_stochastic_scenario__child_stochastic_scenario/#","page":"-","title":"-","text":"The parent_stochastic_scenario__child_stochastic_scenario relationship and the stochastic DAG it forms are crucial for Constraint generation with stochastic path indexing. Every finite stochastic DAG has a limited number of unique ways of traversing it, called full stochastic paths, which are used when determining how many different constraints need to be generated over time periods where stochastic_structures branch or converge, or when generating constraints involving different stochastic_structures. See the Stochastic Framework section for more information.","category":"page"},{"location":"concept_reference/connection_linepack_constant/#","page":"-","title":"-","text":"The linepack constant is a physical property of a connection representing a pipeline and holds information how the linepack flexibility relates to pressures of the adjacent nodes. If, and only if, this parameter is defined, the linepack flexibility of a pipeline can be modelled. The existence of the parameter triggers the generation of the constraint on line pack storage. The [connection_linepack_constant] should always be defined on the tuple (connection pipeline, linepack storage node, node group (containing both pressure nodes, i.e. start and end of the pipeline)). See also.","category":"page"},{"location":"concept_reference/temporal_block/#","page":"-","title":"-","text":"A temporal block defines the temporal properties of the optimization that is to be solved in the current window. It is the key building block of the Temporal Framework. Most importantly, it holds the necessary information about the resolution and horizon of the optimization. A single model can have multiple temporal blocks, which is one of the main sources of temporal flexibility in Spine: by linking different parts of the model to different temporal blocks, a single model can contain aspects that are solved with different temporal resolutions or time horizons.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_out_out/#","page":"-","title":"-","text":"The min_units_on_coefficient_out_out parameter is an optinal coefficient in the unit output-output ratio constraint controlled by the min_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_out_out/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_in_out, and min_units_on_coefficient_out_in, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_out_out and fix_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/fix_ratio_in_out_unit_flow/#","page":"-","title":"-","text":"The definition of the fix_ratio_in_out_unit_flow parameter triggers the generation of the constraint_fix_ratio_in_out_unit_flow and fixes the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the from_node, i.e. the incoming flows to the unit, and the second node (or group of nodes), represents the to_node i.e. the outgoing flow from the unit. To enforce e.g. a fixed ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing gas flow to the node group el_heat (consisting of the two nodes el and heat), the fix_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/right_hand_side/#","page":"-","title":"-","text":"Used to specify the right-hand-side, constant term in a unit_constraint. See also unit_constraints.","category":"page"},{"location":"concept_reference/unit_incremental_heat_rate/#","page":"-","title":"-","text":"Used to implement simple or piecewise linear incremental heat rate functions. Used in the constraint unit_pw_heat_rate - the input fuel flow at node 1 is the sum of the electrical MW output at node 2 times the incremental heat rate over all heat rate segments, plus the unit_idle_heat_rate. The units are detmerined by the data, but generally, incremental heat rates are given in GJ/MWh. Note that the formulation assumes a convex, monitonically increasing heat rate function. The formulation relies on optimality to load the heat rate segments in the correct order and no additional integer variables are created to enforce the correct loading order. The heat rate segment MW operating points are defined by operating_points. ","category":"page"},{"location":"concept_reference/unit_incremental_heat_rate/#","page":"-","title":"-","text":"To implement a simple incremental heat rate function,unit_incremental_heat_rate should be given as a simple scalar representing the incremental heat rate over the entire operating range of the unit. To implement a piecewise linear heat rate function, unit_incremental_heat_rate should be specified as an array type. It is then used in conjunction with the unit parameter operating_points which should also be defined as an array type of equal dimension. When defined as an array type unit_incremental_heat_rate[i] is the effective incremental heat rate between operating_pointsi-1 and operating_points[i]. Note that operating_points is defined on a capacity-normalized basis so if operatingpoints is specified as [0.5, 1], this creates two operating segments, one from zero to 50% of the corresponding [unit\\capacity](@ref) and a second from 50% to 100% of the corresponding unit_capacity.","category":"page"},{"location":"advanced_concepts/Lossless_DC_power_flow/#Lossless-nodal-DC-power-flows-1","page":"Nodal loss-less DC powerflow","title":"Lossless nodal DC power flows","text":"","category":"section"},{"location":"advanced_concepts/Lossless_DC_power_flow/#","page":"Nodal loss-less DC powerflow","title":"Nodal loss-less DC powerflow","text":"Currently, there are two different methods to represent lossless DC power flows. In the following the implementation of the nodal model is presented, based of node voltage angles.","category":"page"},{"location":"advanced_concepts/Lossless_DC_power_flow/#key-concepts-advanced-nodal-DC-1","page":"Nodal loss-less DC powerflow","title":"Key concepts","text":"","category":"section"},{"location":"advanced_concepts/Lossless_DC_power_flow/#","page":"Nodal loss-less DC powerflow","title":"Nodal loss-less DC powerflow","text":"In the following, it is described how to set up a connection in order to represent a nodal lossless DC power flow network. Therefore, key object - and relationship classes as well as parameters are introduced.","category":"page"},{"location":"advanced_concepts/Lossless_DC_power_flow/#","page":"Nodal loss-less DC powerflow","title":"Nodal loss-less DC powerflow","text":"connection: A connection represents the electricity line being modelled. A physical property of the connection of a connection is its connection_reactance, which is defined on the connection object. Furthermore, if the reactance is given in a p.u. different from the standard unit used (e.g. p.u. = 100MVA), the parameter connection_reactance_base can be used to perform this conversion.\nnode: In a lossless DC power flow model, nodes correspond to busses. To use voltage angles for the representation of a lossless DC model, the has_voltage_angle needs to be true for these nodes (which will trigger the generation of the node_voltage_angle variable). Limits on the voltage angle can be enforced through the max_voltage_angle and min_voltage_angle parameters. The reference node of the system should have a voltage angle equal to zero, assigned through the parameter fix_node_voltage_angle.\nconnection__to_node and connection__from_node : These relationships need to be introduced between the connection and each node, in order to allow power flows (i.e. connection_flow). Furthermore, a capacity limit on the connection line can be introduced on these relationships through the parameter connection_capacity.\nconnection__node__node: To ensure energy conservation across the power line, a fixed ratio between incoming and outgoing flows should be given. The fix_ratio_out_in_connection_flow parameter enforces a fixed ratio between outgoing flows (i.e. to_node) and incoming flows (i.e. from_node). This parameter should be defined for both flow direction.","category":"page"},{"location":"advanced_concepts/Lossless_DC_power_flow/#","page":"Nodal loss-less DC powerflow","title":"Nodal loss-less DC powerflow","text":"The mathematical formulation of the lossless DC power flow model using voltage angles is fully described here.","category":"page"},{"location":"concept_reference/max_ratio_in_in_unit_flow/#","page":"-","title":"-","text":"The definition of the max_ratio_in_in_unit_flow parameter triggers the generation of the constraint_max_ratio_in_in_unit_flow and enforces an upper bound on the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply. To enforce e.g. for a unit u a maximum share of 0.8 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the max_ratio_in_in_unit_flow parameter would be set to 0.8 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/model__default_stochastic_structure/#","page":"-","title":"-","text":"The model__default_stochastic_structure relationship can be used to set a model-wide default for the node__stochastic_structure and units_on__stochastic_structure relationships. Its main purpose is to allow users to avoid defining each relationship individually, and instead allow them to focus on defining only the exceptions. As such, any specific node__stochastic_structure or units_on__stochastic_structure relationships take priority over the model__default_stochastic_structure relationship.","category":"page"},{"location":"concept_reference/connection__from_node__unit_constraint/#","page":"-","title":"-","text":"connection__from_node__unit_constraint is a three-dimensional relationship between a connection, a node and a unit_constraint. The relationship specifies that the connection_flow variable to the specified connection from the specified node is involved in the specified unit_constraint. Parameters on this relationship generally apply to this specific connection_flow variable. For example the parameter connectionflowcoefficient defined on connection__from_node__unit_constraint represents the coefficient on the specific connection_flow variable in the specified unit_constraint","category":"page"},{"location":"concept_reference/storage_investment_lifetime/#","page":"-","title":"-","text":"Duration parameter that determines the minimum duration of storage investment decisions. Once a storage has been invested-in, it must remain invested-in for storage_investment_lifetime. Note that storage_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/storage_investment_lifetime/#","page":"-","title":"-","text":"See also investment_optimization and candidate_storages","category":"page"},{"location":"concept_reference/unit_flow_coefficient/#","page":"-","title":"-","text":"The unit_flow_coefficient is an optional parameter that can be used to include the unit_flow or unit_flow_op variables from or to a node in a unit_constraint via the unit__from_node__unit_constraint and unit__to_node__unit_constraint relationships. Essentially, unit_flow_coefficient appears as a coefficient for the unit_flow and unit_flow_op variables from or to the node in the unit constraint.","category":"page"},{"location":"concept_reference/max_iterations/#","page":"-","title":"-","text":"When the model in question is of type :spineopt_master, this determines the maximum number of Benders iterations.","category":"page"},{"location":"concept_reference/weight_relative_to_parents/#","page":"-","title":"-","text":"The weight_relative_to_parents parameter defines how much weight the stochastic_scenario gets in the Objective function. As a stochastic_structure__stochastic_scenario relationship parameter, different  stochastic_structures can use different weights for the same stochastic_scenario. Note that every stochastic_scenario that appears in the model must have a weight_relative_to_parents defined for it related to the used stochastic_structure! See the Stochastic Framework section for more information about how different stochastic_structures interact in SpineOpt.jl.)","category":"page"},{"location":"concept_reference/weight_relative_to_parents/#","page":"-","title":"-","text":"Since the Stochastic Framework in SpineOpt.jl supports stochastic directed acyclic graphs instead of simple stochastic trees, it is possible to define stochastic_structures with converging stochastic_scenarios. In these cases, the child stochastic_scenarios inherint the weight of all of their parents, and the final weight that will appear in the Objective function is calculated as shown below:","category":"page"},{"location":"concept_reference/weight_relative_to_parents/#","page":"-","title":"-","text":"# For root `stochastic_scenarios` (meaning no parents)\n\nweight(scenario) = weight_relative_to_parents(scenario)\n\n# If not a root `stochastic_scenario`\n\nweight(scenario) = sum([weight(parent) * weight_relative_to_parents(scenario)] for parent in parents)","category":"page"},{"location":"concept_reference/weight_relative_to_parents/#","page":"-","title":"-","text":"The above calculation is performed starting from the roots, generation by generation, until the leaves of the stochastic DAG. Thus, the final weight of each stochastic_scenario is dependent on the weight_relative_to_parents Parameters of all its ancestors.","category":"page"},{"location":"concept_reference/connection__to_node/#","page":"-","title":"-","text":"connection__to_node is a two-dimensional relationship between a connection and a node and implies a connection_flow from the connection to the node. Specifying such a relationship will give rise to a connection_flow_variable with indices connection=connection, node=node, direction=:to_node. Relationships defined on this relationship will generally apply to this specific flow variable. For example, connection_capacity will apply only to this specific flow variable, unless the connection parameter connection_type is specified.","category":"page"},{"location":"concept_reference/stochastic_structure__stochastic_scenario/#","page":"-","title":"-","text":"The stochastic_structure__stochastic_scenario relationship defines which stochastic_scenarios are included in which stochastic_structure, as well as holds the stochastic_scenario_end and weight_relative_to_parents Parameters defining how the stochastic_structure interacts with the Temporal Framework and the Objective function. Along with parent_stochastic_scenario__child_stochastic_scenario, this relationship is used to define the exact properties of each stochastic_structure, which are then applied to the objects describing the modelled system according to the Structural relationship classes, like the node__stochastic_structure relationship.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_in_out/#","page":"-","title":"-","text":"The min_units_on_coefficient_in_out parameter is an optinal coefficient in the unit input-output ratio constraint controlled by the min_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_in_out/#","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_out_in, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_in_out and fix_units_on_coefficient_in_out.","category":"page"}]
}
